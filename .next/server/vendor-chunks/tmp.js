"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/tmp";
exports.ids = ["vendor-chunks/tmp"];
exports.modules = {

/***/ "(rsc)/./node_modules/tmp/lib/tmp.js":
/*!*************************************!*\
  !*** ./node_modules/tmp/lib/tmp.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Tmp\n *\n * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */ /*\n * Module dependencies.\n */ \nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst _c = {\n    fs: fs.constants,\n    os: os.constants\n};\n/*\n * The working inner variables.\n */ const // the random characters to choose from\nRANDOM_CHARS = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", TEMPLATE_PATTERN = /XXXXXX/, DEFAULT_TRIES = 3, CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR), // constants are off on the windows platform and will not match the actual errno codes\nIS_WIN32 = os.platform() === \"win32\", EBADF = _c.EBADF || _c.os.errno.EBADF, ENOENT = _c.ENOENT || _c.os.errno.ENOENT, DIR_MODE = 448 /* 448 */ , FILE_MODE = 384 /* 384 */ , EXIT = \"exit\", // this will hold the objects need to be removed on exit\n_removeObjects = [], // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback\nFN_RMDIR_SYNC = fs.rmdirSync.bind(fs);\nlet _gracefulCleanup = false;\n/**\n * Recursively remove a directory and its contents.\n *\n * @param {string} dirPath path of directory to remove\n * @param {Function} callback\n * @private\n */ function rimraf(dirPath, callback) {\n    return fs.rm(dirPath, {\n        recursive: true\n    }, callback);\n}\n/**\n * Recursively remove a directory and its contents, synchronously.\n *\n * @param {string} dirPath path of directory to remove\n * @private\n */ function FN_RIMRAF_SYNC(dirPath) {\n    return fs.rmSync(dirPath, {\n        recursive: true\n    });\n}\n/**\n * Gets a temporary file name.\n *\n * @param {(Options|tmpNameCallback)} options options or callback\n * @param {?tmpNameCallback} callback the callback function\n */ function tmpName(options, callback) {\n    const args = _parseArguments(options, callback), opts = args[0], cb = args[1];\n    try {\n        _assertAndSanitizeOptions(opts);\n    } catch (err) {\n        return cb(err);\n    }\n    let tries = opts.tries;\n    (function _getUniqueName() {\n        try {\n            const name = _generateTmpName(opts);\n            // check whether the path exists then retry if needed\n            fs.stat(name, function(err) {\n                /* istanbul ignore else */ if (!err) {\n                    /* istanbul ignore else */ if (tries-- > 0) return _getUniqueName();\n                    return cb(new Error(\"Could not get a unique tmp filename, max tries reached \" + name));\n                }\n                cb(null, name);\n            });\n        } catch (err) {\n            cb(err);\n        }\n    })();\n}\n/**\n * Synchronous version of tmpName.\n *\n * @param {Object} options\n * @returns {string} the generated random name\n * @throws {Error} if the options are invalid or could not generate a filename\n */ function tmpNameSync(options) {\n    const args = _parseArguments(options), opts = args[0];\n    _assertAndSanitizeOptions(opts);\n    let tries = opts.tries;\n    do {\n        const name = _generateTmpName(opts);\n        try {\n            fs.statSync(name);\n        } catch (e) {\n            return name;\n        }\n    }while (tries-- > 0);\n    throw new Error(\"Could not get a unique tmp filename, max tries reached\");\n}\n/**\n * Creates and opens a temporary file.\n *\n * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined\n * @param {?fileCallback} callback\n */ function file(options, callback) {\n    const args = _parseArguments(options, callback), opts = args[0], cb = args[1];\n    // gets a temporary filename\n    tmpName(opts, function _tmpNameCreated(err, name) {\n        /* istanbul ignore else */ if (err) return cb(err);\n        // create and open the file\n        fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n            /* istanbu ignore else */ if (err) return cb(err);\n            if (opts.discardDescriptor) {\n                return fs.close(fd, function _discardCallback(possibleErr) {\n                    // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only\n                    return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));\n                });\n            } else {\n                // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care\n                // about the descriptor\n                const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n                cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));\n            }\n        });\n    });\n}\n/**\n * Synchronous version of file.\n *\n * @param {Options} options\n * @returns {FileSyncObject} object consists of name, fd and removeCallback\n * @throws {Error} if cannot create a file\n */ function fileSync(options) {\n    const args = _parseArguments(options), opts = args[0];\n    const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;\n    const name = tmpNameSync(opts);\n    var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n    /* istanbul ignore else */ if (opts.discardDescriptor) {\n        fs.closeSync(fd);\n        fd = undefined;\n    }\n    return {\n        name: name,\n        fd: fd,\n        removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)\n    };\n}\n/**\n * Creates a temporary directory.\n *\n * @param {(Options|dirCallback)} options the options or the callback function\n * @param {?dirCallback} callback\n */ function dir(options, callback) {\n    const args = _parseArguments(options, callback), opts = args[0], cb = args[1];\n    // gets a temporary filename\n    tmpName(opts, function _tmpNameCreated(err, name) {\n        /* istanbul ignore else */ if (err) return cb(err);\n        // create the directory\n        fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n            /* istanbul ignore else */ if (err) return cb(err);\n            cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));\n        });\n    });\n}\n/**\n * Synchronous version of dir.\n *\n * @param {Options} options\n * @returns {DirSyncObject} object consists of name and removeCallback\n * @throws {Error} if it cannot create a directory\n */ function dirSync(options) {\n    const args = _parseArguments(options), opts = args[0];\n    const name = tmpNameSync(opts);\n    fs.mkdirSync(name, opts.mode || DIR_MODE);\n    return {\n        name: name,\n        removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)\n    };\n}\n/**\n * Removes files asynchronously.\n *\n * @param {Object} fdPath\n * @param {Function} next\n * @private\n */ function _removeFileAsync(fdPath, next) {\n    const _handler = function(err) {\n        if (err && !_isENOENT(err)) {\n            // reraise any unanticipated error\n            return next(err);\n        }\n        next();\n    };\n    if (0 <= fdPath[0]) fs.close(fdPath[0], function() {\n        fs.unlink(fdPath[1], _handler);\n    });\n    else fs.unlink(fdPath[1], _handler);\n}\n/**\n * Removes files synchronously.\n *\n * @param {Object} fdPath\n * @private\n */ function _removeFileSync(fdPath) {\n    let rethrownException = null;\n    try {\n        if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);\n    } catch (e) {\n        // reraise any unanticipated error\n        if (!_isEBADF(e) && !_isENOENT(e)) throw e;\n    } finally{\n        try {\n            fs.unlinkSync(fdPath[1]);\n        } catch (e) {\n            // reraise any unanticipated error\n            if (!_isENOENT(e)) rethrownException = e;\n        }\n    }\n    if (rethrownException !== null) {\n        throw rethrownException;\n    }\n}\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * Returns either a sync callback or a async callback depending on whether\n * fileSync or file was called, which is expressed by the sync parameter.\n *\n * @param {string} name the path of the file\n * @param {number} fd file descriptor\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {fileCallback | fileCallbackSync}\n * @private\n */ function _prepareTmpFileRemoveCallback(name, fd, opts, sync) {\n    const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [\n        fd,\n        name\n    ], sync);\n    const removeCallback = _prepareRemoveCallback(_removeFileAsync, [\n        fd,\n        name\n    ], sync, removeCallbackSync);\n    if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n    return sync ? removeCallbackSync : removeCallback;\n}\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * Returns either a sync callback or a async callback depending on whether\n * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.\n *\n * @param {string} name\n * @param {Object} opts\n * @param {boolean} sync\n * @returns {Function} the callback\n * @private\n */ function _prepareTmpDirRemoveCallback(name, opts, sync) {\n    const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);\n    const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;\n    const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);\n    const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);\n    if (!opts.keep) _removeObjects.unshift(removeCallbackSync);\n    return sync ? removeCallbackSync : removeCallback;\n}\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * The cleanup callback is save to be called multiple times.\n * Subsequent invocations will be ignored.\n *\n * @param {Function} removeFunction\n * @param {string} fileOrDirName\n * @param {boolean} sync\n * @param {cleanupCallbackSync?} cleanupCallbackSync\n * @returns {cleanupCallback | cleanupCallbackSync}\n * @private\n */ function _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {\n    let called = false;\n    // if sync is true, the next parameter will be ignored\n    return function _cleanupCallback(next) {\n        /* istanbul ignore else */ if (!called) {\n            // remove cleanupCallback from cache\n            const toRemove = cleanupCallbackSync || _cleanupCallback;\n            const index = _removeObjects.indexOf(toRemove);\n            /* istanbul ignore else */ if (index >= 0) _removeObjects.splice(index, 1);\n            called = true;\n            if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {\n                return removeFunction(fileOrDirName);\n            } else {\n                return removeFunction(fileOrDirName, next || function() {});\n            }\n        }\n    };\n}\n/**\n * The garbage collector.\n *\n * @private\n */ function _garbageCollector() {\n    /* istanbul ignore else */ if (!_gracefulCleanup) return;\n    // the function being called removes itself from _removeObjects,\n    // loop until _removeObjects is empty\n    while(_removeObjects.length){\n        try {\n            _removeObjects[0]();\n        } catch (e) {\n        // already removed?\n        }\n    }\n}\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {number} howMany\n * @returns {string} the generated random name\n * @private\n */ function _randomChars(howMany) {\n    let value = [], rnd = null;\n    // make sure that we do not fail because we ran out of entropy\n    try {\n        rnd = crypto.randomBytes(howMany);\n    } catch (e) {\n        rnd = crypto.pseudoRandomBytes(howMany);\n    }\n    for(var i = 0; i < howMany; i++){\n        value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n    }\n    return value.join(\"\");\n}\n/**\n * Helper which determines whether a string s is blank, that is undefined, or empty or null.\n *\n * @private\n * @param {string} s\n * @returns {Boolean} true whether the string s is blank, false otherwise\n */ function _isBlank(s) {\n    return s === null || _isUndefined(s) || !s.trim();\n}\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @returns {boolean} true if the object is undefined\n * @private\n */ function _isUndefined(obj) {\n    return typeof obj === \"undefined\";\n}\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {(Options|null|undefined|Function)} options\n * @param {?Function} callback\n * @returns {Array} parsed arguments\n * @private\n */ function _parseArguments(options, callback) {\n    /* istanbul ignore else */ if (typeof options === \"function\") {\n        return [\n            {},\n            options\n        ];\n    }\n    /* istanbul ignore else */ if (_isUndefined(options)) {\n        return [\n            {},\n            callback\n        ];\n    }\n    // copy options so we do not leak the changes we make internally\n    const actualOptions = {};\n    for (const key of Object.getOwnPropertyNames(options)){\n        actualOptions[key] = options[key];\n    }\n    return [\n        actualOptions,\n        callback\n    ];\n}\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {string} the new random name according to opts\n * @private\n */ function _generateTmpName(opts) {\n    const tmpDir = opts.tmpdir;\n    /* istanbul ignore else */ if (!_isUndefined(opts.name)) return path.join(tmpDir, opts.dir, opts.name);\n    /* istanbul ignore else */ if (!_isUndefined(opts.template)) return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));\n    // prefix and postfix\n    const name = [\n        opts.prefix ? opts.prefix : \"tmp\",\n        \"-\",\n        process.pid,\n        \"-\",\n        _randomChars(12),\n        opts.postfix ? \"-\" + opts.postfix : \"\"\n    ].join(\"\");\n    return path.join(tmpDir, opts.dir, name);\n}\n/**\n * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing\n * options.\n *\n * @param {Options} options\n * @private\n */ function _assertAndSanitizeOptions(options) {\n    options.tmpdir = _getTmpDir(options);\n    const tmpDir = options.tmpdir;\n    /* istanbul ignore else */ if (!_isUndefined(options.name)) _assertIsRelative(options.name, \"name\", tmpDir);\n    /* istanbul ignore else */ if (!_isUndefined(options.dir)) _assertIsRelative(options.dir, \"dir\", tmpDir);\n    /* istanbul ignore else */ if (!_isUndefined(options.template)) {\n        _assertIsRelative(options.template, \"template\", tmpDir);\n        if (!options.template.match(TEMPLATE_PATTERN)) throw new Error(`Invalid template, found \"${options.template}\".`);\n    }\n    /* istanbul ignore else */ if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0) throw new Error(`Invalid tries, found \"${options.tries}\".`);\n    // if a name was specified we will try once\n    options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;\n    options.keep = !!options.keep;\n    options.detachDescriptor = !!options.detachDescriptor;\n    options.discardDescriptor = !!options.discardDescriptor;\n    options.unsafeCleanup = !!options.unsafeCleanup;\n    // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to\n    options.dir = _isUndefined(options.dir) ? \"\" : path.relative(tmpDir, _resolvePath(options.dir, tmpDir));\n    options.template = _isUndefined(options.template) ? undefined : path.relative(tmpDir, _resolvePath(options.template, tmpDir));\n    // sanitize further if template is relative to options.dir\n    options.template = _isBlank(options.template) ? undefined : path.relative(options.dir, options.template);\n    // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to\n    options.name = _isUndefined(options.name) ? undefined : options.name;\n    options.prefix = _isUndefined(options.prefix) ? \"\" : options.prefix;\n    options.postfix = _isUndefined(options.postfix) ? \"\" : options.postfix;\n}\n/**\n * Resolve the specified path name in respect to tmpDir.\n *\n * The specified name might include relative path components, e.g. ../\n * so we need to resolve in order to be sure that is is located inside tmpDir\n *\n * @param name\n * @param tmpDir\n * @returns {string}\n * @private\n */ function _resolvePath(name, tmpDir) {\n    if (name.startsWith(tmpDir)) {\n        return path.resolve(name);\n    } else {\n        return path.resolve(path.join(tmpDir, name));\n    }\n}\n/**\n * Asserts whether specified name is relative to the specified tmpDir.\n *\n * @param {string} name\n * @param {string} option\n * @param {string} tmpDir\n * @throws {Error}\n * @private\n */ function _assertIsRelative(name, option, tmpDir) {\n    if (option === \"name\") {\n        // assert that name is not absolute and does not contain a path\n        if (path.isAbsolute(name)) throw new Error(`${option} option must not contain an absolute path, found \"${name}\".`);\n        // must not fail on valid .<name> or ..<name> or similar such constructs\n        let basename = path.basename(name);\n        if (basename === \"..\" || basename === \".\" || basename !== name) throw new Error(`${option} option must not contain a path, found \"${name}\".`);\n    } else {\n        // assert that dir or template are relative to tmpDir\n        if (path.isAbsolute(name) && !name.startsWith(tmpDir)) {\n            throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${name}\".`);\n        }\n        let resolvedPath = _resolvePath(name, tmpDir);\n        if (!resolvedPath.startsWith(tmpDir)) throw new Error(`${option} option must be relative to \"${tmpDir}\", found \"${resolvedPath}\".`);\n    }\n}\n/**\n * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */ function _isEBADF(error) {\n    return _isExpectedError(error, -EBADF, \"EBADF\");\n}\n/**\n * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.\n *\n * @private\n */ function _isENOENT(error) {\n    return _isExpectedError(error, -ENOENT, \"ENOENT\");\n}\n/**\n * Helper to determine whether the expected error code matches the actual code and errno,\n * which will differ between the supported node versions.\n *\n * - Node >= 7.0:\n *   error.code {string}\n *   error.errno {number} any numerical value will be negated\n *\n * CAVEAT\n *\n * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT\n * is no different here.\n *\n * @param {SystemError} error\n * @param {number} errno\n * @param {string} code\n * @private\n */ function _isExpectedError(error, errno, code) {\n    return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;\n}\n/**\n * Sets the graceful cleanup.\n *\n * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the\n * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary\n * object removals.\n */ function setGracefulCleanup() {\n    _gracefulCleanup = true;\n}\n/**\n * Returns the currently configured tmp dir from os.tmpdir().\n *\n * @private\n * @param {?Options} options\n * @returns {string} the currently configured tmp dir\n */ function _getTmpDir(options) {\n    return path.resolve(options && options.tmpdir || os.tmpdir());\n}\n// Install process exit listener\nprocess.addListener(EXIT, _garbageCollector);\n/**\n * Configuration options.\n *\n * @typedef {Object} Options\n * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected\n * @property {?number} tries the number of tries before give up the name generation\n * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files\n * @property {?string} template the \"mkstemp\" like filename template\n * @property {?string} name fixed name relative to tmpdir or the specified dir option\n * @property {?string} dir tmp directory relative to the root tmp directory in use\n * @property {?string} prefix prefix for the generated name\n * @property {?string} postfix postfix for the generated name\n * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir\n * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty\n * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection\n * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection\n */ /**\n * @typedef {Object} FileSyncObject\n * @property {string} name the name of the file\n * @property {string} fd the file descriptor or -1 if the fd has been discarded\n * @property {fileCallback} removeCallback the callback function to remove the file\n */ /**\n * @typedef {Object} DirSyncObject\n * @property {string} name the name of the directory\n * @property {fileCallback} removeCallback the callback function to remove the directory\n */ /**\n * @callback tmpNameCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n */ /**\n * @callback fileCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallback} fn the cleanup callback function\n */ /**\n * @callback fileCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {number} fd the file descriptor or -1 if the fd had been discarded\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */ /**\n * @callback dirCallback\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallback} fn the cleanup callback function\n */ /**\n * @callback dirCallbackSync\n * @param {?Error} err the error object if anything goes wrong\n * @param {string} name the temporary file name\n * @param {cleanupCallbackSync} fn the cleanup callback function\n */ /**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallback\n * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed\n */ /**\n * Removes the temporary created file or directory.\n *\n * @callback cleanupCallbackSync\n */ /**\n * Callback function for function composition.\n * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}\n *\n * @callback simpleCallback\n */ // exporting all the needed methods\n// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will\n// allow users to reconfigure the temporary directory\nObject.defineProperty(module.exports, \"tmpdir\", ({\n    enumerable: true,\n    configurable: false,\n    get: function() {\n        return _getTmpDir();\n    }\n}));\nmodule.exports.dir = dir;\nmodule.exports.dirSync = dirSync;\nmodule.exports.file = file;\nmodule.exports.fileSync = fileSync;\nmodule.exports.tmpName = tmpName;\nmodule.exports.tmpNameSync = tmpNameSync;\nmodule.exports.setGracefulCleanup = setGracefulCleanup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDNUgsUUFBUTtBQUMxQztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNELFNBQVM2SCxpQkFBaUJELEtBQUssRUFBRTdILEtBQUssRUFBRStILElBQUk7SUFDMUMsT0FBT2xJLFdBQVdnSSxNQUFNRSxJQUFJLEtBQUtBLE9BQU9GLE1BQU1FLElBQUksS0FBS0EsUUFBUUYsTUFBTTdILEtBQUssS0FBS0E7QUFDakY7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTZ0k7SUFDUHZILG1CQUFtQjtBQUNyQjtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVN3RyxXQUFXL0YsT0FBTztJQUN6QixPQUFPaEMsS0FBS3NJLE9BQU8sQ0FBQ3RHLFdBQVdBLFFBQVF3RixNQUFNLElBQUl6SCxHQUFHeUgsTUFBTTtBQUM1RDtBQUVBLGdDQUFnQztBQUNoQ0ksUUFBUW1CLFdBQVcsQ0FBQzdILE1BQU1pRjtBQUUxQjs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUVEOzs7OztDQUtDLEdBRUQ7Ozs7Q0FJQyxHQUVEOzs7O0NBSUMsR0FFRDs7Ozs7O0NBTUMsR0FFRDs7Ozs7O0NBTUMsR0FFRDs7Ozs7Q0FLQyxHQUVEOzs7OztDQUtDLEdBRUQ7Ozs7O0NBS0MsR0FFRDs7OztDQUlDLEdBRUQ7Ozs7O0NBS0MsR0FFRCxtQ0FBbUM7QUFFbkMsZ0ZBQWdGO0FBQ2hGLHFEQUFxRDtBQUNyRGtCLGlEQUFnRDtJQUM5QzhCLFlBQVk7SUFDWkMsY0FBYztJQUNkQyxLQUFLO1FBQ0gsT0FBT3RCO0lBQ1Q7QUFDRixDQUFDLEVBQUM7QUFFRmtCLGtCQUFrQixHQUFHL0U7QUFDckIrRSxzQkFBc0IsR0FBRzNFO0FBRXpCMkUsbUJBQW1CLEdBQUdqRztBQUN0QmlHLHVCQUF1QixHQUFHbkY7QUFFMUJtRixzQkFBc0IsR0FBR2xIO0FBQ3pCa0gsMEJBQTBCLEdBQUdwRztBQUU3Qm9HLGlDQUFpQyxHQUFHSCIsInNvdXJjZXMiOlsid2VicGFjazovL2Jpa2UtcmVudGFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvdG1wL2xpYi90bXAuanM/ODhkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFRtcFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDE3IEtBUkFTWkkgSXN0dmFuIDxnaXRodWJAc3BhbS5yYXN6aS5odT5cbiAqXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgX2MgPSB7IGZzOiBmcy5jb25zdGFudHMsIG9zOiBvcy5jb25zdGFudHMgfTtcblxuLypcbiAqIFRoZSB3b3JraW5nIGlubmVyIHZhcmlhYmxlcy5cbiAqL1xuY29uc3RcbiAgLy8gdGhlIHJhbmRvbSBjaGFyYWN0ZXJzIHRvIGNob29zZSBmcm9tXG4gIFJBTkRPTV9DSEFSUyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicsXG5cbiAgVEVNUExBVEVfUEFUVEVSTiA9IC9YWFhYWFgvLFxuXG4gIERFRkFVTFRfVFJJRVMgPSAzLFxuXG4gIENSRUFURV9GTEFHUyA9IChfYy5PX0NSRUFUIHx8IF9jLmZzLk9fQ1JFQVQpIHwgKF9jLk9fRVhDTCB8fCBfYy5mcy5PX0VYQ0wpIHwgKF9jLk9fUkRXUiB8fCBfYy5mcy5PX1JEV1IpLFxuXG4gIC8vIGNvbnN0YW50cyBhcmUgb2ZmIG9uIHRoZSB3aW5kb3dzIHBsYXRmb3JtIGFuZCB3aWxsIG5vdCBtYXRjaCB0aGUgYWN0dWFsIGVycm5vIGNvZGVzXG4gIElTX1dJTjMyID0gb3MucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJyxcbiAgRUJBREYgPSBfYy5FQkFERiB8fCBfYy5vcy5lcnJuby5FQkFERixcbiAgRU5PRU5UID0gX2MuRU5PRU5UIHx8IF9jLm9zLmVycm5vLkVOT0VOVCxcblxuICBESVJfTU9ERSA9IDBvNzAwIC8qIDQ0OCAqLyxcbiAgRklMRV9NT0RFID0gMG82MDAgLyogMzg0ICovLFxuXG4gIEVYSVQgPSAnZXhpdCcsXG5cbiAgLy8gdGhpcyB3aWxsIGhvbGQgdGhlIG9iamVjdHMgbmVlZCB0byBiZSByZW1vdmVkIG9uIGV4aXRcbiAgX3JlbW92ZU9iamVjdHMgPSBbXSxcblxuICAvLyBBUEkgY2hhbmdlIGluIGZzLnJtZGlyU3luYyBsZWFkcyB0byBlcnJvciB3aGVuIHBhc3NpbmcgaW4gYSBzZWNvbmQgcGFyYW1ldGVyLCBlLmcuIHRoZSBjYWxsYmFja1xuICBGTl9STURJUl9TWU5DID0gZnMucm1kaXJTeW5jLmJpbmQoZnMpO1xuXG5sZXRcbiAgX2dyYWNlZnVsQ2xlYW51cCA9IGZhbHNlO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHJlbW92ZSBhIGRpcmVjdG9yeSBhbmQgaXRzIGNvbnRlbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXJQYXRoIHBhdGggb2YgZGlyZWN0b3J5IHRvIHJlbW92ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJpbXJhZihkaXJQYXRoLCBjYWxsYmFjaykge1xuICByZXR1cm4gZnMucm0oZGlyUGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHJlbW92ZSBhIGRpcmVjdG9yeSBhbmQgaXRzIGNvbnRlbnRzLCBzeW5jaHJvbm91c2x5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXJQYXRoIHBhdGggb2YgZGlyZWN0b3J5IHRvIHJlbW92ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRk5fUklNUkFGX1NZTkMoZGlyUGF0aCkge1xuICByZXR1cm4gZnMucm1TeW5jKGRpclBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xufVxuXG4vKipcbiAqIEdldHMgYSB0ZW1wb3JhcnkgZmlsZSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7KE9wdGlvbnN8dG1wTmFtZUNhbGxiYWNrKX0gb3B0aW9ucyBvcHRpb25zIG9yIGNhbGxiYWNrXG4gKiBAcGFyYW0gez90bXBOYW1lQ2FsbGJhY2t9IGNhbGxiYWNrIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICovXG5mdW5jdGlvbiB0bXBOYW1lKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0XG4gICAgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zLCBjYWxsYmFjayksXG4gICAgb3B0cyA9IGFyZ3NbMF0sXG4gICAgY2IgPSBhcmdzWzFdO1xuXG4gIHRyeSB7XG4gICAgX2Fzc2VydEFuZFNhbml0aXplT3B0aW9ucyhvcHRzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGNiKGVycik7XG4gIH1cblxuICBsZXQgdHJpZXMgPSBvcHRzLnRyaWVzO1xuICAoZnVuY3Rpb24gX2dldFVuaXF1ZU5hbWUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBfZ2VuZXJhdGVUbXBOYW1lKG9wdHMpO1xuXG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBwYXRoIGV4aXN0cyB0aGVuIHJldHJ5IGlmIG5lZWRlZFxuICAgICAgZnMuc3RhdChuYW1lLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICBpZiAodHJpZXMtLSA+IDApIHJldHVybiBfZ2V0VW5pcXVlTmFtZSgpO1xuXG4gICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignQ291bGQgbm90IGdldCBhIHVuaXF1ZSB0bXAgZmlsZW5hbWUsIG1heCB0cmllcyByZWFjaGVkICcgKyBuYW1lKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjYihudWxsLCBuYW1lKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH0oKSk7XG59XG5cbi8qKlxuICogU3luY2hyb25vdXMgdmVyc2lvbiBvZiB0bXBOYW1lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgZ2VuZXJhdGVkIHJhbmRvbSBuYW1lXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIG9wdGlvbnMgYXJlIGludmFsaWQgb3IgY291bGQgbm90IGdlbmVyYXRlIGEgZmlsZW5hbWVcbiAqL1xuZnVuY3Rpb24gdG1wTmFtZVN5bmMob3B0aW9ucykge1xuICBjb25zdFxuICAgIGFyZ3MgPSBfcGFyc2VBcmd1bWVudHMob3B0aW9ucyksXG4gICAgb3B0cyA9IGFyZ3NbMF07XG5cbiAgX2Fzc2VydEFuZFNhbml0aXplT3B0aW9ucyhvcHRzKTtcblxuICBsZXQgdHJpZXMgPSBvcHRzLnRyaWVzO1xuICBkbyB7XG4gICAgY29uc3QgbmFtZSA9IF9nZW5lcmF0ZVRtcE5hbWUob3B0cyk7XG4gICAgdHJ5IHtcbiAgICAgIGZzLnN0YXRTeW5jKG5hbWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgfSB3aGlsZSAodHJpZXMtLSA+IDApO1xuXG4gIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBhIHVuaXF1ZSB0bXAgZmlsZW5hbWUsIG1heCB0cmllcyByZWFjaGVkJyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgb3BlbnMgYSB0ZW1wb3JhcnkgZmlsZS5cbiAqXG4gKiBAcGFyYW0geyhPcHRpb25zfG51bGx8dW5kZWZpbmVkfGZpbGVDYWxsYmFjayl9IG9wdGlvbnMgdGhlIGNvbmZpZyBvcHRpb25zIG9yIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBvciBudWxsIG9yIHVuZGVmaW5lZFxuICogQHBhcmFtIHs/ZmlsZUNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBmaWxlKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0XG4gICAgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zLCBjYWxsYmFjayksXG4gICAgb3B0cyA9IGFyZ3NbMF0sXG4gICAgY2IgPSBhcmdzWzFdO1xuXG4gIC8vIGdldHMgYSB0ZW1wb3JhcnkgZmlsZW5hbWVcbiAgdG1wTmFtZShvcHRzLCBmdW5jdGlvbiBfdG1wTmFtZUNyZWF0ZWQoZXJyLCBuYW1lKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcblxuICAgIC8vIGNyZWF0ZSBhbmQgb3BlbiB0aGUgZmlsZVxuICAgIGZzLm9wZW4obmFtZSwgQ1JFQVRFX0ZMQUdTLCBvcHRzLm1vZGUgfHwgRklMRV9NT0RFLCBmdW5jdGlvbiBfZmlsZUNyZWF0ZWQoZXJyLCBmZCkge1xuICAgICAgLyogaXN0YW5idSBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGlmIChvcHRzLmRpc2NhcmREZXNjcmlwdG9yKSB7XG4gICAgICAgIHJldHVybiBmcy5jbG9zZShmZCwgZnVuY3Rpb24gX2Rpc2NhcmRDYWxsYmFjayhwb3NzaWJsZUVycikge1xuICAgICAgICAgIC8vIHRoZSBjaGFuY2Ugb2YgZ2V0dGluZyBhbiBlcnJvciBvbiBjbG9zZSBoZXJlIGlzIHJhdGhlciBsb3cgYW5kIG1pZ2h0IG9jY3VyIGluIHRoZSBtb3N0IGVkZ2llc3QgY2FzZXMgb25seVxuICAgICAgICAgIHJldHVybiBjYihwb3NzaWJsZUVyciwgbmFtZSwgdW5kZWZpbmVkLCBfcHJlcGFyZVRtcEZpbGVSZW1vdmVDYWxsYmFjayhuYW1lLCAtMSwgb3B0cywgZmFsc2UpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZXRhY2hEZXNjcmlwdG9yIHBhc3NlcyB0aGUgZGVzY3JpcHRvciB3aGVyZWFzIGRpc2NhcmREZXNjcmlwdG9yIGNsb3NlcyBpdCwgZWl0aGVyIHdheSwgd2Ugbm8gbG9uZ2VyIGNhcmVcbiAgICAgICAgLy8gYWJvdXQgdGhlIGRlc2NyaXB0b3JcbiAgICAgICAgY29uc3QgZGlzY2FyZE9yRGV0YWNoRGVzY3JpcHRvciA9IG9wdHMuZGlzY2FyZERlc2NyaXB0b3IgfHwgb3B0cy5kZXRhY2hEZXNjcmlwdG9yO1xuICAgICAgICBjYihudWxsLCBuYW1lLCBmZCwgX3ByZXBhcmVUbXBGaWxlUmVtb3ZlQ2FsbGJhY2sobmFtZSwgZGlzY2FyZE9yRGV0YWNoRGVzY3JpcHRvciA/IC0xIDogZmQsIG9wdHMsIGZhbHNlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzIHZlcnNpb24gb2YgZmlsZS5cbiAqXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtGaWxlU3luY09iamVjdH0gb2JqZWN0IGNvbnNpc3RzIG9mIG5hbWUsIGZkIGFuZCByZW1vdmVDYWxsYmFja1xuICogQHRocm93cyB7RXJyb3J9IGlmIGNhbm5vdCBjcmVhdGUgYSBmaWxlXG4gKi9cbmZ1bmN0aW9uIGZpbGVTeW5jKG9wdGlvbnMpIHtcbiAgY29uc3RcbiAgICBhcmdzID0gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMpLFxuICAgIG9wdHMgPSBhcmdzWzBdO1xuXG4gIGNvbnN0IGRpc2NhcmRPckRldGFjaERlc2NyaXB0b3IgPSBvcHRzLmRpc2NhcmREZXNjcmlwdG9yIHx8IG9wdHMuZGV0YWNoRGVzY3JpcHRvcjtcbiAgY29uc3QgbmFtZSA9IHRtcE5hbWVTeW5jKG9wdHMpO1xuICB2YXIgZmQgPSBmcy5vcGVuU3luYyhuYW1lLCBDUkVBVEVfRkxBR1MsIG9wdHMubW9kZSB8fCBGSUxFX01PREUpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAob3B0cy5kaXNjYXJkRGVzY3JpcHRvcikge1xuICAgIGZzLmNsb3NlU3luYyhmZCk7XG4gICAgZmQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgZmQ6IGZkLFxuICAgIHJlbW92ZUNhbGxiYWNrOiBfcHJlcGFyZVRtcEZpbGVSZW1vdmVDYWxsYmFjayhuYW1lLCBkaXNjYXJkT3JEZXRhY2hEZXNjcmlwdG9yID8gLTEgOiBmZCwgb3B0cywgdHJ1ZSlcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdGVtcG9yYXJ5IGRpcmVjdG9yeS5cbiAqXG4gKiBAcGFyYW0geyhPcHRpb25zfGRpckNhbGxiYWNrKX0gb3B0aW9ucyB0aGUgb3B0aW9ucyBvciB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEBwYXJhbSB7P2RpckNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBkaXIob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY29uc3RcbiAgICBhcmdzID0gX3BhcnNlQXJndW1lbnRzKG9wdGlvbnMsIGNhbGxiYWNrKSxcbiAgICBvcHRzID0gYXJnc1swXSxcbiAgICBjYiA9IGFyZ3NbMV07XG5cbiAgLy8gZ2V0cyBhIHRlbXBvcmFyeSBmaWxlbmFtZVxuICB0bXBOYW1lKG9wdHMsIGZ1bmN0aW9uIF90bXBOYW1lQ3JlYXRlZChlcnIsIG5hbWUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBkaXJlY3RvcnlcbiAgICBmcy5ta2RpcihuYW1lLCBvcHRzLm1vZGUgfHwgRElSX01PREUsIGZ1bmN0aW9uIF9kaXJDcmVhdGVkKGVycikge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgICBjYihudWxsLCBuYW1lLCBfcHJlcGFyZVRtcERpclJlbW92ZUNhbGxiYWNrKG5hbWUsIG9wdHMsIGZhbHNlKSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzIHZlcnNpb24gb2YgZGlyLlxuICpcbiAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0RpclN5bmNPYmplY3R9IG9iamVjdCBjb25zaXN0cyBvZiBuYW1lIGFuZCByZW1vdmVDYWxsYmFja1xuICogQHRocm93cyB7RXJyb3J9IGlmIGl0IGNhbm5vdCBjcmVhdGUgYSBkaXJlY3RvcnlcbiAqL1xuZnVuY3Rpb24gZGlyU3luYyhvcHRpb25zKSB7XG4gIGNvbnN0XG4gICAgYXJncyA9IF9wYXJzZUFyZ3VtZW50cyhvcHRpb25zKSxcbiAgICBvcHRzID0gYXJnc1swXTtcblxuICBjb25zdCBuYW1lID0gdG1wTmFtZVN5bmMob3B0cyk7XG4gIGZzLm1rZGlyU3luYyhuYW1lLCBvcHRzLm1vZGUgfHwgRElSX01PREUpO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICByZW1vdmVDYWxsYmFjazogX3ByZXBhcmVUbXBEaXJSZW1vdmVDYWxsYmFjayhuYW1lLCBvcHRzLCB0cnVlKVxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgZmlsZXMgYXN5bmNocm9ub3VzbHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZkUGF0aFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3JlbW92ZUZpbGVBc3luYyhmZFBhdGgsIG5leHQpIHtcbiAgY29uc3QgX2hhbmRsZXIgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVyciAmJiAhX2lzRU5PRU5UKGVycikpIHtcbiAgICAgIC8vIHJlcmFpc2UgYW55IHVuYW50aWNpcGF0ZWQgZXJyb3JcbiAgICAgIHJldHVybiBuZXh0KGVycik7XG4gICAgfVxuICAgIG5leHQoKTtcbiAgfTtcblxuICBpZiAoMCA8PSBmZFBhdGhbMF0pXG4gICAgZnMuY2xvc2UoZmRQYXRoWzBdLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmcy51bmxpbmsoZmRQYXRoWzFdLCBfaGFuZGxlcik7XG4gICAgfSk7XG4gIGVsc2UgZnMudW5saW5rKGZkUGF0aFsxXSwgX2hhbmRsZXIpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgZmlsZXMgc3luY2hyb25vdXNseS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmRQYXRoXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcmVtb3ZlRmlsZVN5bmMoZmRQYXRoKSB7XG4gIGxldCByZXRocm93bkV4Y2VwdGlvbiA9IG51bGw7XG4gIHRyeSB7XG4gICAgaWYgKDAgPD0gZmRQYXRoWzBdKSBmcy5jbG9zZVN5bmMoZmRQYXRoWzBdKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHJlcmFpc2UgYW55IHVuYW50aWNpcGF0ZWQgZXJyb3JcbiAgICBpZiAoIV9pc0VCQURGKGUpICYmICFfaXNFTk9FTlQoZSkpIHRocm93IGU7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGZzLnVubGlua1N5bmMoZmRQYXRoWzFdKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHJlcmFpc2UgYW55IHVuYW50aWNpcGF0ZWQgZXJyb3JcbiAgICAgIGlmICghX2lzRU5PRU5UKGUpKSByZXRocm93bkV4Y2VwdGlvbiA9IGU7XG4gICAgfVxuICB9XG4gIGlmIChyZXRocm93bkV4Y2VwdGlvbiAhPT0gbnVsbCkge1xuICAgIHRocm93IHJldGhyb3duRXhjZXB0aW9uO1xuICB9XG59XG5cbi8qKlxuICogUHJlcGFyZXMgdGhlIGNhbGxiYWNrIGZvciByZW1vdmFsIG9mIHRoZSB0ZW1wb3JhcnkgZmlsZS5cbiAqXG4gKiBSZXR1cm5zIGVpdGhlciBhIHN5bmMgY2FsbGJhY2sgb3IgYSBhc3luYyBjYWxsYmFjayBkZXBlbmRpbmcgb24gd2hldGhlclxuICogZmlsZVN5bmMgb3IgZmlsZSB3YXMgY2FsbGVkLCB3aGljaCBpcyBleHByZXNzZWQgYnkgdGhlIHN5bmMgcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBwYXRoIG9mIHRoZSBmaWxlXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtib29sZWFufSBzeW5jXG4gKiBAcmV0dXJucyB7ZmlsZUNhbGxiYWNrIHwgZmlsZUNhbGxiYWNrU3luY31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9wcmVwYXJlVG1wRmlsZVJlbW92ZUNhbGxiYWNrKG5hbWUsIGZkLCBvcHRzLCBzeW5jKSB7XG4gIGNvbnN0IHJlbW92ZUNhbGxiYWNrU3luYyA9IF9wcmVwYXJlUmVtb3ZlQ2FsbGJhY2soX3JlbW92ZUZpbGVTeW5jLCBbZmQsIG5hbWVdLCBzeW5jKTtcbiAgY29uc3QgcmVtb3ZlQ2FsbGJhY2sgPSBfcHJlcGFyZVJlbW92ZUNhbGxiYWNrKF9yZW1vdmVGaWxlQXN5bmMsIFtmZCwgbmFtZV0sIHN5bmMsIHJlbW92ZUNhbGxiYWNrU3luYyk7XG5cbiAgaWYgKCFvcHRzLmtlZXApIF9yZW1vdmVPYmplY3RzLnVuc2hpZnQocmVtb3ZlQ2FsbGJhY2tTeW5jKTtcblxuICByZXR1cm4gc3luYyA/IHJlbW92ZUNhbGxiYWNrU3luYyA6IHJlbW92ZUNhbGxiYWNrO1xufVxuXG4vKipcbiAqIFByZXBhcmVzIHRoZSBjYWxsYmFjayBmb3IgcmVtb3ZhbCBvZiB0aGUgdGVtcG9yYXJ5IGRpcmVjdG9yeS5cbiAqXG4gKiBSZXR1cm5zIGVpdGhlciBhIHN5bmMgY2FsbGJhY2sgb3IgYSBhc3luYyBjYWxsYmFjayBkZXBlbmRpbmcgb24gd2hldGhlclxuICogdG1wRmlsZVN5bmMgb3IgdG1wRmlsZSB3YXMgY2FsbGVkLCB3aGljaCBpcyBleHByZXNzZWQgYnkgdGhlIHN5bmMgcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtib29sZWFufSBzeW5jXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHRoZSBjYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3ByZXBhcmVUbXBEaXJSZW1vdmVDYWxsYmFjayhuYW1lLCBvcHRzLCBzeW5jKSB7XG4gIGNvbnN0IHJlbW92ZUZ1bmN0aW9uID0gb3B0cy51bnNhZmVDbGVhbnVwID8gcmltcmFmIDogZnMucm1kaXIuYmluZChmcyk7XG4gIGNvbnN0IHJlbW92ZUZ1bmN0aW9uU3luYyA9IG9wdHMudW5zYWZlQ2xlYW51cCA/IEZOX1JJTVJBRl9TWU5DIDogRk5fUk1ESVJfU1lOQztcbiAgY29uc3QgcmVtb3ZlQ2FsbGJhY2tTeW5jID0gX3ByZXBhcmVSZW1vdmVDYWxsYmFjayhyZW1vdmVGdW5jdGlvblN5bmMsIG5hbWUsIHN5bmMpO1xuICBjb25zdCByZW1vdmVDYWxsYmFjayA9IF9wcmVwYXJlUmVtb3ZlQ2FsbGJhY2socmVtb3ZlRnVuY3Rpb24sIG5hbWUsIHN5bmMsIHJlbW92ZUNhbGxiYWNrU3luYyk7XG4gIGlmICghb3B0cy5rZWVwKSBfcmVtb3ZlT2JqZWN0cy51bnNoaWZ0KHJlbW92ZUNhbGxiYWNrU3luYyk7XG5cbiAgcmV0dXJuIHN5bmMgPyByZW1vdmVDYWxsYmFja1N5bmMgOiByZW1vdmVDYWxsYmFjaztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZ3VhcmRlZCBmdW5jdGlvbiB3cmFwcGluZyB0aGUgcmVtb3ZlRnVuY3Rpb24gY2FsbC5cbiAqXG4gKiBUaGUgY2xlYW51cCBjYWxsYmFjayBpcyBzYXZlIHRvIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAqIFN1YnNlcXVlbnQgaW52b2NhdGlvbnMgd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlbW92ZUZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZU9yRGlyTmFtZVxuICogQHBhcmFtIHtib29sZWFufSBzeW5jXG4gKiBAcGFyYW0ge2NsZWFudXBDYWxsYmFja1N5bmM/fSBjbGVhbnVwQ2FsbGJhY2tTeW5jXG4gKiBAcmV0dXJucyB7Y2xlYW51cENhbGxiYWNrIHwgY2xlYW51cENhbGxiYWNrU3luY31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9wcmVwYXJlUmVtb3ZlQ2FsbGJhY2socmVtb3ZlRnVuY3Rpb24sIGZpbGVPckRpck5hbWUsIHN5bmMsIGNsZWFudXBDYWxsYmFja1N5bmMpIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGlmIHN5bmMgaXMgdHJ1ZSwgdGhlIG5leHQgcGFyYW1ldGVyIHdpbGwgYmUgaWdub3JlZFxuICByZXR1cm4gZnVuY3Rpb24gX2NsZWFudXBDYWxsYmFjayhuZXh0KSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAvLyByZW1vdmUgY2xlYW51cENhbGxiYWNrIGZyb20gY2FjaGVcbiAgICAgIGNvbnN0IHRvUmVtb3ZlID0gY2xlYW51cENhbGxiYWNrU3luYyB8fCBfY2xlYW51cENhbGxiYWNrO1xuICAgICAgY29uc3QgaW5kZXggPSBfcmVtb3ZlT2JqZWN0cy5pbmRleE9mKHRvUmVtb3ZlKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAoaW5kZXggPj0gMCkgX3JlbW92ZU9iamVjdHMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGlmIChzeW5jIHx8IHJlbW92ZUZ1bmN0aW9uID09PSBGTl9STURJUl9TWU5DIHx8IHJlbW92ZUZ1bmN0aW9uID09PSBGTl9SSU1SQUZfU1lOQykge1xuICAgICAgICByZXR1cm4gcmVtb3ZlRnVuY3Rpb24oZmlsZU9yRGlyTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVtb3ZlRnVuY3Rpb24oZmlsZU9yRGlyTmFtZSwgbmV4dCB8fCBmdW5jdGlvbigpIHt9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGdhcmJhZ2UgY29sbGVjdG9yLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nYXJiYWdlQ29sbGVjdG9yKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9ncmFjZWZ1bENsZWFudXApIHJldHVybjtcblxuICAvLyB0aGUgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIHJlbW92ZXMgaXRzZWxmIGZyb20gX3JlbW92ZU9iamVjdHMsXG4gIC8vIGxvb3AgdW50aWwgX3JlbW92ZU9iamVjdHMgaXMgZW1wdHlcbiAgd2hpbGUgKF9yZW1vdmVPYmplY3RzLmxlbmd0aCkge1xuICAgIHRyeSB7XG4gICAgICBfcmVtb3ZlT2JqZWN0c1swXSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGFscmVhZHkgcmVtb3ZlZD9cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSYW5kb20gbmFtZSBnZW5lcmF0b3IgYmFzZWQgb24gY3J5cHRvLlxuICogQWRhcHRlZCBmcm9tIGh0dHA6Ly9ibG9nLnRvbXBhd2xhay5vcmcvaG93LXRvLWdlbmVyYXRlLXJhbmRvbS12YWx1ZXMtbm9kZWpzLWphdmFzY3JpcHRcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaG93TWFueVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGdlbmVyYXRlZCByYW5kb20gbmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3JhbmRvbUNoYXJzKGhvd01hbnkpIHtcbiAgbGV0XG4gICAgdmFsdWUgPSBbXSxcbiAgICBybmQgPSBudWxsO1xuXG4gIC8vIG1ha2Ugc3VyZSB0aGF0IHdlIGRvIG5vdCBmYWlsIGJlY2F1c2Ugd2UgcmFuIG91dCBvZiBlbnRyb3B5XG4gIHRyeSB7XG4gICAgcm5kID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGhvd01hbnkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcm5kID0gY3J5cHRvLnBzZXVkb1JhbmRvbUJ5dGVzKGhvd01hbnkpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3dNYW55OyBpKyspIHtcbiAgICB2YWx1ZS5wdXNoKFJBTkRPTV9DSEFSU1tybmRbaV0gJSBSQU5ET01fQ0hBUlMubGVuZ3RoXSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWUuam9pbignJyk7XG59XG5cbi8qKlxuICogSGVscGVyIHdoaWNoIGRldGVybWluZXMgd2hldGhlciBhIHN0cmluZyBzIGlzIGJsYW5rLCB0aGF0IGlzIHVuZGVmaW5lZCwgb3IgZW1wdHkgb3IgbnVsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIHdoZXRoZXIgdGhlIHN0cmluZyBzIGlzIGJsYW5rLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gX2lzQmxhbmsocykge1xuICByZXR1cm4gcyA9PT0gbnVsbCB8fCBfaXNVbmRlZmluZWQocykgfHwgIXMudHJpbSgpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBgb2JqYCBwYXJhbWV0ZXIgaXMgZGVmaW5lZCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG9iamVjdCBpcyB1bmRlZmluZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9pc1VuZGVmaW5lZChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgZnVuY3Rpb24gYXJndW1lbnRzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaGVscHMgdG8gaGF2ZSBvcHRpb25hbCBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIHsoT3B0aW9uc3xudWxsfHVuZGVmaW5lZHxGdW5jdGlvbil9IG9wdGlvbnNcbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0FycmF5fSBwYXJzZWQgYXJndW1lbnRzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfcGFyc2VBcmd1bWVudHMob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIFt7fSwgb3B0aW9uc107XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoX2lzVW5kZWZpbmVkKG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIFt7fSwgY2FsbGJhY2tdO1xuICB9XG5cbiAgLy8gY29weSBvcHRpb25zIHNvIHdlIGRvIG5vdCBsZWFrIHRoZSBjaGFuZ2VzIHdlIG1ha2UgaW50ZXJuYWxseVxuICBjb25zdCBhY3R1YWxPcHRpb25zID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9wdGlvbnMpKSB7XG4gICAgYWN0dWFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICB9XG5cbiAgcmV0dXJuIFthY3R1YWxPcHRpb25zLCBjYWxsYmFja107XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbmV3IHRlbXBvcmFyeSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgbmV3IHJhbmRvbSBuYW1lIGFjY29yZGluZyB0byBvcHRzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2VuZXJhdGVUbXBOYW1lKG9wdHMpIHtcblxuICBjb25zdCB0bXBEaXIgPSBvcHRzLnRtcGRpcjtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRzLm5hbWUpKVxuICAgIHJldHVybiBwYXRoLmpvaW4odG1wRGlyLCBvcHRzLmRpciwgb3B0cy5uYW1lKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRzLnRlbXBsYXRlKSlcbiAgICByZXR1cm4gcGF0aC5qb2luKHRtcERpciwgb3B0cy5kaXIsIG9wdHMudGVtcGxhdGUpLnJlcGxhY2UoVEVNUExBVEVfUEFUVEVSTiwgX3JhbmRvbUNoYXJzKDYpKTtcblxuICAvLyBwcmVmaXggYW5kIHBvc3RmaXhcbiAgY29uc3QgbmFtZSA9IFtcbiAgICBvcHRzLnByZWZpeCA/IG9wdHMucHJlZml4IDogJ3RtcCcsXG4gICAgJy0nLFxuICAgIHByb2Nlc3MucGlkLFxuICAgICctJyxcbiAgICBfcmFuZG9tQ2hhcnMoMTIpLFxuICAgIG9wdHMucG9zdGZpeCA/ICctJyArIG9wdHMucG9zdGZpeCA6ICcnXG4gIF0uam9pbignJyk7XG5cbiAgcmV0dXJuIHBhdGguam9pbih0bXBEaXIsIG9wdHMuZGlyLCBuYW1lKTtcbn1cblxuLyoqXG4gKiBBc3NlcnRzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBvcHRpb25zIGFyZSB2YWxpZCwgYWxzbyBzYW5pdGl6ZXMgb3B0aW9ucyBhbmQgcHJvdmlkZXMgc2FuZSBkZWZhdWx0cyBmb3IgbWlzc2luZ1xuICogb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9hc3NlcnRBbmRTYW5pdGl6ZU9wdGlvbnMob3B0aW9ucykge1xuXG4gIG9wdGlvbnMudG1wZGlyID0gX2dldFRtcERpcihvcHRpb25zKTtcblxuICBjb25zdCB0bXBEaXIgPSBvcHRpb25zLnRtcGRpcjtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRpb25zLm5hbWUpKVxuICAgIF9hc3NlcnRJc1JlbGF0aXZlKG9wdGlvbnMubmFtZSwgJ25hbWUnLCB0bXBEaXIpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRpb25zLmRpcikpXG4gICAgX2Fzc2VydElzUmVsYXRpdmUob3B0aW9ucy5kaXIsICdkaXInLCB0bXBEaXIpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRpb25zLnRlbXBsYXRlKSkge1xuICAgIF9hc3NlcnRJc1JlbGF0aXZlKG9wdGlvbnMudGVtcGxhdGUsICd0ZW1wbGF0ZScsIHRtcERpcik7XG4gICAgaWYgKCFvcHRpb25zLnRlbXBsYXRlLm1hdGNoKFRFTVBMQVRFX1BBVFRFUk4pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRlbXBsYXRlLCBmb3VuZCBcIiR7b3B0aW9ucy50ZW1wbGF0ZX1cIi5gKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoIV9pc1VuZGVmaW5lZChvcHRpb25zLnRyaWVzKSAmJiBpc05hTihvcHRpb25zLnRyaWVzKSB8fCBvcHRpb25zLnRyaWVzIDwgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdHJpZXMsIGZvdW5kIFwiJHtvcHRpb25zLnRyaWVzfVwiLmApO1xuXG4gIC8vIGlmIGEgbmFtZSB3YXMgc3BlY2lmaWVkIHdlIHdpbGwgdHJ5IG9uY2VcbiAgb3B0aW9ucy50cmllcyA9IF9pc1VuZGVmaW5lZChvcHRpb25zLm5hbWUpID8gb3B0aW9ucy50cmllcyB8fCBERUZBVUxUX1RSSUVTIDogMTtcbiAgb3B0aW9ucy5rZWVwID0gISFvcHRpb25zLmtlZXA7XG4gIG9wdGlvbnMuZGV0YWNoRGVzY3JpcHRvciA9ICEhb3B0aW9ucy5kZXRhY2hEZXNjcmlwdG9yO1xuICBvcHRpb25zLmRpc2NhcmREZXNjcmlwdG9yID0gISFvcHRpb25zLmRpc2NhcmREZXNjcmlwdG9yO1xuICBvcHRpb25zLnVuc2FmZUNsZWFudXAgPSAhIW9wdGlvbnMudW5zYWZlQ2xlYW51cDtcblxuICAvLyBzYW5pdGl6ZSBkaXIsIGFsc28ga2VlcCAobXVsdGlwbGUpIGJsYW5rcyBpZiB0aGUgdXNlciwgcHVycG9ydGVkbHkgc2FuZSwgcmVxdWVzdHMgdXMgdG9cbiAgb3B0aW9ucy5kaXIgPSBfaXNVbmRlZmluZWQob3B0aW9ucy5kaXIpID8gJycgOiBwYXRoLnJlbGF0aXZlKHRtcERpciwgX3Jlc29sdmVQYXRoKG9wdGlvbnMuZGlyLCB0bXBEaXIpKTtcbiAgb3B0aW9ucy50ZW1wbGF0ZSA9IF9pc1VuZGVmaW5lZChvcHRpb25zLnRlbXBsYXRlKSA/IHVuZGVmaW5lZCA6IHBhdGgucmVsYXRpdmUodG1wRGlyLCBfcmVzb2x2ZVBhdGgob3B0aW9ucy50ZW1wbGF0ZSwgdG1wRGlyKSk7XG4gIC8vIHNhbml0aXplIGZ1cnRoZXIgaWYgdGVtcGxhdGUgaXMgcmVsYXRpdmUgdG8gb3B0aW9ucy5kaXJcbiAgb3B0aW9ucy50ZW1wbGF0ZSA9IF9pc0JsYW5rKG9wdGlvbnMudGVtcGxhdGUpID8gdW5kZWZpbmVkIDogcGF0aC5yZWxhdGl2ZShvcHRpb25zLmRpciwgb3B0aW9ucy50ZW1wbGF0ZSk7XG5cbiAgLy8gZm9yIGNvbXBsZXRlbmVzcycgc2FrZSBvbmx5LCBhbHNvIGtlZXAgKG11bHRpcGxlKSBibGFua3MgaWYgdGhlIHVzZXIsIHB1cnBvcnRlZGx5IHNhbmUsIHJlcXVlc3RzIHVzIHRvXG4gIG9wdGlvbnMubmFtZSA9IF9pc1VuZGVmaW5lZChvcHRpb25zLm5hbWUpID8gdW5kZWZpbmVkIDogb3B0aW9ucy5uYW1lO1xuICBvcHRpb25zLnByZWZpeCA9IF9pc1VuZGVmaW5lZChvcHRpb25zLnByZWZpeCkgPyAnJyA6IG9wdGlvbnMucHJlZml4O1xuICBvcHRpb25zLnBvc3RmaXggPSBfaXNVbmRlZmluZWQob3B0aW9ucy5wb3N0Zml4KSA/ICcnIDogb3B0aW9ucy5wb3N0Zml4O1xufVxuXG4vKipcbiAqIFJlc29sdmUgdGhlIHNwZWNpZmllZCBwYXRoIG5hbWUgaW4gcmVzcGVjdCB0byB0bXBEaXIuXG4gKlxuICogVGhlIHNwZWNpZmllZCBuYW1lIG1pZ2h0IGluY2x1ZGUgcmVsYXRpdmUgcGF0aCBjb21wb25lbnRzLCBlLmcuIC4uL1xuICogc28gd2UgbmVlZCB0byByZXNvbHZlIGluIG9yZGVyIHRvIGJlIHN1cmUgdGhhdCBpcyBpcyBsb2NhdGVkIGluc2lkZSB0bXBEaXJcbiAqXG4gKiBAcGFyYW0gbmFtZVxuICogQHBhcmFtIHRtcERpclxuICogQHJldHVybnMge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9yZXNvbHZlUGF0aChuYW1lLCB0bXBEaXIpIHtcbiAgaWYgKG5hbWUuc3RhcnRzV2l0aCh0bXBEaXIpKSB7XG4gICAgcmV0dXJuIHBhdGgucmVzb2x2ZShuYW1lKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGF0aC5yZXNvbHZlKHBhdGguam9pbih0bXBEaXIsIG5hbWUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEFzc2VydHMgd2hldGhlciBzcGVjaWZpZWQgbmFtZSBpcyByZWxhdGl2ZSB0byB0aGUgc3BlY2lmaWVkIHRtcERpci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHRtcERpclxuICogQHRocm93cyB7RXJyb3J9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfYXNzZXJ0SXNSZWxhdGl2ZShuYW1lLCBvcHRpb24sIHRtcERpcikge1xuICBpZiAob3B0aW9uID09PSAnbmFtZScpIHtcbiAgICAvLyBhc3NlcnQgdGhhdCBuYW1lIGlzIG5vdCBhYnNvbHV0ZSBhbmQgZG9lcyBub3QgY29udGFpbiBhIHBhdGhcbiAgICBpZiAocGF0aC5pc0Fic29sdXRlKG5hbWUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke29wdGlvbn0gb3B0aW9uIG11c3Qgbm90IGNvbnRhaW4gYW4gYWJzb2x1dGUgcGF0aCwgZm91bmQgXCIke25hbWV9XCIuYCk7XG4gICAgLy8gbXVzdCBub3QgZmFpbCBvbiB2YWxpZCAuPG5hbWU+IG9yIC4uPG5hbWU+IG9yIHNpbWlsYXIgc3VjaCBjb25zdHJ1Y3RzXG4gICAgbGV0IGJhc2VuYW1lID0gcGF0aC5iYXNlbmFtZShuYW1lKTtcbiAgICBpZiAoYmFzZW5hbWUgPT09ICcuLicgfHwgYmFzZW5hbWUgPT09ICcuJyB8fCBiYXNlbmFtZSAhPT0gbmFtZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvcHRpb259IG9wdGlvbiBtdXN0IG5vdCBjb250YWluIGEgcGF0aCwgZm91bmQgXCIke25hbWV9XCIuYCk7XG4gIH1cbiAgZWxzZSB7IC8vIGlmIChvcHRpb24gPT09ICdkaXInIHx8IG9wdGlvbiA9PT0gJ3RlbXBsYXRlJykge1xuICAgIC8vIGFzc2VydCB0aGF0IGRpciBvciB0ZW1wbGF0ZSBhcmUgcmVsYXRpdmUgdG8gdG1wRGlyXG4gICAgaWYgKHBhdGguaXNBYnNvbHV0ZShuYW1lKSAmJiAhbmFtZS5zdGFydHNXaXRoKHRtcERpcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvcHRpb259IG9wdGlvbiBtdXN0IGJlIHJlbGF0aXZlIHRvIFwiJHt0bXBEaXJ9XCIsIGZvdW5kIFwiJHtuYW1lfVwiLmApO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZWRQYXRoID0gX3Jlc29sdmVQYXRoKG5hbWUsIHRtcERpcik7XG4gICAgaWYgKCFyZXNvbHZlZFBhdGguc3RhcnRzV2l0aCh0bXBEaXIpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke29wdGlvbn0gb3B0aW9uIG11c3QgYmUgcmVsYXRpdmUgdG8gXCIke3RtcERpcn1cIiwgZm91bmQgXCIke3Jlc29sdmVkUGF0aH1cIi5gKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgdGVzdGluZyBhZ2FpbnN0IEVCQURGIHRvIGNvbXBlbnNhdGUgY2hhbmdlcyBtYWRlIHRvIE5vZGUgNy54IHVuZGVyIFdpbmRvd3MuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2lzRUJBREYoZXJyb3IpIHtcbiAgcmV0dXJuIF9pc0V4cGVjdGVkRXJyb3IoZXJyb3IsIC1FQkFERiwgJ0VCQURGJyk7XG59XG5cbi8qKlxuICogSGVscGVyIGZvciB0ZXN0aW5nIGFnYWluc3QgRU5PRU5UIHRvIGNvbXBlbnNhdGUgY2hhbmdlcyBtYWRlIHRvIE5vZGUgNy54IHVuZGVyIFdpbmRvd3MuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2lzRU5PRU5UKGVycm9yKSB7XG4gIHJldHVybiBfaXNFeHBlY3RlZEVycm9yKGVycm9yLCAtRU5PRU5ULCAnRU5PRU5UJyk7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBleHBlY3RlZCBlcnJvciBjb2RlIG1hdGNoZXMgdGhlIGFjdHVhbCBjb2RlIGFuZCBlcnJubyxcbiAqIHdoaWNoIHdpbGwgZGlmZmVyIGJldHdlZW4gdGhlIHN1cHBvcnRlZCBub2RlIHZlcnNpb25zLlxuICpcbiAqIC0gTm9kZSA+PSA3LjA6XG4gKiAgIGVycm9yLmNvZGUge3N0cmluZ31cbiAqICAgZXJyb3IuZXJybm8ge251bWJlcn0gYW55IG51bWVyaWNhbCB2YWx1ZSB3aWxsIGJlIG5lZ2F0ZWRcbiAqXG4gKiBDQVZFQVRcbiAqXG4gKiBPbiB3aW5kb3dzLCB0aGUgZXJybm8gZm9yIEVCQURGIGlzIC00MDgzIGJ1dCBvcy5jb25zdGFudHMuZXJybm8uRUJBREYgaXMgZGlmZmVyZW50IGFuZCB3ZSBtdXN0IGFzc3VtZSB0aGF0IEVOT0VOVFxuICogaXMgbm8gZGlmZmVyZW50IGhlcmUuXG4gKlxuICogQHBhcmFtIHtTeXN0ZW1FcnJvcn0gZXJyb3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBlcnJub1xuICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9pc0V4cGVjdGVkRXJyb3IoZXJyb3IsIGVycm5vLCBjb2RlKSB7XG4gIHJldHVybiBJU19XSU4zMiA/IGVycm9yLmNvZGUgPT09IGNvZGUgOiBlcnJvci5jb2RlID09PSBjb2RlICYmIGVycm9yLmVycm5vID09PSBlcnJubztcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBncmFjZWZ1bCBjbGVhbnVwLlxuICpcbiAqIElmIGdyYWNlZnVsIGNsZWFudXAgaXMgc2V0LCB0bXAgd2lsbCByZW1vdmUgYWxsIGNvbnRyb2xsZWQgdGVtcG9yYXJ5IG9iamVjdHMgb24gcHJvY2VzcyBleGl0LCBvdGhlcndpc2UgdGhlXG4gKiB0ZW1wb3Jhcnkgb2JqZWN0cyB3aWxsIHJlbWFpbiBpbiBwbGFjZSwgd2FpdGluZyB0byBiZSBjbGVhbmVkIHVwIG9uIHN5c3RlbSByZXN0YXJ0IG9yIG90aGVyd2lzZSBzY2hlZHVsZWQgdGVtcG9yYXJ5XG4gKiBvYmplY3QgcmVtb3ZhbHMuXG4gKi9cbmZ1bmN0aW9uIHNldEdyYWNlZnVsQ2xlYW51cCgpIHtcbiAgX2dyYWNlZnVsQ2xlYW51cCA9IHRydWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudGx5IGNvbmZpZ3VyZWQgdG1wIGRpciBmcm9tIG9zLnRtcGRpcigpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gez9PcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgY3VycmVudGx5IGNvbmZpZ3VyZWQgdG1wIGRpclxuICovXG5mdW5jdGlvbiBfZ2V0VG1wRGlyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHBhdGgucmVzb2x2ZShvcHRpb25zICYmIG9wdGlvbnMudG1wZGlyIHx8IG9zLnRtcGRpcigpKTtcbn1cblxuLy8gSW5zdGFsbCBwcm9jZXNzIGV4aXQgbGlzdGVuZXJcbnByb2Nlc3MuYWRkTGlzdGVuZXIoRVhJVCwgX2dhcmJhZ2VDb2xsZWN0b3IpO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSBrZWVwIHRoZSB0ZW1wb3Jhcnkgb2JqZWN0IChmaWxlIG9yIGRpcikgd2lsbCBub3QgYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAqIEBwcm9wZXJ0eSB7P251bWJlcn0gdHJpZXMgdGhlIG51bWJlciBvZiB0cmllcyBiZWZvcmUgZ2l2ZSB1cCB0aGUgbmFtZSBnZW5lcmF0aW9uXG4gKiBAcHJvcGVydHkgKD9pbnQpIG1vZGUgdGhlIGFjY2VzcyBtb2RlLCBkZWZhdWx0cyBhcmUgMG83MDAgZm9yIGRpcmVjdG9yaWVzIGFuZCAwbzYwMCBmb3IgZmlsZXNcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdGVtcGxhdGUgdGhlIFwibWtzdGVtcFwiIGxpa2UgZmlsZW5hbWUgdGVtcGxhdGVcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gbmFtZSBmaXhlZCBuYW1lIHJlbGF0aXZlIHRvIHRtcGRpciBvciB0aGUgc3BlY2lmaWVkIGRpciBvcHRpb25cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gZGlyIHRtcCBkaXJlY3RvcnkgcmVsYXRpdmUgdG8gdGhlIHJvb3QgdG1wIGRpcmVjdG9yeSBpbiB1c2VcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gcHJlZml4IHByZWZpeCBmb3IgdGhlIGdlbmVyYXRlZCBuYW1lXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHBvc3RmaXggcG9zdGZpeCBmb3IgdGhlIGdlbmVyYXRlZCBuYW1lXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHRtcGRpciB0aGUgcm9vdCB0bXAgZGlyZWN0b3J5IHdoaWNoIG92ZXJyaWRlcyB0aGUgb3MgdG1wZGlyXG4gKiBAcHJvcGVydHkgez9ib29sZWFufSB1bnNhZmVDbGVhbnVwIHJlY3Vyc2l2ZWx5IHJlbW92ZXMgdGhlIGNyZWF0ZWQgdGVtcG9yYXJ5IGRpcmVjdG9yeSwgZXZlbiB3aGVuIGl0J3Mgbm90IGVtcHR5XG4gKiBAcHJvcGVydHkgez9ib29sZWFufSBkZXRhY2hEZXNjcmlwdG9yIGRldGFjaGVzIHRoZSBmaWxlIGRlc2NyaXB0b3IsIGNhbGxlciBpcyByZXNwb25zaWJsZSBmb3IgY2xvc2luZyB0aGUgZmlsZSwgdG1wIHdpbGwgbm8gbG9uZ2VyIHRyeSBjbG9zaW5nIHRoZSBmaWxlIGR1cmluZyBnYXJiYWdlIGNvbGxlY3Rpb25cbiAqIEBwcm9wZXJ0eSB7P2Jvb2xlYW59IGRpc2NhcmREZXNjcmlwdG9yIGRpc2NhcmRzIHRoZSBmaWxlIGRlc2NyaXB0b3IgKGNsb3NlcyBmaWxlLCBmZCBpcyAtMSksIHRtcCB3aWxsIG5vIGxvbmdlciB0cnkgY2xvc2luZyB0aGUgZmlsZSBkdXJpbmcgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGaWxlU3luY09iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmZCB0aGUgZmlsZSBkZXNjcmlwdG9yIG9yIC0xIGlmIHRoZSBmZCBoYXMgYmVlbiBkaXNjYXJkZWRcbiAqIEBwcm9wZXJ0eSB7ZmlsZUNhbGxiYWNrfSByZW1vdmVDYWxsYmFjayB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoZSBmaWxlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEaXJTeW5jT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZGlyZWN0b3J5XG4gKiBAcHJvcGVydHkge2ZpbGVDYWxsYmFja30gcmVtb3ZlQ2FsbGJhY2sgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGUgZGlyZWN0b3J5XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgdG1wTmFtZUNhbGxiYWNrXG4gKiBAcGFyYW0gez9FcnJvcn0gZXJyIHRoZSBlcnJvciBvYmplY3QgaWYgYW55dGhpbmcgZ29lcyB3cm9uZ1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHRlbXBvcmFyeSBmaWxlIG5hbWVcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBmaWxlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgdGhlIGVycm9yIG9iamVjdCBpZiBhbnl0aGluZyBnb2VzIHdyb25nXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgdGVtcG9yYXJ5IGZpbGUgbmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IGZkIHRoZSBmaWxlIGRlc2NyaXB0b3Igb3IgLTEgaWYgdGhlIGZkIGhhZCBiZWVuIGRpc2NhcmRlZFxuICogQHBhcmFtIHtjbGVhbnVwQ2FsbGJhY2t9IGZuIHRoZSBjbGVhbnVwIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgZmlsZUNhbGxiYWNrU3luY1xuICogQHBhcmFtIHs/RXJyb3J9IGVyciB0aGUgZXJyb3Igb2JqZWN0IGlmIGFueXRoaW5nIGdvZXMgd3JvbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSB0ZW1wb3JhcnkgZmlsZSBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgdGhlIGZpbGUgZGVzY3JpcHRvciBvciAtMSBpZiB0aGUgZmQgaGFkIGJlZW4gZGlzY2FyZGVkXG4gKiBAcGFyYW0ge2NsZWFudXBDYWxsYmFja1N5bmN9IGZuIHRoZSBjbGVhbnVwIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgZGlyQ2FsbGJhY2tcbiAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgdGhlIGVycm9yIG9iamVjdCBpZiBhbnl0aGluZyBnb2VzIHdyb25nXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgdGVtcG9yYXJ5IGZpbGUgbmFtZVxuICogQHBhcmFtIHtjbGVhbnVwQ2FsbGJhY2t9IGZuIHRoZSBjbGVhbnVwIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgZGlyQ2FsbGJhY2tTeW5jXG4gKiBAcGFyYW0gez9FcnJvcn0gZXJyIHRoZSBlcnJvciBvYmplY3QgaWYgYW55dGhpbmcgZ29lcyB3cm9uZ1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHRlbXBvcmFyeSBmaWxlIG5hbWVcbiAqIEBwYXJhbSB7Y2xlYW51cENhbGxiYWNrU3luY30gZm4gdGhlIGNsZWFudXAgY2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIHRlbXBvcmFyeSBjcmVhdGVkIGZpbGUgb3IgZGlyZWN0b3J5LlxuICpcbiAqIEBjYWxsYmFjayBjbGVhbnVwQ2FsbGJhY2tcbiAqIEBwYXJhbSB7c2ltcGxlQ2FsbGJhY2t9IFtuZXh0XSBmdW5jdGlvbiB0byBjYWxsIHdoZW5ldmVyIHRoZSB0bXAgb2JqZWN0IG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAqL1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIHRlbXBvcmFyeSBjcmVhdGVkIGZpbGUgb3IgZGlyZWN0b3J5LlxuICpcbiAqIEBjYWxsYmFjayBjbGVhbnVwQ2FsbGJhY2tTeW5jXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgZnVuY3Rpb24gY29tcG9zaXRpb24uXG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcmFzemkvbm9kZS10bXAvaXNzdWVzLzU3fHJhc3ppL25vZGUtdG1wIzU3fVxuICpcbiAqIEBjYWxsYmFjayBzaW1wbGVDYWxsYmFja1xuICovXG5cbi8vIGV4cG9ydGluZyBhbGwgdGhlIG5lZWRlZCBtZXRob2RzXG5cbi8vIGV2YWx1YXRlIF9nZXRUbXBEaXIoKSBsYXppbHksIG1haW5seSBmb3Igc2ltcGxpZnlpbmcgdGVzdGluZyBidXQgaXQgYWxzbyB3aWxsXG4vLyBhbGxvdyB1c2VycyB0byByZWNvbmZpZ3VyZSB0aGUgdGVtcG9yYXJ5IGRpcmVjdG9yeVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAndG1wZGlyJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2dldFRtcERpcigpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMuZGlyID0gZGlyO1xubW9kdWxlLmV4cG9ydHMuZGlyU3luYyA9IGRpclN5bmM7XG5cbm1vZHVsZS5leHBvcnRzLmZpbGUgPSBmaWxlO1xubW9kdWxlLmV4cG9ydHMuZmlsZVN5bmMgPSBmaWxlU3luYztcblxubW9kdWxlLmV4cG9ydHMudG1wTmFtZSA9IHRtcE5hbWU7XG5tb2R1bGUuZXhwb3J0cy50bXBOYW1lU3luYyA9IHRtcE5hbWVTeW5jO1xuXG5tb2R1bGUuZXhwb3J0cy5zZXRHcmFjZWZ1bENsZWFudXAgPSBzZXRHcmFjZWZ1bENsZWFudXA7XG4iXSwibmFtZXMiOlsiZnMiLCJyZXF1aXJlIiwib3MiLCJwYXRoIiwiY3J5cHRvIiwiX2MiLCJjb25zdGFudHMiLCJSQU5ET01fQ0hBUlMiLCJURU1QTEFURV9QQVRURVJOIiwiREVGQVVMVF9UUklFUyIsIkNSRUFURV9GTEFHUyIsIk9fQ1JFQVQiLCJPX0VYQ0wiLCJPX1JEV1IiLCJJU19XSU4zMiIsInBsYXRmb3JtIiwiRUJBREYiLCJlcnJubyIsIkVOT0VOVCIsIkRJUl9NT0RFIiwiRklMRV9NT0RFIiwiRVhJVCIsIl9yZW1vdmVPYmplY3RzIiwiRk5fUk1ESVJfU1lOQyIsInJtZGlyU3luYyIsImJpbmQiLCJfZ3JhY2VmdWxDbGVhbnVwIiwicmltcmFmIiwiZGlyUGF0aCIsImNhbGxiYWNrIiwicm0iLCJyZWN1cnNpdmUiLCJGTl9SSU1SQUZfU1lOQyIsInJtU3luYyIsInRtcE5hbWUiLCJvcHRpb25zIiwiYXJncyIsIl9wYXJzZUFyZ3VtZW50cyIsIm9wdHMiLCJjYiIsIl9hc3NlcnRBbmRTYW5pdGl6ZU9wdGlvbnMiLCJlcnIiLCJ0cmllcyIsIl9nZXRVbmlxdWVOYW1lIiwibmFtZSIsIl9nZW5lcmF0ZVRtcE5hbWUiLCJzdGF0IiwiRXJyb3IiLCJ0bXBOYW1lU3luYyIsInN0YXRTeW5jIiwiZSIsImZpbGUiLCJfdG1wTmFtZUNyZWF0ZWQiLCJvcGVuIiwibW9kZSIsIl9maWxlQ3JlYXRlZCIsImZkIiwiZGlzY2FyZERlc2NyaXB0b3IiLCJjbG9zZSIsIl9kaXNjYXJkQ2FsbGJhY2siLCJwb3NzaWJsZUVyciIsInVuZGVmaW5lZCIsIl9wcmVwYXJlVG1wRmlsZVJlbW92ZUNhbGxiYWNrIiwiZGlzY2FyZE9yRGV0YWNoRGVzY3JpcHRvciIsImRldGFjaERlc2NyaXB0b3IiLCJmaWxlU3luYyIsIm9wZW5TeW5jIiwiY2xvc2VTeW5jIiwicmVtb3ZlQ2FsbGJhY2siLCJkaXIiLCJta2RpciIsIl9kaXJDcmVhdGVkIiwiX3ByZXBhcmVUbXBEaXJSZW1vdmVDYWxsYmFjayIsImRpclN5bmMiLCJta2RpclN5bmMiLCJfcmVtb3ZlRmlsZUFzeW5jIiwiZmRQYXRoIiwibmV4dCIsIl9oYW5kbGVyIiwiX2lzRU5PRU5UIiwidW5saW5rIiwiX3JlbW92ZUZpbGVTeW5jIiwicmV0aHJvd25FeGNlcHRpb24iLCJfaXNFQkFERiIsInVubGlua1N5bmMiLCJzeW5jIiwicmVtb3ZlQ2FsbGJhY2tTeW5jIiwiX3ByZXBhcmVSZW1vdmVDYWxsYmFjayIsImtlZXAiLCJ1bnNoaWZ0IiwicmVtb3ZlRnVuY3Rpb24iLCJ1bnNhZmVDbGVhbnVwIiwicm1kaXIiLCJyZW1vdmVGdW5jdGlvblN5bmMiLCJmaWxlT3JEaXJOYW1lIiwiY2xlYW51cENhbGxiYWNrU3luYyIsImNhbGxlZCIsIl9jbGVhbnVwQ2FsbGJhY2siLCJ0b1JlbW92ZSIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsIl9nYXJiYWdlQ29sbGVjdG9yIiwibGVuZ3RoIiwiX3JhbmRvbUNoYXJzIiwiaG93TWFueSIsInZhbHVlIiwicm5kIiwicmFuZG9tQnl0ZXMiLCJwc2V1ZG9SYW5kb21CeXRlcyIsImkiLCJwdXNoIiwiam9pbiIsIl9pc0JsYW5rIiwicyIsIl9pc1VuZGVmaW5lZCIsInRyaW0iLCJvYmoiLCJhY3R1YWxPcHRpb25zIiwia2V5IiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInRtcERpciIsInRtcGRpciIsInRlbXBsYXRlIiwicmVwbGFjZSIsInByZWZpeCIsInByb2Nlc3MiLCJwaWQiLCJwb3N0Zml4IiwiX2dldFRtcERpciIsIl9hc3NlcnRJc1JlbGF0aXZlIiwibWF0Y2giLCJpc05hTiIsInJlbGF0aXZlIiwiX3Jlc29sdmVQYXRoIiwic3RhcnRzV2l0aCIsInJlc29sdmUiLCJvcHRpb24iLCJpc0Fic29sdXRlIiwiYmFzZW5hbWUiLCJyZXNvbHZlZFBhdGgiLCJlcnJvciIsIl9pc0V4cGVjdGVkRXJyb3IiLCJjb2RlIiwic2V0R3JhY2VmdWxDbGVhbnVwIiwiYWRkTGlzdGVuZXIiLCJkZWZpbmVQcm9wZXJ0eSIsIm1vZHVsZSIsImV4cG9ydHMiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwiZ2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/tmp/lib/tmp.js\n");

/***/ })

};
;