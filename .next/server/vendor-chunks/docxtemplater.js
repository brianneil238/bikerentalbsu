"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/docxtemplater";
exports.ids = ["vendor-chunks/docxtemplater"];
exports.modules = {

/***/ "(rsc)/./node_modules/docxtemplater/js/collect-content-types.js":
/*!****************************************************************!*\
  !*** ./node_modules/docxtemplater/js/collect-content-types.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("\nvar ctXML = \"[Content_Types].xml\";\nfunction collectContentTypes(overrides, defaults, zip) {\n    var partNames = {};\n    for(var _i2 = 0; _i2 < overrides.length; _i2++){\n        var override = overrides[_i2];\n        var contentType = override.getAttribute(\"ContentType\");\n        var partName = override.getAttribute(\"PartName\").substr(1);\n        partNames[partName] = contentType;\n    }\n    var _loop = function _loop() {\n        var def = defaults[_i4];\n        var contentType = def.getAttribute(\"ContentType\");\n        var extension = def.getAttribute(\"Extension\");\n        zip.file(/./).map(function(_ref) {\n            var name = _ref.name;\n            if (name.slice(name.length - extension.length) === extension && !partNames[name] && name !== ctXML) {\n                partNames[name] = contentType;\n            }\n        });\n    };\n    for(var _i4 = 0; _i4 < defaults.length; _i4++){\n        _loop();\n    }\n    return partNames;\n}\nmodule.exports = collectContentTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9jb2xsZWN0LWNvbnRlbnQtdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxRQUFRO0FBQ1osU0FBU0Msb0JBQW9CQyxTQUFTLEVBQUVDLFFBQVEsRUFBRUMsR0FBRztJQUNuRCxJQUFJQyxZQUFZLENBQUM7SUFDakIsSUFBSyxJQUFJQyxNQUFNLEdBQUdBLE1BQU1KLFVBQVVLLE1BQU0sRUFBRUQsTUFBTztRQUMvQyxJQUFJRSxXQUFXTixTQUFTLENBQUNJLElBQUk7UUFDN0IsSUFBSUcsY0FBY0QsU0FBU0UsWUFBWSxDQUFDO1FBQ3hDLElBQUlDLFdBQVdILFNBQVNFLFlBQVksQ0FBQyxZQUFZRSxNQUFNLENBQUM7UUFDeERQLFNBQVMsQ0FBQ00sU0FBUyxHQUFHRjtJQUN4QjtJQUNBLElBQUlJLFFBQVEsU0FBU0E7UUFDbkIsSUFBSUMsTUFBTVgsUUFBUSxDQUFDWSxJQUFJO1FBQ3ZCLElBQUlOLGNBQWNLLElBQUlKLFlBQVksQ0FBQztRQUNuQyxJQUFJTSxZQUFZRixJQUFJSixZQUFZLENBQUM7UUFDakNOLElBQUlhLElBQUksQ0FBQyxLQUFLQyxHQUFHLENBQUMsU0FBVUMsSUFBSTtZQUM5QixJQUFJQyxPQUFPRCxLQUFLQyxJQUFJO1lBQ3BCLElBQUlBLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS2IsTUFBTSxHQUFHUyxVQUFVVCxNQUFNLE1BQU1TLGFBQWEsQ0FBQ1gsU0FBUyxDQUFDZSxLQUFLLElBQUlBLFNBQVNwQixPQUFPO2dCQUNsR0ssU0FBUyxDQUFDZSxLQUFLLEdBQUdYO1lBQ3BCO1FBQ0Y7SUFDRjtJQUNBLElBQUssSUFBSU0sTUFBTSxHQUFHQSxNQUFNWixTQUFTSSxNQUFNLEVBQUVRLE1BQU87UUFDOUNGO0lBQ0Y7SUFDQSxPQUFPUjtBQUNUO0FBQ0FpQixPQUFPQyxPQUFPLEdBQUd0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Jpa2UtcmVudGFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9jb2xsZWN0LWNvbnRlbnQtdHlwZXMuanM/NDhiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGN0WE1MID0gXCJbQ29udGVudF9UeXBlc10ueG1sXCI7XG5mdW5jdGlvbiBjb2xsZWN0Q29udGVudFR5cGVzKG92ZXJyaWRlcywgZGVmYXVsdHMsIHppcCkge1xuICB2YXIgcGFydE5hbWVzID0ge307XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG92ZXJyaWRlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIG92ZXJyaWRlID0gb3ZlcnJpZGVzW19pMl07XG4gICAgdmFyIGNvbnRlbnRUeXBlID0gb3ZlcnJpZGUuZ2V0QXR0cmlidXRlKFwiQ29udGVudFR5cGVcIik7XG4gICAgdmFyIHBhcnROYW1lID0gb3ZlcnJpZGUuZ2V0QXR0cmlidXRlKFwiUGFydE5hbWVcIikuc3Vic3RyKDEpO1xuICAgIHBhcnROYW1lc1twYXJ0TmFtZV0gPSBjb250ZW50VHlwZTtcbiAgfVxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICB2YXIgZGVmID0gZGVmYXVsdHNbX2k0XTtcbiAgICB2YXIgY29udGVudFR5cGUgPSBkZWYuZ2V0QXR0cmlidXRlKFwiQ29udGVudFR5cGVcIik7XG4gICAgdmFyIGV4dGVuc2lvbiA9IGRlZi5nZXRBdHRyaWJ1dGUoXCJFeHRlbnNpb25cIik7XG4gICAgemlwLmZpbGUoLy4vKS5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgICAgaWYgKG5hbWUuc2xpY2UobmFtZS5sZW5ndGggLSBleHRlbnNpb24ubGVuZ3RoKSA9PT0gZXh0ZW5zaW9uICYmICFwYXJ0TmFtZXNbbmFtZV0gJiYgbmFtZSAhPT0gY3RYTUwpIHtcbiAgICAgICAgcGFydE5hbWVzW25hbWVdID0gY29udGVudFR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGRlZmF1bHRzLmxlbmd0aDsgX2k0KyspIHtcbiAgICBfbG9vcCgpO1xuICB9XG4gIHJldHVybiBwYXJ0TmFtZXM7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvbGxlY3RDb250ZW50VHlwZXM7Il0sIm5hbWVzIjpbImN0WE1MIiwiY29sbGVjdENvbnRlbnRUeXBlcyIsIm92ZXJyaWRlcyIsImRlZmF1bHRzIiwiemlwIiwicGFydE5hbWVzIiwiX2kyIiwibGVuZ3RoIiwib3ZlcnJpZGUiLCJjb250ZW50VHlwZSIsImdldEF0dHJpYnV0ZSIsInBhcnROYW1lIiwic3Vic3RyIiwiX2xvb3AiLCJkZWYiLCJfaTQiLCJleHRlbnNpb24iLCJmaWxlIiwibWFwIiwiX3JlZiIsIm5hbWUiLCJzbGljZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/collect-content-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/content-types.js":
/*!********************************************************!*\
  !*** ./node_modules/docxtemplater/js/content-types.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\nvar coreContentType = \"application/vnd.openxmlformats-package.core-properties+xml\";\nvar appContentType = \"application/vnd.openxmlformats-officedocument.extended-properties+xml\";\nvar customContentType = \"application/vnd.openxmlformats-officedocument.custom-properties+xml\";\nvar settingsContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml\";\nvar diagramDataContentType = \"application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml\";\nvar diagramDrawingContentType = \"application/vnd.ms-office.drawingml.diagramDrawing+xml\";\nmodule.exports = {\n    settingsContentType: settingsContentType,\n    coreContentType: coreContentType,\n    appContentType: appContentType,\n    customContentType: customContentType,\n    diagramDataContentType: diagramDataContentType,\n    diagramDrawingContentType: diagramDrawingContentType\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9jb250ZW50LXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsa0JBQWtCO0FBQ3RCLElBQUlDLGlCQUFpQjtBQUNyQixJQUFJQyxvQkFBb0I7QUFDeEIsSUFBSUMsc0JBQXNCO0FBQzFCLElBQUlDLHlCQUF5QjtBQUM3QixJQUFJQyw0QkFBNEI7QUFDaENDLE9BQU9DLE9BQU8sR0FBRztJQUNmSixxQkFBcUJBO0lBQ3JCSCxpQkFBaUJBO0lBQ2pCQyxnQkFBZ0JBO0lBQ2hCQyxtQkFBbUJBO0lBQ25CRSx3QkFBd0JBO0lBQ3hCQywyQkFBMkJBO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlrZS1yZW50YWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2NvbnRlbnQtdHlwZXMuanM/MmM2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGNvcmVDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLXBhY2thZ2UuY29yZS1wcm9wZXJ0aWVzK3htbFwiO1xudmFyIGFwcENvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuZXh0ZW5kZWQtcHJvcGVydGllcyt4bWxcIjtcbnZhciBjdXN0b21Db250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LmN1c3RvbS1wcm9wZXJ0aWVzK3htbFwiO1xudmFyIHNldHRpbmdzQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLnNldHRpbmdzK3htbFwiO1xudmFyIGRpYWdyYW1EYXRhQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5kcmF3aW5nbWwuZGlhZ3JhbURhdGEreG1sXCI7XG52YXIgZGlhZ3JhbURyYXdpbmdDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm1zLW9mZmljZS5kcmF3aW5nbWwuZGlhZ3JhbURyYXdpbmcreG1sXCI7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0dGluZ3NDb250ZW50VHlwZTogc2V0dGluZ3NDb250ZW50VHlwZSxcbiAgY29yZUNvbnRlbnRUeXBlOiBjb3JlQ29udGVudFR5cGUsXG4gIGFwcENvbnRlbnRUeXBlOiBhcHBDb250ZW50VHlwZSxcbiAgY3VzdG9tQ29udGVudFR5cGU6IGN1c3RvbUNvbnRlbnRUeXBlLFxuICBkaWFncmFtRGF0YUNvbnRlbnRUeXBlOiBkaWFncmFtRGF0YUNvbnRlbnRUeXBlLFxuICBkaWFncmFtRHJhd2luZ0NvbnRlbnRUeXBlOiBkaWFncmFtRHJhd2luZ0NvbnRlbnRUeXBlXG59OyJdLCJuYW1lcyI6WyJjb3JlQ29udGVudFR5cGUiLCJhcHBDb250ZW50VHlwZSIsImN1c3RvbUNvbnRlbnRUeXBlIiwic2V0dGluZ3NDb250ZW50VHlwZSIsImRpYWdyYW1EYXRhQ29udGVudFR5cGUiLCJkaWFncmFtRHJhd2luZ0NvbnRlbnRUeXBlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/content-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/doc-utils.js":
/*!****************************************************!*\
  !*** ./node_modules/docxtemplater/js/doc-utils.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _slicedToArray(r, e) {\n    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(r, a) {\n    if (r) {\n        if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n        var t = ({}).toString.call(r).slice(8, -1);\n        return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n    }\n}\nfunction _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];\n    return n;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(r) {\n    if (Array.isArray(r)) return r;\n}\nvar _require = __webpack_require__(/*! @xmldom/xmldom */ \"(rsc)/./node_modules/@xmldom/xmldom/lib/index.js\"), DOMParser = _require.DOMParser, XMLSerializer = _require.XMLSerializer;\nvar _require2 = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\"), throwXmlTagNotFound = _require2.throwXmlTagNotFound;\nvar _require3 = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/docxtemplater/js/utils.js\"), last = _require3.last, first = _require3.first;\nfunction isWhiteSpace(value) {\n    return /^[ \\n\\r\\t]+$/.test(value);\n}\nfunction parser(tag) {\n    return {\n        get: function get(scope) {\n            if (tag === \".\") {\n                return scope;\n            }\n            if (scope) {\n                return scope[tag];\n            }\n            return scope;\n        }\n    };\n}\nvar attrToRegex = {};\nfunction setSingleAttribute(partValue, attr, attrValue) {\n    var regex;\n    // Stryker disable next-line all : because this is an optimisation\n    if (attrToRegex[attr]) {\n        regex = attrToRegex[attr];\n    } else {\n        regex = new RegExp(\"(<.* \".concat(attr, '=\")([^\"]*)(\".*)$'));\n        attrToRegex[attr] = regex;\n    }\n    if (regex.test(partValue)) {\n        return partValue.replace(regex, \"$1\".concat(attrValue, \"$3\"));\n    }\n    var end = partValue.lastIndexOf(\"/>\");\n    if (end === -1) {\n        end = partValue.lastIndexOf(\">\");\n    }\n    return partValue.substr(0, end) + \" \".concat(attr, '=\"').concat(attrValue, '\"') + partValue.substr(end);\n}\nfunction getSingleAttribute(value, attributeName) {\n    var index = value.indexOf(\" \".concat(attributeName, '=\"'));\n    if (index === -1) {\n        return null;\n    }\n    var startIndex = value.substr(index).search(/[\"']/) + index;\n    var endIndex = value.substr(startIndex + 1).search(/[\"']/) + startIndex;\n    return value.substr(startIndex + 1, endIndex - startIndex);\n}\nfunction endsWith(str, suffix) {\n    return str.indexOf(suffix, str.length - suffix.length) !== -1;\n}\nfunction startsWith(str, prefix) {\n    return str.substring(0, prefix.length) === prefix;\n}\nfunction getDuplicates(arr) {\n    var duplicates = [];\n    var hash = {}, result = [];\n    for(var i = 0, l = arr.length; i < l; ++i){\n        if (!hash[arr[i]]) {\n            hash[arr[i]] = true;\n            result.push(arr[i]);\n        } else {\n            duplicates.push(arr[i]);\n        }\n    }\n    return duplicates;\n}\nfunction uniq(arr) {\n    var hash = {}, result = [];\n    for(var i = 0, l = arr.length; i < l; ++i){\n        if (!hash[arr[i]]) {\n            hash[arr[i]] = true;\n            result.push(arr[i]);\n        }\n    }\n    return result;\n}\nfunction chunkBy(parsed, f) {\n    var chunks = [\n        []\n    ];\n    for(var _i2 = 0; _i2 < parsed.length; _i2++){\n        var p = parsed[_i2];\n        var currentChunk = chunks[chunks.length - 1];\n        var res = f(p);\n        if (res === \"start\") {\n            chunks.push([\n                p\n            ]);\n        } else if (res === \"end\") {\n            currentChunk.push(p);\n            chunks.push([]);\n        } else {\n            currentChunk.push(p);\n        }\n    } // Remove empty chunks\n    var result = [];\n    for(var _i4 = 0; _i4 < chunks.length; _i4++){\n        var chunk = chunks[_i4];\n        if (chunk.length > 0) {\n            result.push(chunk);\n        }\n    }\n    return result;\n}\nfunction getDefaults() {\n    return {\n        errorLogging: \"json\",\n        stripInvalidXMLChars: false,\n        paragraphLoop: false,\n        nullGetter: function nullGetter(part) {\n            return part.module ? \"\" : \"undefined\";\n        },\n        xmlFileNames: [\n            \"[Content_Types].xml\"\n        ],\n        parser: parser,\n        linebreaks: false,\n        fileTypeConfig: null,\n        delimiters: {\n            start: \"{\",\n            end: \"}\"\n        },\n        syntax: {\n            changeDelimiterPrefix: \"=\"\n        }\n    };\n}\nfunction xml2str(xmlNode) {\n    return new XMLSerializer().serializeToString(xmlNode).replace(/xmlns(:[a-z0-9]+)?=\"\" ?/g, \"\");\n}\nfunction str2xml(str) {\n    if (str.charCodeAt(0) === 65279) {\n        // BOM sequence\n        str = str.substr(1);\n    }\n    return new DOMParser().parseFromString(str, \"text/xml\");\n}\nvar charMap = [\n    [\n        \"&\",\n        \"&amp;\"\n    ],\n    [\n        \"<\",\n        \"&lt;\"\n    ],\n    [\n        \">\",\n        \"&gt;\"\n    ],\n    [\n        '\"',\n        \"&quot;\"\n    ],\n    [\n        \"'\",\n        \"&apos;\"\n    ]\n];\nvar charMapRegexes = charMap.map(function(_ref) {\n    var _ref2 = _slicedToArray(_ref, 2), endChar = _ref2[0], startChar = _ref2[1];\n    return {\n        rstart: new RegExp(startChar, \"g\"),\n        rend: new RegExp(endChar, \"g\"),\n        start: startChar,\n        end: endChar\n    };\n});\nfunction wordToUtf8(string) {\n    for(var i = charMapRegexes.length - 1; i >= 0; i--){\n        var r = charMapRegexes[i];\n        string = string.replace(r.rstart, r.end);\n    }\n    return string;\n}\nfunction utf8ToWord(string) {\n    // To make sure that the object given is a string (this is a noop for strings).\n    string = string.toString();\n    var r;\n    for(var i = 0, l = charMapRegexes.length; i < l; i++){\n        r = charMapRegexes[i];\n        string = string.replace(r.rend, r.start);\n    }\n    return string;\n}\n// This function is written with for loops for performance\nfunction concatArrays(arrays) {\n    var result = [];\n    for(var _i6 = 0; _i6 < arrays.length; _i6++){\n        var array = arrays[_i6];\n        for(var _i8 = 0; _i8 < array.length; _i8++){\n            var el = array[_i8];\n            result.push(el);\n        }\n    }\n    return result;\n}\nfunction pushArray(array1, array2) {\n    if (!array2) {\n        return array1;\n    }\n    for(var i = 0, len = array2.length; i < len; i++){\n        array1.push(array2[i]);\n    }\n    return array1;\n}\nvar spaceRegexp = new RegExp(String.fromCharCode(160), \"g\");\nfunction convertSpaces(s) {\n    return s.replace(spaceRegexp, \" \");\n}\nfunction pregMatchAll(regex, content) {\n    /*\n   * Regex is a string, content is the content. It returns an array of all\n   * matches with their offset, for example:\n   *\n   * regex=la\n   * content=lolalolilala\n   *\n   * Returns:\n   *\n   * [\n   *    {array: {0: 'la'}, offset: 2},\n   *    {array: {0: 'la'}, offset: 8},\n   *    {array: {0: 'la'}, offset: 10}\n   * ]\n   */ var matchArray = [];\n    var match;\n    while((match = regex.exec(content)) != null){\n        matchArray.push({\n            array: match,\n            offset: match.index\n        });\n    }\n    return matchArray;\n}\nfunction isEnding(value, element) {\n    return value === \"</\" + element + \">\";\n}\nfunction isStarting(value, element) {\n    return value.indexOf(\"<\" + element) === 0 && [\n        \">\",\n        \" \",\n        \"/\"\n    ].indexOf(value[element.length + 1]) !== -1;\n}\nfunction getRight(parsed, element, index) {\n    var val = getRightOrNull(parsed, element, index);\n    if (val !== null) {\n        return val;\n    }\n    throwXmlTagNotFound({\n        position: \"right\",\n        element: element,\n        parsed: parsed,\n        index: index\n    });\n}\nfunction getRightOrNull(parsed, elements, index) {\n    if (typeof elements === \"string\") {\n        elements = [\n            elements\n        ];\n    }\n    var level = 1;\n    for(var i = index, l = parsed.length; i < l; i++){\n        var part = parsed[i];\n        for(var _i10 = 0, _elements2 = elements; _i10 < _elements2.length; _i10++){\n            var element = _elements2[_i10];\n            if (isEnding(part.value, element)) {\n                level--;\n            }\n            if (isStarting(part.value, element)) {\n                level++;\n            }\n            if (level === 0) {\n                return i;\n            }\n        }\n    }\n    return null;\n}\nfunction getLeft(parsed, element, index) {\n    var val = getLeftOrNull(parsed, element, index);\n    if (val !== null) {\n        return val;\n    }\n    throwXmlTagNotFound({\n        position: \"left\",\n        element: element,\n        parsed: parsed,\n        index: index\n    });\n}\nfunction getLeftOrNull(parsed, elements, index) {\n    if (typeof elements === \"string\") {\n        elements = [\n            elements\n        ];\n    }\n    var level = 1;\n    for(var i = index; i >= 0; i--){\n        var part = parsed[i];\n        for(var _i12 = 0, _elements4 = elements; _i12 < _elements4.length; _i12++){\n            var element = _elements4[_i12];\n            if (isStarting(part.value, element)) {\n                level--;\n            }\n            if (isEnding(part.value, element)) {\n                level++;\n            }\n            if (level === 0) {\n                return i;\n            }\n        }\n    }\n    return null;\n}\n/*\n * Stryker disable all : because those are functions that depend on the parsed\n * structure based and we don't want minimal code here, but rather code that\n * makes things clear.\n */ function isTagStart(tagType, _ref3) {\n    var type = _ref3.type, tag = _ref3.tag, position = _ref3.position;\n    return type === \"tag\" && tag === tagType && (position === \"start\" || position === \"selfclosing\");\n}\nfunction isTagEnd(tagType, _ref4) {\n    var type = _ref4.type, tag = _ref4.tag, position = _ref4.position;\n    return type === \"tag\" && tag === tagType && position === \"end\";\n}\nfunction isParagraphStart(_ref5) {\n    var type = _ref5.type, tag = _ref5.tag, position = _ref5.position;\n    return [\n        \"w:p\",\n        \"a:p\"\n    ].indexOf(tag) !== -1 && type === \"tag\" && position === \"start\";\n}\nfunction isParagraphEnd(_ref6) {\n    var type = _ref6.type, tag = _ref6.tag, position = _ref6.position;\n    return [\n        \"w:p\",\n        \"a:p\"\n    ].indexOf(tag) !== -1 && type === \"tag\" && position === \"end\";\n}\nfunction isTextStart(_ref7) {\n    var type = _ref7.type, position = _ref7.position, text = _ref7.text;\n    return text && type === \"tag\" && position === \"start\";\n}\nfunction isTextEnd(_ref8) {\n    var type = _ref8.type, position = _ref8.position, text = _ref8.text;\n    return text && type === \"tag\" && position === \"end\";\n}\nfunction isContent(_ref9) {\n    var type = _ref9.type, position = _ref9.position;\n    return type === \"placeholder\" || type === \"content\" && position === \"insidetag\";\n}\nfunction isModule(_ref10, modules) {\n    var module1 = _ref10.module, type = _ref10.type;\n    if (!(modules instanceof Array)) {\n        modules = [\n            modules\n        ];\n    }\n    return type === \"placeholder\" && modules.indexOf(module1) !== -1;\n}\n// Stryker restore all\nvar corruptCharacters = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/g;\n/*\n * 00    NUL '\\0' (null character)\n * 01    SOH (start of heading)\n * 02    STX (start of text)\n * 03    ETX (end of text)\n * 04    EOT (end of transmission)\n * 05    ENQ (enquiry)\n * 06    ACK (acknowledge)\n * 07    BEL '\\a' (bell)\n * 08    BS  '\\b' (backspace)\n * 0B    VT  '\\v' (vertical tab)\n * 0C    FF  '\\f' (form feed)\n * 0E    SO  (shift out)\n * 0F    SI  (shift in)\n * 10    DLE (data link escape)\n * 11    DC1 (device control 1)\n * 12    DC2 (device control 2)\n * 13    DC3 (device control 3)\n * 14    DC4 (device control 4)\n * 15    NAK (negative ack.)\n * 16    SYN (synchronous idle)\n * 17    ETB (end of trans. blk)\n * 18    CAN (cancel)\n * 19    EM  (end of medium)\n * 1A    SUB (substitute)\n * 1B    ESC (escape)\n * 1C    FS  (file separator)\n * 1D    GS  (group separator)\n * 1E    RS  (record separator)\n * 1F    US  (unit separator)\n */ function hasCorruptCharacters(string) {\n    corruptCharacters.lastIndex = 0;\n    return corruptCharacters.test(string);\n}\nfunction removeCorruptCharacters(string) {\n    if (typeof string !== \"string\") {\n        string = String(string);\n    }\n    return string.replace(corruptCharacters, \"\");\n}\nfunction invertMap(map) {\n    var invertedMap = {};\n    for(var key in map){\n        var value = map[key];\n        invertedMap[value] || (invertedMap[value] = []);\n        invertedMap[value].push(key);\n    }\n    return invertedMap;\n}\n/*\n * This ensures that the sort is stable. The default Array.sort of the browser\n * is not stable in firefox, as the JS spec does not enforce the sort to be\n * stable.\n */ function stableSort(arr, compare) {\n    // Stryker disable all : in previous versions of Chrome, sort was not stable by itself, so we had to add this. This is to support older versions of JS runners.\n    return arr.map(function(item, index) {\n        return {\n            item: item,\n            index: index\n        };\n    }).sort(function(a, b) {\n        return compare(a.item, b.item) || a.index - b.index;\n    }).map(function(_ref11) {\n        var item = _ref11.item;\n        return item;\n    });\n// Stryker restore all\n}\nmodule.exports = {\n    endsWith: endsWith,\n    startsWith: startsWith,\n    isContent: isContent,\n    isParagraphStart: isParagraphStart,\n    isParagraphEnd: isParagraphEnd,\n    isTagStart: isTagStart,\n    isTagEnd: isTagEnd,\n    isTextStart: isTextStart,\n    isTextEnd: isTextEnd,\n    isStarting: isStarting,\n    isEnding: isEnding,\n    isModule: isModule,\n    uniq: uniq,\n    getDuplicates: getDuplicates,\n    chunkBy: chunkBy,\n    last: last,\n    first: first,\n    xml2str: xml2str,\n    str2xml: str2xml,\n    getRightOrNull: getRightOrNull,\n    getRight: getRight,\n    getLeftOrNull: getLeftOrNull,\n    getLeft: getLeft,\n    pregMatchAll: pregMatchAll,\n    convertSpaces: convertSpaces,\n    charMapRegexes: charMapRegexes,\n    hasCorruptCharacters: hasCorruptCharacters,\n    removeCorruptCharacters: removeCorruptCharacters,\n    getDefaults: getDefaults,\n    wordToUtf8: wordToUtf8,\n    utf8ToWord: utf8ToWord,\n    concatArrays: concatArrays,\n    pushArray: pushArray,\n    invertMap: invertMap,\n    charMap: charMap,\n    getSingleAttribute: getSingleAttribute,\n    setSingleAttribute: setSingleAttribute,\n    isWhiteSpace: isWhiteSpace,\n    stableSort: stableSort\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9kb2MtdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxlQUFlQyxDQUFDLEVBQUVDLENBQUM7SUFBSSxPQUFPQyxnQkFBZ0JGLE1BQU1HLHNCQUFzQkgsR0FBR0MsTUFBTUcsNEJBQTRCSixHQUFHQyxNQUFNSTtBQUFvQjtBQUNySixTQUFTQTtJQUFxQixNQUFNLElBQUlDLFVBQVU7QUFBOEk7QUFDaE0sU0FBU0YsNEJBQTRCSixDQUFDLEVBQUVPLENBQUM7SUFBSSxJQUFJUCxHQUFHO1FBQUUsSUFBSSxZQUFZLE9BQU9BLEdBQUcsT0FBT1Esa0JBQWtCUixHQUFHTztRQUFJLElBQUlFLElBQUksRUFBQyxHQUFFQyxRQUFRLENBQUNDLElBQUksQ0FBQ1gsR0FBR1ksS0FBSyxDQUFDLEdBQUcsQ0FBQztRQUFJLE9BQU8sYUFBYUgsS0FBS1QsRUFBRWEsV0FBVyxJQUFLSixDQUFBQSxJQUFJVCxFQUFFYSxXQUFXLENBQUNDLElBQUksR0FBRyxVQUFVTCxLQUFLLFVBQVVBLElBQUlNLE1BQU1DLElBQUksQ0FBQ2hCLEtBQUssZ0JBQWdCUyxLQUFLLDJDQUEyQ1EsSUFBSSxDQUFDUixLQUFLRCxrQkFBa0JSLEdBQUdPLEtBQUssS0FBSztJQUFHO0FBQUU7QUFDelgsU0FBU0Msa0JBQWtCUixDQUFDLEVBQUVPLENBQUM7SUFBSyxTQUFRQSxLQUFLQSxJQUFJUCxFQUFFa0IsTUFBTSxLQUFNWCxDQUFBQSxJQUFJUCxFQUFFa0IsTUFBTTtJQUFHLElBQUssSUFBSWpCLElBQUksR0FBR2tCLElBQUlKLE1BQU1SLElBQUlOLElBQUlNLEdBQUdOLElBQUtrQixDQUFDLENBQUNsQixFQUFFLEdBQUdELENBQUMsQ0FBQ0MsRUFBRTtJQUFFLE9BQU9rQjtBQUFHO0FBQ25KLFNBQVNoQixzQkFBc0JILENBQUMsRUFBRW9CLENBQUM7SUFBSSxJQUFJWCxJQUFJLFFBQVFULElBQUksT0FBTyxlQUFl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LFVBQVVBO0lBQ1ZNLGFBQWFBO0lBQ2JHLFdBQVdBO0lBQ1gxQixZQUFZQTtJQUNaRixVQUFVQTtJQUNWZ0MsVUFBVUE7SUFDVi9GLE1BQU1BO0lBQ05MLGVBQWVBO0lBQ2ZNLFNBQVNBO0lBQ1R0QyxNQUFNQTtJQUNOQyxPQUFPQTtJQUNQNEQsU0FBU0E7SUFDVEcsU0FBU0E7SUFDVHlDLGdCQUFnQkE7SUFDaEJGLFVBQVVBO0lBQ1ZTLGVBQWVBO0lBQ2ZELFNBQVNBO0lBQ1RqQixjQUFjQTtJQUNkRixlQUFlQTtJQUNmeEIsZ0JBQWdCQTtJQUNoQm9FLHNCQUFzQkE7SUFDdEJFLHlCQUF5QkE7SUFDekIzRixhQUFhQTtJQUNiNkIsWUFBWUE7SUFDWkUsWUFBWUE7SUFDWkMsY0FBY0E7SUFDZE0sV0FBV0E7SUFDWHNELFdBQVdBO0lBQ1h4RSxTQUFTQTtJQUNUaEQsb0JBQW9CQTtJQUNwQlgsb0JBQW9CQTtJQUNwQk4sY0FBY0E7SUFDZDRJLFlBQVlBO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaWtlLXJlbnRhbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZG9jLXV0aWxzLmpzP2YwYmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7IH1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCJAeG1sZG9tL3htbGRvbVwiKSxcbiAgRE9NUGFyc2VyID0gX3JlcXVpcmUuRE9NUGFyc2VyLFxuICBYTUxTZXJpYWxpemVyID0gX3JlcXVpcmUuWE1MU2VyaWFsaXplcjtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIiksXG4gIHRocm93WG1sVGFnTm90Rm91bmQgPSBfcmVxdWlyZTIudGhyb3dYbWxUYWdOb3RGb3VuZDtcbnZhciBfcmVxdWlyZTMgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKSxcbiAgbGFzdCA9IF9yZXF1aXJlMy5sYXN0LFxuICBmaXJzdCA9IF9yZXF1aXJlMy5maXJzdDtcbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZSh2YWx1ZSkge1xuICByZXR1cm4gL15bIFxcblxcclxcdF0rJC8udGVzdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBwYXJzZXIodGFnKSB7XG4gIHJldHVybiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoc2NvcGUpIHtcbiAgICAgIGlmICh0YWcgPT09IFwiLlwiKSB7XG4gICAgICAgIHJldHVybiBzY29wZTtcbiAgICAgIH1cbiAgICAgIGlmIChzY29wZSkge1xuICAgICAgICByZXR1cm4gc2NvcGVbdGFnXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY29wZTtcbiAgICB9XG4gIH07XG59XG52YXIgYXR0clRvUmVnZXggPSB7fTtcbmZ1bmN0aW9uIHNldFNpbmdsZUF0dHJpYnV0ZShwYXJ0VmFsdWUsIGF0dHIsIGF0dHJWYWx1ZSkge1xuICB2YXIgcmVnZXg7XG4gIC8vIFN0cnlrZXIgZGlzYWJsZSBuZXh0LWxpbmUgYWxsIDogYmVjYXVzZSB0aGlzIGlzIGFuIG9wdGltaXNhdGlvblxuICBpZiAoYXR0clRvUmVnZXhbYXR0cl0pIHtcbiAgICByZWdleCA9IGF0dHJUb1JlZ2V4W2F0dHJdO1xuICB9IGVsc2Uge1xuICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChcIig8LiogXCIuY29uY2F0KGF0dHIsIFwiPVxcXCIpKFteXFxcIl0qKShcXFwiLiopJFwiKSk7XG4gICAgYXR0clRvUmVnZXhbYXR0cl0gPSByZWdleDtcbiAgfVxuICBpZiAocmVnZXgudGVzdChwYXJ0VmFsdWUpKSB7XG4gICAgcmV0dXJuIHBhcnRWYWx1ZS5yZXBsYWNlKHJlZ2V4LCBcIiQxXCIuY29uY2F0KGF0dHJWYWx1ZSwgXCIkM1wiKSk7XG4gIH1cbiAgdmFyIGVuZCA9IHBhcnRWYWx1ZS5sYXN0SW5kZXhPZihcIi8+XCIpO1xuICBpZiAoZW5kID09PSAtMSkge1xuICAgIGVuZCA9IHBhcnRWYWx1ZS5sYXN0SW5kZXhPZihcIj5cIik7XG4gIH1cbiAgcmV0dXJuIHBhcnRWYWx1ZS5zdWJzdHIoMCwgZW5kKSArIFwiIFwiLmNvbmNhdChhdHRyLCBcIj1cXFwiXCIpLmNvbmNhdChhdHRyVmFsdWUsIFwiXFxcIlwiKSArIHBhcnRWYWx1ZS5zdWJzdHIoZW5kKTtcbn1cbmZ1bmN0aW9uIGdldFNpbmdsZUF0dHJpYnV0ZSh2YWx1ZSwgYXR0cmlidXRlTmFtZSkge1xuICB2YXIgaW5kZXggPSB2YWx1ZS5pbmRleE9mKFwiIFwiLmNvbmNhdChhdHRyaWJ1dGVOYW1lLCBcIj1cXFwiXCIpKTtcbiAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBzdGFydEluZGV4ID0gdmFsdWUuc3Vic3RyKGluZGV4KS5zZWFyY2goL1tcIiddLykgKyBpbmRleDtcbiAgdmFyIGVuZEluZGV4ID0gdmFsdWUuc3Vic3RyKHN0YXJ0SW5kZXggKyAxKS5zZWFyY2goL1tcIiddLykgKyBzdGFydEluZGV4O1xuICByZXR1cm4gdmFsdWUuc3Vic3RyKHN0YXJ0SW5kZXggKyAxLCBlbmRJbmRleCAtIHN0YXJ0SW5kZXgpO1xufVxuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzdWZmaXgpIHtcbiAgcmV0dXJuIHN0ci5pbmRleE9mKHN1ZmZpeCwgc3RyLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpICE9PSAtMTtcbn1cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBwcmVmaXgpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgcHJlZml4Lmxlbmd0aCkgPT09IHByZWZpeDtcbn1cbmZ1bmN0aW9uIGdldER1cGxpY2F0ZXMoYXJyKSB7XG4gIHZhciBkdXBsaWNhdGVzID0gW107XG4gIHZhciBoYXNoID0ge30sXG4gICAgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmICghaGFzaFthcnJbaV1dKSB7XG4gICAgICBoYXNoW2FycltpXV0gPSB0cnVlO1xuICAgICAgcmVzdWx0LnB1c2goYXJyW2ldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZHVwbGljYXRlcy5wdXNoKGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkdXBsaWNhdGVzO1xufVxuZnVuY3Rpb24gdW5pcShhcnIpIHtcbiAgdmFyIGhhc2ggPSB7fSxcbiAgICByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKCFoYXNoW2FycltpXV0pIHtcbiAgICAgIGhhc2hbYXJyW2ldXSA9IHRydWU7XG4gICAgICByZXN1bHQucHVzaChhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2h1bmtCeShwYXJzZWQsIGYpIHtcbiAgdmFyIGNodW5rcyA9IFtbXV07XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHBhcnNlZC5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIHAgPSBwYXJzZWRbX2kyXTtcbiAgICB2YXIgY3VycmVudENodW5rID0gY2h1bmtzW2NodW5rcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgcmVzID0gZihwKTtcbiAgICBpZiAocmVzID09PSBcInN0YXJ0XCIpIHtcbiAgICAgIGNodW5rcy5wdXNoKFtwXSk7XG4gICAgfSBlbHNlIGlmIChyZXMgPT09IFwiZW5kXCIpIHtcbiAgICAgIGN1cnJlbnRDaHVuay5wdXNoKHApO1xuICAgICAgY2h1bmtzLnB1c2goW10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Q2h1bmsucHVzaChwKTtcbiAgICB9XG4gIH0gLy8gUmVtb3ZlIGVtcHR5IGNodW5rc1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGNodW5rcy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgdmFyIGNodW5rID0gY2h1bmtzW19pNF07XG4gICAgaWYgKGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKGNodW5rKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRzKCkge1xuICByZXR1cm4ge1xuICAgIGVycm9yTG9nZ2luZzogXCJqc29uXCIsXG4gICAgc3RyaXBJbnZhbGlkWE1MQ2hhcnM6IGZhbHNlLFxuICAgIHBhcmFncmFwaExvb3A6IGZhbHNlLFxuICAgIG51bGxHZXR0ZXI6IGZ1bmN0aW9uIG51bGxHZXR0ZXIocGFydCkge1xuICAgICAgcmV0dXJuIHBhcnQubW9kdWxlID8gXCJcIiA6IFwidW5kZWZpbmVkXCI7XG4gICAgfSxcbiAgICB4bWxGaWxlTmFtZXM6IFtcIltDb250ZW50X1R5cGVzXS54bWxcIl0sXG4gICAgcGFyc2VyOiBwYXJzZXIsXG4gICAgbGluZWJyZWFrczogZmFsc2UsXG4gICAgZmlsZVR5cGVDb25maWc6IG51bGwsXG4gICAgZGVsaW1pdGVyczoge1xuICAgICAgc3RhcnQ6IFwie1wiLFxuICAgICAgZW5kOiBcIn1cIlxuICAgIH0sXG4gICAgc3ludGF4OiB7XG4gICAgICBjaGFuZ2VEZWxpbWl0ZXJQcmVmaXg6IFwiPVwiXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24geG1sMnN0cih4bWxOb2RlKSB7XG4gIHJldHVybiBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHhtbE5vZGUpLnJlcGxhY2UoL3htbG5zKDpbYS16MC05XSspPz1cIlwiID8vZywgXCJcIik7XG59XG5mdW5jdGlvbiBzdHIyeG1sKHN0cikge1xuICBpZiAoc3RyLmNoYXJDb2RlQXQoMCkgPT09IDY1Mjc5KSB7XG4gICAgLy8gQk9NIHNlcXVlbmNlXG4gICAgc3RyID0gc3RyLnN1YnN0cigxKTtcbiAgfVxuICByZXR1cm4gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzdHIsIFwidGV4dC94bWxcIik7XG59XG52YXIgY2hhck1hcCA9IFtbXCImXCIsIFwiJmFtcDtcIl0sIFtcIjxcIiwgXCImbHQ7XCJdLCBbXCI+XCIsIFwiJmd0O1wiXSwgWydcIicsIFwiJnF1b3Q7XCJdLCBbXCInXCIsIFwiJmFwb3M7XCJdXTtcbnZhciBjaGFyTWFwUmVnZXhlcyA9IGNoYXJNYXAubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgIGVuZENoYXIgPSBfcmVmMlswXSxcbiAgICBzdGFydENoYXIgPSBfcmVmMlsxXTtcbiAgcmV0dXJuIHtcbiAgICByc3RhcnQ6IG5ldyBSZWdFeHAoc3RhcnRDaGFyLCBcImdcIiksXG4gICAgcmVuZDogbmV3IFJlZ0V4cChlbmRDaGFyLCBcImdcIiksXG4gICAgc3RhcnQ6IHN0YXJ0Q2hhcixcbiAgICBlbmQ6IGVuZENoYXJcbiAgfTtcbn0pO1xuZnVuY3Rpb24gd29yZFRvVXRmOChzdHJpbmcpIHtcbiAgZm9yICh2YXIgaSA9IGNoYXJNYXBSZWdleGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHIgPSBjaGFyTWFwUmVnZXhlc1tpXTtcbiAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyLnJzdGFydCwgci5lbmQpO1xuICB9XG4gIHJldHVybiBzdHJpbmc7XG59XG5mdW5jdGlvbiB1dGY4VG9Xb3JkKHN0cmluZykge1xuICAvLyBUbyBtYWtlIHN1cmUgdGhhdCB0aGUgb2JqZWN0IGdpdmVuIGlzIGEgc3RyaW5nICh0aGlzIGlzIGEgbm9vcCBmb3Igc3RyaW5ncykuXG4gIHN0cmluZyA9IHN0cmluZy50b1N0cmluZygpO1xuICB2YXIgcjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGFyTWFwUmVnZXhlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICByID0gY2hhck1hcFJlZ2V4ZXNbaV07XG4gICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2Uoci5yZW5kLCByLnN0YXJ0KTtcbiAgfVxuICByZXR1cm4gc3RyaW5nO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHdyaXR0ZW4gd2l0aCBmb3IgbG9vcHMgZm9yIHBlcmZvcm1hbmNlXG5mdW5jdGlvbiBjb25jYXRBcnJheXMoYXJyYXlzKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgYXJyYXlzLmxlbmd0aDsgX2k2KyspIHtcbiAgICB2YXIgYXJyYXkgPSBhcnJheXNbX2k2XTtcbiAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBhcnJheS5sZW5ndGg7IF9pOCsrKSB7XG4gICAgICB2YXIgZWwgPSBhcnJheVtfaThdO1xuICAgICAgcmVzdWx0LnB1c2goZWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcHVzaEFycmF5KGFycmF5MSwgYXJyYXkyKSB7XG4gIGlmICghYXJyYXkyKSB7XG4gICAgcmV0dXJuIGFycmF5MTtcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyYXkxLnB1c2goYXJyYXkyW2ldKTtcbiAgfVxuICByZXR1cm4gYXJyYXkxO1xufVxudmFyIHNwYWNlUmVnZXhwID0gbmV3IFJlZ0V4cChTdHJpbmcuZnJvbUNoYXJDb2RlKDE2MCksIFwiZ1wiKTtcbmZ1bmN0aW9uIGNvbnZlcnRTcGFjZXMocykge1xuICByZXR1cm4gcy5yZXBsYWNlKHNwYWNlUmVnZXhwLCBcIiBcIik7XG59XG5mdW5jdGlvbiBwcmVnTWF0Y2hBbGwocmVnZXgsIGNvbnRlbnQpIHtcbiAgLypcbiAgICogUmVnZXggaXMgYSBzdHJpbmcsIGNvbnRlbnQgaXMgdGhlIGNvbnRlbnQuIEl0IHJldHVybnMgYW4gYXJyYXkgb2YgYWxsXG4gICAqIG1hdGNoZXMgd2l0aCB0aGVpciBvZmZzZXQsIGZvciBleGFtcGxlOlxuICAgKlxuICAgKiByZWdleD1sYVxuICAgKiBjb250ZW50PWxvbGFsb2xpbGFsYVxuICAgKlxuICAgKiBSZXR1cm5zOlxuICAgKlxuICAgKiBbXG4gICAqICAgIHthcnJheTogezA6ICdsYSd9LCBvZmZzZXQ6IDJ9LFxuICAgKiAgICB7YXJyYXk6IHswOiAnbGEnfSwgb2Zmc2V0OiA4fSxcbiAgICogICAge2FycmF5OiB7MDogJ2xhJ30sIG9mZnNldDogMTB9XG4gICAqIF1cbiAgICovXG4gIHZhciBtYXRjaEFycmF5ID0gW107XG4gIHZhciBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IHJlZ2V4LmV4ZWMoY29udGVudCkpICE9IG51bGwpIHtcbiAgICBtYXRjaEFycmF5LnB1c2goe1xuICAgICAgYXJyYXk6IG1hdGNoLFxuICAgICAgb2Zmc2V0OiBtYXRjaC5pbmRleFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBtYXRjaEFycmF5O1xufVxuZnVuY3Rpb24gaXNFbmRpbmcodmFsdWUsIGVsZW1lbnQpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcIjwvXCIgKyBlbGVtZW50ICsgXCI+XCI7XG59XG5mdW5jdGlvbiBpc1N0YXJ0aW5nKHZhbHVlLCBlbGVtZW50KSB7XG4gIHJldHVybiB2YWx1ZS5pbmRleE9mKFwiPFwiICsgZWxlbWVudCkgPT09IDAgJiYgW1wiPlwiLCBcIiBcIiwgXCIvXCJdLmluZGV4T2YodmFsdWVbZWxlbWVudC5sZW5ndGggKyAxXSkgIT09IC0xO1xufVxuZnVuY3Rpb24gZ2V0UmlnaHQocGFyc2VkLCBlbGVtZW50LCBpbmRleCkge1xuICB2YXIgdmFsID0gZ2V0UmlnaHRPck51bGwocGFyc2VkLCBlbGVtZW50LCBpbmRleCk7XG4gIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHRocm93WG1sVGFnTm90Rm91bmQoe1xuICAgIHBvc2l0aW9uOiBcInJpZ2h0XCIsXG4gICAgZWxlbWVudDogZWxlbWVudCxcbiAgICBwYXJzZWQ6IHBhcnNlZCxcbiAgICBpbmRleDogaW5kZXhcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRSaWdodE9yTnVsbChwYXJzZWQsIGVsZW1lbnRzLCBpbmRleCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgZWxlbWVudHMgPSBbZWxlbWVudHNdO1xuICB9XG4gIHZhciBsZXZlbCA9IDE7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgbCA9IHBhcnNlZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgcGFydCA9IHBhcnNlZFtpXTtcbiAgICBmb3IgKHZhciBfaTEwID0gMCwgX2VsZW1lbnRzMiA9IGVsZW1lbnRzOyBfaTEwIDwgX2VsZW1lbnRzMi5sZW5ndGg7IF9pMTArKykge1xuICAgICAgdmFyIGVsZW1lbnQgPSBfZWxlbWVudHMyW19pMTBdO1xuICAgICAgaWYgKGlzRW5kaW5nKHBhcnQudmFsdWUsIGVsZW1lbnQpKSB7XG4gICAgICAgIGxldmVsLS07XG4gICAgICB9XG4gICAgICBpZiAoaXNTdGFydGluZyhwYXJ0LnZhbHVlLCBlbGVtZW50KSkge1xuICAgICAgICBsZXZlbCsrO1xuICAgICAgfVxuICAgICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldExlZnQocGFyc2VkLCBlbGVtZW50LCBpbmRleCkge1xuICB2YXIgdmFsID0gZ2V0TGVmdE9yTnVsbChwYXJzZWQsIGVsZW1lbnQsIGluZGV4KTtcbiAgaWYgKHZhbCAhPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgdGhyb3dYbWxUYWdOb3RGb3VuZCh7XG4gICAgcG9zaXRpb246IFwibGVmdFwiLFxuICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgcGFyc2VkOiBwYXJzZWQsXG4gICAgaW5kZXg6IGluZGV4XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0TGVmdE9yTnVsbChwYXJzZWQsIGVsZW1lbnRzLCBpbmRleCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgZWxlbWVudHMgPSBbZWxlbWVudHNdO1xuICB9XG4gIHZhciBsZXZlbCA9IDE7XG4gIGZvciAodmFyIGkgPSBpbmRleDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcGFydCA9IHBhcnNlZFtpXTtcbiAgICBmb3IgKHZhciBfaTEyID0gMCwgX2VsZW1lbnRzNCA9IGVsZW1lbnRzOyBfaTEyIDwgX2VsZW1lbnRzNC5sZW5ndGg7IF9pMTIrKykge1xuICAgICAgdmFyIGVsZW1lbnQgPSBfZWxlbWVudHM0W19pMTJdO1xuICAgICAgaWYgKGlzU3RhcnRpbmcocGFydC52YWx1ZSwgZWxlbWVudCkpIHtcbiAgICAgICAgbGV2ZWwtLTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0VuZGluZyhwYXJ0LnZhbHVlLCBlbGVtZW50KSkge1xuICAgICAgICBsZXZlbCsrO1xuICAgICAgfVxuICAgICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLypcbiAqIFN0cnlrZXIgZGlzYWJsZSBhbGwgOiBiZWNhdXNlIHRob3NlIGFyZSBmdW5jdGlvbnMgdGhhdCBkZXBlbmQgb24gdGhlIHBhcnNlZFxuICogc3RydWN0dXJlIGJhc2VkIGFuZCB3ZSBkb24ndCB3YW50IG1pbmltYWwgY29kZSBoZXJlLCBidXQgcmF0aGVyIGNvZGUgdGhhdFxuICogbWFrZXMgdGhpbmdzIGNsZWFyLlxuICovXG5mdW5jdGlvbiBpc1RhZ1N0YXJ0KHRhZ1R5cGUsIF9yZWYzKSB7XG4gIHZhciB0eXBlID0gX3JlZjMudHlwZSxcbiAgICB0YWcgPSBfcmVmMy50YWcsXG4gICAgcG9zaXRpb24gPSBfcmVmMy5wb3NpdGlvbjtcbiAgcmV0dXJuIHR5cGUgPT09IFwidGFnXCIgJiYgdGFnID09PSB0YWdUeXBlICYmIChwb3NpdGlvbiA9PT0gXCJzdGFydFwiIHx8IHBvc2l0aW9uID09PSBcInNlbGZjbG9zaW5nXCIpO1xufVxuZnVuY3Rpb24gaXNUYWdFbmQodGFnVHlwZSwgX3JlZjQpIHtcbiAgdmFyIHR5cGUgPSBfcmVmNC50eXBlLFxuICAgIHRhZyA9IF9yZWY0LnRhZyxcbiAgICBwb3NpdGlvbiA9IF9yZWY0LnBvc2l0aW9uO1xuICByZXR1cm4gdHlwZSA9PT0gXCJ0YWdcIiAmJiB0YWcgPT09IHRhZ1R5cGUgJiYgcG9zaXRpb24gPT09IFwiZW5kXCI7XG59XG5mdW5jdGlvbiBpc1BhcmFncmFwaFN0YXJ0KF9yZWY1KSB7XG4gIHZhciB0eXBlID0gX3JlZjUudHlwZSxcbiAgICB0YWcgPSBfcmVmNS50YWcsXG4gICAgcG9zaXRpb24gPSBfcmVmNS5wb3NpdGlvbjtcbiAgcmV0dXJuIFtcInc6cFwiLCBcImE6cFwiXS5pbmRleE9mKHRhZykgIT09IC0xICYmIHR5cGUgPT09IFwidGFnXCIgJiYgcG9zaXRpb24gPT09IFwic3RhcnRcIjtcbn1cbmZ1bmN0aW9uIGlzUGFyYWdyYXBoRW5kKF9yZWY2KSB7XG4gIHZhciB0eXBlID0gX3JlZjYudHlwZSxcbiAgICB0YWcgPSBfcmVmNi50YWcsXG4gICAgcG9zaXRpb24gPSBfcmVmNi5wb3NpdGlvbjtcbiAgcmV0dXJuIFtcInc6cFwiLCBcImE6cFwiXS5pbmRleE9mKHRhZykgIT09IC0xICYmIHR5cGUgPT09IFwidGFnXCIgJiYgcG9zaXRpb24gPT09IFwiZW5kXCI7XG59XG5mdW5jdGlvbiBpc1RleHRTdGFydChfcmVmNykge1xuICB2YXIgdHlwZSA9IF9yZWY3LnR5cGUsXG4gICAgcG9zaXRpb24gPSBfcmVmNy5wb3NpdGlvbixcbiAgICB0ZXh0ID0gX3JlZjcudGV4dDtcbiAgcmV0dXJuIHRleHQgJiYgdHlwZSA9PT0gXCJ0YWdcIiAmJiBwb3NpdGlvbiA9PT0gXCJzdGFydFwiO1xufVxuZnVuY3Rpb24gaXNUZXh0RW5kKF9yZWY4KSB7XG4gIHZhciB0eXBlID0gX3JlZjgudHlwZSxcbiAgICBwb3NpdGlvbiA9IF9yZWY4LnBvc2l0aW9uLFxuICAgIHRleHQgPSBfcmVmOC50ZXh0O1xuICByZXR1cm4gdGV4dCAmJiB0eXBlID09PSBcInRhZ1wiICYmIHBvc2l0aW9uID09PSBcImVuZFwiO1xufVxuZnVuY3Rpb24gaXNDb250ZW50KF9yZWY5KSB7XG4gIHZhciB0eXBlID0gX3JlZjkudHlwZSxcbiAgICBwb3NpdGlvbiA9IF9yZWY5LnBvc2l0aW9uO1xuICByZXR1cm4gdHlwZSA9PT0gXCJwbGFjZWhvbGRlclwiIHx8IHR5cGUgPT09IFwiY29udGVudFwiICYmIHBvc2l0aW9uID09PSBcImluc2lkZXRhZ1wiO1xufVxuZnVuY3Rpb24gaXNNb2R1bGUoX3JlZjEwLCBtb2R1bGVzKSB7XG4gIHZhciBtb2R1bGUgPSBfcmVmMTAubW9kdWxlLFxuICAgIHR5cGUgPSBfcmVmMTAudHlwZTtcbiAgaWYgKCEobW9kdWxlcyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgIG1vZHVsZXMgPSBbbW9kdWxlc107XG4gIH1cbiAgcmV0dXJuIHR5cGUgPT09IFwicGxhY2Vob2xkZXJcIiAmJiBtb2R1bGVzLmluZGV4T2YobW9kdWxlKSAhPT0gLTE7XG59XG4vLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG5cbnZhciBjb3JydXB0Q2hhcmFjdGVycyA9IC9bXFx4MDAtXFx4MDhcXHgwQlxceDBDXFx4MEUtXFx4MUZdL2c7XG4vKlxuICogMDAgICAgTlVMICdcXDAnIChudWxsIGNoYXJhY3RlcilcbiAqIDAxICAgIFNPSCAoc3RhcnQgb2YgaGVhZGluZylcbiAqIDAyICAgIFNUWCAoc3RhcnQgb2YgdGV4dClcbiAqIDAzICAgIEVUWCAoZW5kIG9mIHRleHQpXG4gKiAwNCAgICBFT1QgKGVuZCBvZiB0cmFuc21pc3Npb24pXG4gKiAwNSAgICBFTlEgKGVucXVpcnkpXG4gKiAwNiAgICBBQ0sgKGFja25vd2xlZGdlKVxuICogMDcgICAgQkVMICdcXGEnIChiZWxsKVxuICogMDggICAgQlMgICdcXGInIChiYWNrc3BhY2UpXG4gKiAwQiAgICBWVCAgJ1xcdicgKHZlcnRpY2FsIHRhYilcbiAqIDBDICAgIEZGICAnXFxmJyAoZm9ybSBmZWVkKVxuICogMEUgICAgU08gIChzaGlmdCBvdXQpXG4gKiAwRiAgICBTSSAgKHNoaWZ0IGluKVxuICogMTAgICAgRExFIChkYXRhIGxpbmsgZXNjYXBlKVxuICogMTEgICAgREMxIChkZXZpY2UgY29udHJvbCAxKVxuICogMTIgICAgREMyIChkZXZpY2UgY29udHJvbCAyKVxuICogMTMgICAgREMzIChkZXZpY2UgY29udHJvbCAzKVxuICogMTQgICAgREM0IChkZXZpY2UgY29udHJvbCA0KVxuICogMTUgICAgTkFLIChuZWdhdGl2ZSBhY2suKVxuICogMTYgICAgU1lOIChzeW5jaHJvbm91cyBpZGxlKVxuICogMTcgICAgRVRCIChlbmQgb2YgdHJhbnMuIGJsaylcbiAqIDE4ICAgIENBTiAoY2FuY2VsKVxuICogMTkgICAgRU0gIChlbmQgb2YgbWVkaXVtKVxuICogMUEgICAgU1VCIChzdWJzdGl0dXRlKVxuICogMUIgICAgRVNDIChlc2NhcGUpXG4gKiAxQyAgICBGUyAgKGZpbGUgc2VwYXJhdG9yKVxuICogMUQgICAgR1MgIChncm91cCBzZXBhcmF0b3IpXG4gKiAxRSAgICBSUyAgKHJlY29yZCBzZXBhcmF0b3IpXG4gKiAxRiAgICBVUyAgKHVuaXQgc2VwYXJhdG9yKVxuICovXG5mdW5jdGlvbiBoYXNDb3JydXB0Q2hhcmFjdGVycyhzdHJpbmcpIHtcbiAgY29ycnVwdENoYXJhY3RlcnMubGFzdEluZGV4ID0gMDtcbiAgcmV0dXJuIGNvcnJ1cHRDaGFyYWN0ZXJzLnRlc3Qoc3RyaW5nKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNvcnJ1cHRDaGFyYWN0ZXJzKHN0cmluZykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHN0cmluZyA9IFN0cmluZyhzdHJpbmcpO1xuICB9XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShjb3JydXB0Q2hhcmFjdGVycywgXCJcIik7XG59XG5mdW5jdGlvbiBpbnZlcnRNYXAobWFwKSB7XG4gIHZhciBpbnZlcnRlZE1hcCA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gbWFwKSB7XG4gICAgdmFyIHZhbHVlID0gbWFwW2tleV07XG4gICAgaW52ZXJ0ZWRNYXBbdmFsdWVdIHx8IChpbnZlcnRlZE1hcFt2YWx1ZV0gPSBbXSk7XG4gICAgaW52ZXJ0ZWRNYXBbdmFsdWVdLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gaW52ZXJ0ZWRNYXA7XG59XG4vKlxuICogVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHNvcnQgaXMgc3RhYmxlLiBUaGUgZGVmYXVsdCBBcnJheS5zb3J0IG9mIHRoZSBicm93c2VyXG4gKiBpcyBub3Qgc3RhYmxlIGluIGZpcmVmb3gsIGFzIHRoZSBKUyBzcGVjIGRvZXMgbm90IGVuZm9yY2UgdGhlIHNvcnQgdG8gYmVcbiAqIHN0YWJsZS5cbiAqL1xuZnVuY3Rpb24gc3RhYmxlU29ydChhcnIsIGNvbXBhcmUpIHtcbiAgLy8gU3RyeWtlciBkaXNhYmxlIGFsbCA6IGluIHByZXZpb3VzIHZlcnNpb25zIG9mIENocm9tZSwgc29ydCB3YXMgbm90IHN0YWJsZSBieSBpdHNlbGYsIHNvIHdlIGhhZCB0byBhZGQgdGhpcy4gVGhpcyBpcyB0byBzdXBwb3J0IG9sZGVyIHZlcnNpb25zIG9mIEpTIHJ1bm5lcnMuXG4gIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtOiBpdGVtLFxuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfTtcbiAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBjb21wYXJlKGEuaXRlbSwgYi5pdGVtKSB8fCBhLmluZGV4IC0gYi5pbmRleDtcbiAgfSkubWFwKGZ1bmN0aW9uIChfcmVmMTEpIHtcbiAgICB2YXIgaXRlbSA9IF9yZWYxMS5pdGVtO1xuICAgIHJldHVybiBpdGVtO1xuICB9KTtcbiAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVuZHNXaXRoOiBlbmRzV2l0aCxcbiAgc3RhcnRzV2l0aDogc3RhcnRzV2l0aCxcbiAgaXNDb250ZW50OiBpc0NvbnRlbnQsXG4gIGlzUGFyYWdyYXBoU3RhcnQ6IGlzUGFyYWdyYXBoU3RhcnQsXG4gIGlzUGFyYWdyYXBoRW5kOiBpc1BhcmFncmFwaEVuZCxcbiAgaXNUYWdTdGFydDogaXNUYWdTdGFydCxcbiAgaXNUYWdFbmQ6IGlzVGFnRW5kLFxuICBpc1RleHRTdGFydDogaXNUZXh0U3RhcnQsXG4gIGlzVGV4dEVuZDogaXNUZXh0RW5kLFxuICBpc1N0YXJ0aW5nOiBpc1N0YXJ0aW5nLFxuICBpc0VuZGluZzogaXNFbmRpbmcsXG4gIGlzTW9kdWxlOiBpc01vZHVsZSxcbiAgdW5pcTogdW5pcSxcbiAgZ2V0RHVwbGljYXRlczogZ2V0RHVwbGljYXRlcyxcbiAgY2h1bmtCeTogY2h1bmtCeSxcbiAgbGFzdDogbGFzdCxcbiAgZmlyc3Q6IGZpcnN0LFxuICB4bWwyc3RyOiB4bWwyc3RyLFxuICBzdHIyeG1sOiBzdHIyeG1sLFxuICBnZXRSaWdodE9yTnVsbDogZ2V0UmlnaHRPck51bGwsXG4gIGdldFJpZ2h0OiBnZXRSaWdodCxcbiAgZ2V0TGVmdE9yTnVsbDogZ2V0TGVmdE9yTnVsbCxcbiAgZ2V0TGVmdDogZ2V0TGVmdCxcbiAgcHJlZ01hdGNoQWxsOiBwcmVnTWF0Y2hBbGwsXG4gIGNvbnZlcnRTcGFjZXM6IGNvbnZlcnRTcGFjZXMsXG4gIGNoYXJNYXBSZWdleGVzOiBjaGFyTWFwUmVnZXhlcyxcbiAgaGFzQ29ycnVwdENoYXJhY3RlcnM6IGhhc0NvcnJ1cHRDaGFyYWN0ZXJzLFxuICByZW1vdmVDb3JydXB0Q2hhcmFjdGVyczogcmVtb3ZlQ29ycnVwdENoYXJhY3RlcnMsXG4gIGdldERlZmF1bHRzOiBnZXREZWZhdWx0cyxcbiAgd29yZFRvVXRmODogd29yZFRvVXRmOCxcbiAgdXRmOFRvV29yZDogdXRmOFRvV29yZCxcbiAgY29uY2F0QXJyYXlzOiBjb25jYXRBcnJheXMsXG4gIHB1c2hBcnJheTogcHVzaEFycmF5LFxuICBpbnZlcnRNYXA6IGludmVydE1hcCxcbiAgY2hhck1hcDogY2hhck1hcCxcbiAgZ2V0U2luZ2xlQXR0cmlidXRlOiBnZXRTaW5nbGVBdHRyaWJ1dGUsXG4gIHNldFNpbmdsZUF0dHJpYnV0ZTogc2V0U2luZ2xlQXR0cmlidXRlLFxuICBpc1doaXRlU3BhY2U6IGlzV2hpdGVTcGFjZSxcbiAgc3RhYmxlU29ydDogc3RhYmxlU29ydFxufTsiXSwibmFtZXMiOlsiX3NsaWNlZFRvQXJyYXkiLCJyIiwiZSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJUeXBlRXJyb3IiLCJhIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJ0IiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwibGVuZ3RoIiwibiIsImwiLCJTeW1ib2wiLCJpdGVyYXRvciIsImkiLCJ1IiwiZiIsIm8iLCJuZXh0IiwiT2JqZWN0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImlzQXJyYXkiLCJfcmVxdWlyZSIsInJlcXVpcmUiLCJET01QYXJzZXIiLCJYTUxTZXJpYWxpemVyIiwiX3JlcXVpcmUyIiwidGhyb3dYbWxUYWdOb3RGb3VuZCIsIl9yZXF1aXJlMyIsImxhc3QiLCJmaXJzdCIsImlzV2hpdGVTcGFjZSIsInBhcnNlciIsInRhZyIsImdldCIsInNjb3BlIiwiYXR0clRvUmVnZXgiLCJzZXRTaW5nbGVBdHRyaWJ1dGUiLCJwYXJ0VmFsdWUiLCJhdHRyIiwiYXR0clZhbHVlIiwicmVnZXgiLCJSZWdFeHAiLCJjb25jYXQiLCJyZXBsYWNlIiwiZW5kIiwibGFzdEluZGV4T2YiLCJzdWJzdHIiLCJnZXRTaW5nbGVBdHRyaWJ1dGUiLCJhdHRyaWJ1dGVOYW1lIiwiaW5kZXgiLCJpbmRleE9mIiwic3RhcnRJbmRleCIsInNlYXJjaCIsImVuZEluZGV4IiwiZW5kc1dpdGgiLCJzdHIiLCJzdWZmaXgiLCJzdGFydHNXaXRoIiwicHJlZml4Iiwic3Vic3RyaW5nIiwiZ2V0RHVwbGljYXRlcyIsImFyciIsImR1cGxpY2F0ZXMiLCJoYXNoIiwicmVzdWx0IiwidW5pcSIsImNodW5rQnkiLCJwYXJzZWQiLCJjaHVua3MiLCJfaTIiLCJwIiwiY3VycmVudENodW5rIiwicmVzIiwiX2k0IiwiY2h1bmsiLCJnZXREZWZhdWx0cyIsImVycm9yTG9nZ2luZyIsInN0cmlwSW52YWxpZFhNTENoYXJzIiwicGFyYWdyYXBoTG9vcCIsIm51bGxHZXR0ZXIiLCJwYXJ0IiwibW9kdWxlIiwieG1sRmlsZU5hbWVzIiwibGluZWJyZWFrcyIsImZpbGVUeXBlQ29uZmlnIiwiZGVsaW1pdGVycyIsInN0YXJ0Iiwic3ludGF4IiwiY2hhbmdlRGVsaW1pdGVyUHJlZml4IiwieG1sMnN0ciIsInhtbE5vZGUiLCJzZXJpYWxpemVUb1N0cmluZyIsInN0cjJ4bWwiLCJjaGFyQ29kZUF0IiwicGFyc2VGcm9tU3RyaW5nIiwiY2hhck1hcCIsImNoYXJNYXBSZWdleGVzIiwibWFwIiwiX3JlZiIsIl9yZWYyIiwiZW5kQ2hhciIsInN0YXJ0Q2hhciIsInJzdGFydCIsInJlbmQiLCJ3b3JkVG9VdGY4Iiwic3RyaW5nIiwidXRmOFRvV29yZCIsImNvbmNhdEFycmF5cyIsImFycmF5cyIsIl9pNiIsImFycmF5IiwiX2k4IiwiZWwiLCJwdXNoQXJyYXkiLCJhcnJheTEiLCJhcnJheTIiLCJsZW4iLCJzcGFjZVJlZ2V4cCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImNvbnZlcnRTcGFjZXMiLCJzIiwicHJlZ01hdGNoQWxsIiwiY29udGVudCIsIm1hdGNoQXJyYXkiLCJtYXRjaCIsImV4ZWMiLCJvZmZzZXQiLCJpc0VuZGluZyIsImVsZW1lbnQiLCJpc1N0YXJ0aW5nIiwiZ2V0UmlnaHQiLCJ2YWwiLCJnZXRSaWdodE9yTnVsbCIsInBvc2l0aW9uIiwiZWxlbWVudHMiLCJsZXZlbCIsIl9pMTAiLCJfZWxlbWVudHMyIiwiZ2V0TGVmdCIsImdldExlZnRPck51bGwiLCJfaTEyIiwiX2VsZW1lbnRzNCIsImlzVGFnU3RhcnQiLCJ0YWdUeXBlIiwiX3JlZjMiLCJ0eXBlIiwiaXNUYWdFbmQiLCJfcmVmNCIsImlzUGFyYWdyYXBoU3RhcnQiLCJfcmVmNSIsImlzUGFyYWdyYXBoRW5kIiwiX3JlZjYiLCJpc1RleHRTdGFydCIsIl9yZWY3IiwidGV4dCIsImlzVGV4dEVuZCIsIl9yZWY4IiwiaXNDb250ZW50IiwiX3JlZjkiLCJpc01vZHVsZSIsIl9yZWYxMCIsIm1vZHVsZXMiLCJjb3JydXB0Q2hhcmFjdGVycyIsImhhc0NvcnJ1cHRDaGFyYWN0ZXJzIiwibGFzdEluZGV4IiwicmVtb3ZlQ29ycnVwdENoYXJhY3RlcnMiLCJpbnZlcnRNYXAiLCJpbnZlcnRlZE1hcCIsImtleSIsInN0YWJsZVNvcnQiLCJjb21wYXJlIiwiaXRlbSIsInNvcnQiLCJiIiwiX3JlZjExIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/doc-utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/docxtemplater.js":
/*!********************************************************!*\
  !*** ./node_modules/docxtemplater/js/docxtemplater.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar _excluded = [\n    \"modules\"\n];\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\nfunction _slicedToArray(r, e) {\n    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(r, a) {\n    if (r) {\n        if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n        var t = ({}).toString.call(r).slice(8, -1);\n        return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n    }\n}\nfunction _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];\n    return n;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(r) {\n    if (Array.isArray(r)) return r;\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _objectWithoutProperties(e, t) {\n    if (null == e) return {};\n    var o, r, i = _objectWithoutPropertiesLoose(e, t);\n    if (Object.getOwnPropertySymbols) {\n        var n = Object.getOwnPropertySymbols(e);\n        for(r = 0; r < n.length; r++)o = n[r], -1 === t.indexOf(o) && ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n    }\n    return i;\n}\nfunction _objectWithoutPropertiesLoose(r, e) {\n    if (null == r) return {};\n    var t = {};\n    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {\n        if (-1 !== e.indexOf(n)) continue;\n        t[n] = r[n];\n    }\n    return t;\n}\nfunction _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n    for(var t = 0; t < r.length; t++){\n        var o = r[t];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n}\nfunction _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n        writable: !1\n    }), e;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar DocUtils = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\");\nDocUtils.traits = __webpack_require__(/*! ./traits.js */ \"(rsc)/./node_modules/docxtemplater/js/traits.js\");\nDocUtils.moduleWrapper = __webpack_require__(/*! ./module-wrapper.js */ \"(rsc)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar commonModule = __webpack_require__(/*! ./modules/common.js */ \"(rsc)/./node_modules/docxtemplater/js/modules/common.js\");\nvar createScope = __webpack_require__(/*! ./scope-manager.js */ \"(rsc)/./node_modules/docxtemplater/js/scope-manager.js\");\nvar Lexer = __webpack_require__(/*! ./lexer.js */ \"(rsc)/./node_modules/docxtemplater/js/lexer.js\");\nvar _require = __webpack_require__(/*! ./get-tags.js */ \"(rsc)/./node_modules/docxtemplater/js/get-tags.js\"), _getTags = _require.getTags;\nvar logErrors = __webpack_require__(/*! ./error-logger.js */ \"(rsc)/./node_modules/docxtemplater/js/error-logger.js\");\nvar collectContentTypes = __webpack_require__(/*! ./collect-content-types.js */ \"(rsc)/./node_modules/docxtemplater/js/collect-content-types.js\");\nvar _require2 = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\"), throwMultiError = _require2.throwMultiError, throwResolveBeforeCompile = _require2.throwResolveBeforeCompile, throwRenderInvalidTemplate = _require2.throwRenderInvalidTemplate, throwRenderTwice = _require2.throwRenderTwice, XTInternalError = _require2.XTInternalError, XTTemplateError = _require2.XTTemplateError, throwFileTypeNotIdentified = _require2.throwFileTypeNotIdentified, throwFileTypeNotHandled = _require2.throwFileTypeNotHandled, throwApiVersionError = _require2.throwApiVersionError;\nvar getDefaults = DocUtils.getDefaults, str2xml = DocUtils.str2xml, xml2str = DocUtils.xml2str, moduleWrapper = DocUtils.moduleWrapper, concatArrays = DocUtils.concatArrays, uniq = DocUtils.uniq, getDuplicates = DocUtils.getDuplicates, stableSort = DocUtils.stableSort, pushArray = DocUtils.pushArray;\nvar ctXML = \"[Content_Types].xml\";\nvar relsFile = \"_rels/.rels\";\nvar currentModuleApiVersion = [\n    3,\n    46,\n    0\n];\nfunction zipFileOrder(files) {\n    var allFiles = [];\n    for(var name in files){\n        allFiles.push(name);\n    }\n    /*\n   * The first files that need to be put in the zip file are :\n   * [Content_Types].xml and _rels/.rels\n   */ var resultFiles = [\n        ctXML,\n        relsFile\n    ];\n    /*\n   * The next files that should be in the zip file are :\n   *\n   * - word/* (ie word/document.xml, word/header1.xml, ...)\n   * - xl/* (ie xl/worksheets/sheet1.xml)\n   * - ppt/* (ie ppt/slides/slide1.xml)\n   */ var prefixes = [\n        \"word/\",\n        \"xl/\",\n        \"ppt/\"\n    ];\n    for(var _i2 = 0; _i2 < allFiles.length; _i2++){\n        var _name = allFiles[_i2];\n        for(var _i4 = 0; _i4 < prefixes.length; _i4++){\n            var prefix = prefixes[_i4];\n            if (_name.indexOf(\"\".concat(prefix)) === 0) {\n                resultFiles.push(_name);\n            }\n        }\n    }\n    /*\n   * Push the rest of files, such as docProps/core.xml and docProps/app.xml\n   */ for(var _i6 = 0; _i6 < allFiles.length; _i6++){\n        var _name2 = allFiles[_i6];\n        if (resultFiles.indexOf(_name2) === -1) {\n            resultFiles.push(_name2);\n        }\n    }\n    return resultFiles;\n}\nfunction deprecatedMessage(obj, message) {\n    if (obj.hideDeprecations === true) {\n        return;\n    }\n    // eslint-disable-next-line no-console\n    console.warn(message);\n}\nfunction deprecatedMethod(obj, method) {\n    if (obj.hideDeprecations === true) {\n        return;\n    }\n    return deprecatedMessage(obj, 'Deprecated method \".'.concat(method, '\", view upgrade guide : https://docxtemplater.com/docs/api/#upgrade-guide, stack : ').concat(new Error().stack));\n}\nfunction dropUnsupportedFileTypesModules(doc) {\n    doc.modules = doc.modules.filter(function(module1) {\n        if (!module1.supportedFileTypes) {\n            return true;\n        }\n        if (!Array.isArray(module1.supportedFileTypes)) {\n            throw new Error(\"The supportedFileTypes field of the module must be an array\");\n        }\n        var isSupportedModule = module1.supportedFileTypes.includes(doc.fileType);\n        if (!isSupportedModule) {\n            module1.on(\"detached\");\n        }\n        return isSupportedModule;\n    });\n}\nfunction verifyErrors(doc) {\n    var compiled = doc.compiled;\n    doc.errors = concatArrays(Object.keys(compiled).map(function(name) {\n        return compiled[name].allErrors;\n    }));\n    if (doc.errors.length !== 0) {\n        if (doc.options.errorLogging) {\n            logErrors(doc.errors, doc.options.errorLogging);\n        }\n        throwMultiError(doc.errors);\n    }\n}\nvar Docxtemplater = /*#__PURE__*/ function() {\n    function Docxtemplater(zip) {\n        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$modules = _ref.modules, modules = _ref$modules === void 0 ? [] : _ref$modules, options = _objectWithoutProperties(_ref, _excluded);\n        _classCallCheck(this, Docxtemplater);\n        this.targets = [];\n        this.rendered = false;\n        this.scopeManagers = {};\n        this.compiled = {};\n        this.modules = [\n            commonModule()\n        ];\n        this.xmlDocuments = {};\n        if (arguments.length === 0) {\n            deprecatedMessage(this, \"Deprecated docxtemplater constructor with no arguments, view upgrade guide : https://docxtemplater.com/docs/api/#upgrade-guide, stack : \".concat(new Error().stack));\n            this.hideDeprecations = true;\n            this.setOptions(options);\n        } else {\n            this.hideDeprecations = true;\n            this.setOptions(options);\n            if (!zip || !zip.files || typeof zip.file !== \"function\") {\n                throw new Error(\"The first argument of docxtemplater's constructor must be a valid zip file (jszip v2 or pizzip v3)\");\n            }\n            if (!Array.isArray(modules)) {\n                throw new Error(\"The modules argument of docxtemplater's constructor must be an array\");\n            }\n            for(var _i8 = 0; _i8 < modules.length; _i8++){\n                var _module = modules[_i8];\n                this.attachModule(_module);\n            }\n            this.loadZip(zip);\n            this.compile();\n            this.v4Constructor = true;\n        }\n        this.hideDeprecations = false;\n    }\n    return _createClass(Docxtemplater, [\n        {\n            key: \"verifyApiVersion\",\n            value: function verifyApiVersion(neededVersion) {\n                neededVersion = neededVersion.split(\".\").map(function(i) {\n                    return parseInt(i, 10);\n                });\n                if (neededVersion.length !== 3) {\n                    throwApiVersionError(\"neededVersion is not a valid version\", {\n                        neededVersion: neededVersion,\n                        explanation: \"the neededVersion must be an array of length 3\"\n                    });\n                }\n                if (neededVersion[0] !== currentModuleApiVersion[0]) {\n                    throwApiVersionError(\"The major api version do not match, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n                        neededVersion: neededVersion,\n                        currentModuleApiVersion: currentModuleApiVersion,\n                        explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n                    });\n                }\n                if (neededVersion[1] > currentModuleApiVersion[1]) {\n                    throwApiVersionError(\"The minor api version is not uptodate, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n                        neededVersion: neededVersion,\n                        currentModuleApiVersion: currentModuleApiVersion,\n                        explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n                    });\n                }\n                if (neededVersion[1] === currentModuleApiVersion[1] && neededVersion[2] > currentModuleApiVersion[2]) {\n                    throwApiVersionError(\"The patch api version is not uptodate, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n                        neededVersion: neededVersion,\n                        currentModuleApiVersion: currentModuleApiVersion,\n                        explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n                    });\n                }\n                return true;\n            }\n        },\n        {\n            key: \"setModules\",\n            value: function setModules(obj) {\n                for(var _i10 = 0, _this$modules2 = this.modules; _i10 < _this$modules2.length; _i10++){\n                    var _module2 = _this$modules2[_i10];\n                    _module2.set(obj);\n                }\n            }\n        },\n        {\n            key: \"sendEvent\",\n            value: function sendEvent(eventName) {\n                for(var _i12 = 0, _this$modules4 = this.modules; _i12 < _this$modules4.length; _i12++){\n                    var _module3 = _this$modules4[_i12];\n                    _module3.on(eventName);\n                }\n            }\n        },\n        {\n            key: \"attachModule\",\n            value: function attachModule(module1) {\n                if (this.v4Constructor) {\n                    throw new XTInternalError(\"attachModule() should not be called manually when using the v4 constructor\");\n                }\n                deprecatedMethod(this, \"attachModule\");\n                var moduleType = _typeof(module1);\n                if (moduleType === \"function\") {\n                    throw new XTInternalError(\"Cannot attach a class/function as a module. Most probably you forgot to instantiate the module by using `new` on the module.\");\n                }\n                if (!module1 || moduleType !== \"object\") {\n                    throw new XTInternalError(\"Cannot attachModule with a falsy value\");\n                }\n                if (module1.requiredAPIVersion) {\n                    this.verifyApiVersion(module1.requiredAPIVersion);\n                }\n                if (module1.attached === true) {\n                    if (typeof module1.clone === \"function\") {\n                        module1 = module1.clone();\n                    } else {\n                        throw new Error('Cannot attach a module that was already attached : \"'.concat(module1.name, '\". The most likely cause is that you are instantiating the module at the root level, and using it for multiple instances of Docxtemplater'));\n                    }\n                }\n                module1.attached = true;\n                var wrappedModule = moduleWrapper(module1);\n                this.modules.push(wrappedModule);\n                wrappedModule.on(\"attached\");\n                if (this.fileType) {\n                    dropUnsupportedFileTypesModules(this);\n                }\n                return this;\n            }\n        },\n        {\n            key: \"setOptions\",\n            value: function setOptions(options) {\n                var _this$delimiters, _this$delimiters2;\n                if (this.v4Constructor) {\n                    throw new Error(\"setOptions() should not be called manually when using the v4 constructor\");\n                }\n                deprecatedMethod(this, \"setOptions\");\n                if (!options) {\n                    throw new Error(\"setOptions should be called with an object as first parameter\");\n                }\n                this.options = {};\n                var defaults = getDefaults();\n                for(var key in defaults){\n                    var defaultValue = defaults[key];\n                    this.options[key] = options[key] != null ? options[key] : this[key] || defaultValue;\n                    this[key] = this.options[key];\n                }\n                (_this$delimiters = this.delimiters).start && (_this$delimiters.start = DocUtils.utf8ToWord(this.delimiters.start));\n                (_this$delimiters2 = this.delimiters).end && (_this$delimiters2.end = DocUtils.utf8ToWord(this.delimiters.end));\n                return this;\n            }\n        },\n        {\n            key: \"loadZip\",\n            value: function loadZip(zip) {\n                if (this.v4Constructor) {\n                    throw new Error(\"loadZip() should not be called manually when using the v4 constructor\");\n                }\n                deprecatedMethod(this, \"loadZip\");\n                if (zip.loadAsync) {\n                    throw new XTInternalError(\"Docxtemplater doesn't handle JSZip version >=3, please use pizzip\");\n                }\n                this.zip = zip;\n                this.updateFileTypeConfig();\n                this.modules = concatArrays([\n                    this.fileTypeConfig.baseModules.map(function(moduleFunction) {\n                        return moduleFunction();\n                    }),\n                    this.modules\n                ]);\n                for(var _i14 = 0, _this$modules6 = this.modules; _i14 < _this$modules6.length; _i14++){\n                    var _module4 = _this$modules6[_i14];\n                    _module4.zip = this.zip;\n                    _module4.docxtemplater = this;\n                }\n                dropUnsupportedFileTypesModules(this);\n                return this;\n            }\n        },\n        {\n            key: \"precompileFile\",\n            value: function precompileFile(fileName) {\n                var currentFile = this.createTemplateClass(fileName);\n                currentFile.preparse();\n                this.compiled[fileName] = currentFile;\n            }\n        },\n        {\n            key: \"compileFile\",\n            value: function compileFile(fileName) {\n                this.compiled[fileName].parse();\n            }\n        },\n        {\n            key: \"getScopeManager\",\n            value: function getScopeManager(to, currentFile, tags) {\n                var _this$scopeManagers;\n                (_this$scopeManagers = this.scopeManagers)[to] || (_this$scopeManagers[to] = createScope({\n                    tags: tags,\n                    parser: this.parser,\n                    cachedParsers: currentFile.cachedParsers\n                }));\n                return this.scopeManagers[to];\n            }\n        },\n        {\n            key: \"resolveData\",\n            value: function resolveData(data) {\n                var _this = this;\n                deprecatedMethod(this, \"resolveData\");\n                var errors = [];\n                if (!Object.keys(this.compiled).length) {\n                    throwResolveBeforeCompile();\n                }\n                return Promise.resolve(data).then(function(data) {\n                    _this.data = data;\n                    _this.setModules({\n                        data: _this.data,\n                        Lexer: Lexer\n                    });\n                    _this.mapper = _this.modules.reduce(function(value, module1) {\n                        return module1.getRenderedMap(value);\n                    }, {});\n                    return Promise.all(Object.keys(_this.mapper).map(function(to) {\n                        var _this$mapper$to = _this.mapper[to], from = _this$mapper$to.from, data = _this$mapper$to.data;\n                        return Promise.resolve(data).then(function(data) {\n                            var currentFile = _this.compiled[from];\n                            currentFile.filePath = to;\n                            currentFile.scopeManager = _this.getScopeManager(to, currentFile, data);\n                            return currentFile.resolveTags(data).then(function(result) {\n                                currentFile.scopeManager.finishedResolving = true;\n                                return result;\n                            }, function(errs) {\n                                pushArray(errors, errs);\n                            });\n                        });\n                    })).then(function(resolved) {\n                        if (errors.length !== 0) {\n                            if (_this.options.errorLogging) {\n                                logErrors(errors, _this.options.errorLogging);\n                            }\n                            throwMultiError(errors);\n                        }\n                        return concatArrays(resolved);\n                    });\n                });\n            }\n        },\n        {\n            key: \"reorderModules\",\n            value: function reorderModules() {\n                /**\n       * Modules will be sorted according to priority.\n       *\n       * Input example:\n       * [\n       *   { priority: 1, name: \"FooMod\" },\n       *   { priority: -1, name: \"XMod\" },\n       *   { priority: 4, name: \"OtherMod\" }\n       * ]\n       *\n       * Output example (sorted by priority in descending order):\n       * [\n       *   { priority: 4, name: \"OtherMod\" },\n       *   { priority: 1, name: \"FooMod\" },\n       *   { priority: -1, name: \"XMod\" }\n       * ]\n       * Tested in #test-reorder-modules\n       */ this.modules = stableSort(this.modules, function(m1, m2) {\n                    return (m2.priority || 0) - (m1.priority || 0);\n                });\n            }\n        },\n        {\n            key: \"throwIfDuplicateModules\",\n            value: function throwIfDuplicateModules() {\n                var duplicates = getDuplicates(this.modules.map(function(_ref2) {\n                    var name = _ref2.name;\n                    return name;\n                }));\n                if (duplicates.length > 0) {\n                    throw new XTInternalError('Detected duplicate module \"'.concat(duplicates[0], '\"'));\n                }\n            }\n        },\n        {\n            key: \"compile\",\n            value: function compile() {\n                var _this2 = this;\n                deprecatedMethod(this, \"compile\");\n                this.updateFileTypeConfig();\n                this.throwIfDuplicateModules();\n                this.reorderModules();\n                if (Object.keys(this.compiled).length) {\n                    return this;\n                }\n                this.options = this.modules.reduce(function(options, module1) {\n                    return module1.optionsTransformer(options, _this2);\n                }, this.options);\n                this.options.xmlFileNames = uniq(this.options.xmlFileNames);\n                for(var _i16 = 0, _this$options$xmlFile2 = this.options.xmlFileNames; _i16 < _this$options$xmlFile2.length; _i16++){\n                    var fileName = _this$options$xmlFile2[_i16];\n                    var content = this.zip.files[fileName].asText();\n                    this.xmlDocuments[fileName] = str2xml(content);\n                }\n                this.setModules({\n                    zip: this.zip,\n                    xmlDocuments: this.xmlDocuments\n                });\n                this.getTemplatedFiles();\n                /*\n       * Loop inside all templatedFiles (ie xml files with content).\n       * Sometimes they don't exist (footer.xml for example)\n       */ this.sendEvent(\"before-preparse\");\n                for(var _i18 = 0, _this$templatedFiles2 = this.templatedFiles; _i18 < _this$templatedFiles2.length; _i18++){\n                    var _fileName = _this$templatedFiles2[_i18];\n                    if (this.zip.files[_fileName] != null) {\n                        this.precompileFile(_fileName);\n                    }\n                }\n                this.sendEvent(\"after-preparse\");\n                for(var _i20 = 0, _this$templatedFiles4 = this.templatedFiles; _i20 < _this$templatedFiles4.length; _i20++){\n                    var _fileName2 = _this$templatedFiles4[_i20];\n                    if (this.zip.files[_fileName2] != null) {\n                        this.compiled[_fileName2].parse({\n                            noPostParse: true\n                        });\n                    }\n                }\n                this.sendEvent(\"after-parse\");\n                for(var _i22 = 0, _this$templatedFiles6 = this.templatedFiles; _i22 < _this$templatedFiles6.length; _i22++){\n                    var _fileName3 = _this$templatedFiles6[_i22];\n                    if (this.zip.files[_fileName3] != null) {\n                        this.compiled[_fileName3].postparse();\n                    }\n                }\n                this.sendEvent(\"after-postparse\");\n                this.setModules({\n                    compiled: this.compiled\n                });\n                verifyErrors(this);\n                return this;\n            }\n        },\n        {\n            key: \"getRelsTypes\",\n            value: function getRelsTypes() {\n                var rootRels = this.zip.files[relsFile];\n                var rootRelsXml = rootRels ? str2xml(rootRels.asText()) : null;\n                var rootRelationships = rootRelsXml ? rootRelsXml.getElementsByTagName(\"Relationship\") : [];\n                var relsTypes = {};\n                for(var _i24 = 0; _i24 < rootRelationships.length; _i24++){\n                    var relation = rootRelationships[_i24];\n                    relsTypes[relation.getAttribute(\"Target\")] = relation.getAttribute(\"Type\");\n                }\n                return relsTypes;\n            }\n        },\n        {\n            key: \"getContentTypes\",\n            value: function getContentTypes() {\n                var contentTypes = this.zip.files[ctXML];\n                var contentTypeXml = contentTypes ? str2xml(contentTypes.asText()) : null;\n                var overrides = contentTypeXml ? contentTypeXml.getElementsByTagName(\"Override\") : null;\n                var defaults = contentTypeXml ? contentTypeXml.getElementsByTagName(\"Default\") : null;\n                return {\n                    overrides: overrides,\n                    defaults: defaults,\n                    contentTypes: contentTypes,\n                    contentTypeXml: contentTypeXml\n                };\n            }\n        },\n        {\n            key: \"updateFileTypeConfig\",\n            value: function updateFileTypeConfig() {\n                this.relsTypes = this.getRelsTypes();\n                var _this$getContentTypes = this.getContentTypes(), overrides = _this$getContentTypes.overrides, defaults = _this$getContentTypes.defaults, contentTypes = _this$getContentTypes.contentTypes, contentTypeXml = _this$getContentTypes.contentTypeXml;\n                if (contentTypeXml) {\n                    this.filesContentTypes = collectContentTypes(overrides, defaults, this.zip);\n                    this.invertedContentTypes = DocUtils.invertMap(this.filesContentTypes);\n                    this.setModules({\n                        contentTypes: this.contentTypes,\n                        invertedContentTypes: this.invertedContentTypes\n                    });\n                }\n                var fileType;\n                if (this.zip.files.mimetype) {\n                    fileType = \"odt\";\n                }\n                for(var _i26 = 0, _this$modules8 = this.modules; _i26 < _this$modules8.length; _i26++){\n                    var _module5 = _this$modules8[_i26];\n                    fileType = _module5.getFileType({\n                        zip: this.zip,\n                        contentTypes: contentTypes,\n                        contentTypeXml: contentTypeXml,\n                        overrides: overrides,\n                        defaults: defaults,\n                        doc: this\n                    }) || fileType;\n                }\n                if (fileType === \"odt\") {\n                    throwFileTypeNotHandled(fileType);\n                }\n                if (!fileType) {\n                    throwFileTypeNotIdentified(this.zip);\n                }\n                for(var _i28 = 0, _this$modules10 = this.modules; _i28 < _this$modules10.length; _i28++){\n                    var _module6 = _this$modules10[_i28];\n                    for(var _i30 = 0, _ref4 = _module6.xmlContentTypes || []; _i30 < _ref4.length; _i30++){\n                        var contentType = _ref4[_i30];\n                        pushArray(this.options.xmlFileNames, this.invertedContentTypes[contentType] || []);\n                    }\n                }\n                this.fileType = fileType;\n                dropUnsupportedFileTypesModules(this);\n                this.fileTypeConfig = this.options.fileTypeConfig || this.fileTypeConfig;\n                if (!this.fileTypeConfig) {\n                    if (Docxtemplater.FileTypeConfig[this.fileType]) {\n                        this.fileTypeConfig = Docxtemplater.FileTypeConfig[this.fileType]();\n                    } else {\n                        /*\n           * Error case handled since v3.60.2\n           * Throw specific error when trying to template xlsx file without xlsxmodule\n           */ var message = 'Filetype \"'.concat(this.fileType, '\" is not supported');\n                        var id = \"filetype_not_supported\";\n                        if (this.fileType === \"xlsx\") {\n                            message = 'Filetype \"'.concat(this.fileType, '\" is supported only with the paid XlsxModule');\n                            id = \"xlsx_filetype_needs_xlsx_module\";\n                        }\n                        var err = new XTTemplateError(message);\n                        err.properties = {\n                            id: id,\n                            explanation: message\n                        };\n                        throw err;\n                    }\n                }\n                return this;\n            }\n        },\n        {\n            key: \"renderAsync\",\n            value: function renderAsync(data) {\n                var _this3 = this;\n                this.hideDeprecations = true;\n                var promise = this.resolveData(data);\n                this.hideDeprecations = false;\n                return promise.then(function() {\n                    return _this3.render();\n                });\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(data) {\n                if (this.rendered) {\n                    throwRenderTwice();\n                }\n                this.rendered = true;\n                if (Object.keys(this.compiled).length === 0) {\n                    this.compile();\n                }\n                if (this.errors.length > 0) {\n                    throwRenderInvalidTemplate();\n                }\n                if (arguments.length > 0) {\n                    this.data = data;\n                }\n                this.setModules({\n                    data: this.data,\n                    Lexer: Lexer\n                });\n                this.mapper || (this.mapper = this.modules.reduce(function(value, module1) {\n                    return module1.getRenderedMap(value);\n                }, {}));\n                var output = [];\n                for(var to in this.mapper){\n                    var _this$mapper$to2 = this.mapper[to], from = _this$mapper$to2.from, _data = _this$mapper$to2.data;\n                    var currentFile = this.compiled[from];\n                    currentFile.scopeManager = this.getScopeManager(to, currentFile, _data);\n                    currentFile.render(to);\n                    output.push([\n                        to,\n                        currentFile.content,\n                        currentFile\n                    ]);\n                    delete currentFile.content;\n                }\n                for(var _i32 = 0; _i32 < output.length; _i32++){\n                    var outputPart = output[_i32];\n                    var _outputPart = _slicedToArray(outputPart, 3), content = _outputPart[1], _currentFile = _outputPart[2];\n                    for(var _i34 = 0, _this$modules12 = this.modules; _i34 < _this$modules12.length; _i34++){\n                        var _module7 = _this$modules12[_i34];\n                        if (_module7.preZip) {\n                            var result = _module7.preZip(content, _currentFile);\n                            if (typeof result === \"string\") {\n                                outputPart[1] = result;\n                            }\n                        }\n                    }\n                }\n                for(var _i36 = 0; _i36 < output.length; _i36++){\n                    var _output$_i = _slicedToArray(output[_i36], 2), _to = _output$_i[0], _content = _output$_i[1];\n                    this.zip.file(_to, _content, {\n                        createFolders: true\n                    });\n                }\n                verifyErrors(this);\n                this.sendEvent(\"syncing-zip\");\n                this.syncZip();\n                // The synced-zip event is used in the subtemplate module for example\n                this.sendEvent(\"synced-zip\");\n                return this;\n            }\n        },\n        {\n            key: \"syncZip\",\n            value: function syncZip() {\n                for(var fileName in this.xmlDocuments){\n                    this.zip.remove(fileName);\n                    var content = xml2str(this.xmlDocuments[fileName]);\n                    this.zip.file(fileName, content, {\n                        createFolders: true\n                    });\n                }\n            }\n        },\n        {\n            key: \"setData\",\n            value: function setData(data) {\n                deprecatedMethod(this, \"setData\");\n                this.data = data;\n                return this;\n            }\n        },\n        {\n            key: \"getZip\",\n            value: function getZip() {\n                return this.zip;\n            }\n        },\n        {\n            key: \"createTemplateClass\",\n            value: function createTemplateClass(path) {\n                var content = this.zip.files[path].asText();\n                return this.createTemplateClassFromContent(content, path);\n            }\n        },\n        {\n            key: \"createTemplateClassFromContent\",\n            value: function createTemplateClassFromContent(content, filePath) {\n                var xmltOptions = {\n                    filePath: filePath,\n                    contentType: this.filesContentTypes[filePath],\n                    relsType: this.relsTypes[filePath]\n                };\n                var defaults = getDefaults();\n                var defaultKeys = pushArray(Object.keys(defaults), [\n                    \"filesContentTypes\",\n                    \"fileTypeConfig\",\n                    \"fileType\",\n                    \"modules\"\n                ]);\n                for(var _i38 = 0; _i38 < defaultKeys.length; _i38++){\n                    var key = defaultKeys[_i38];\n                    xmltOptions[key] = this[key];\n                }\n                return new Docxtemplater.XmlTemplater(content, xmltOptions);\n            }\n        },\n        {\n            key: \"getFullText\",\n            value: function getFullText(path) {\n                return this.createTemplateClass(path || this.fileTypeConfig.textPath(this)).getFullText();\n            }\n        },\n        {\n            key: \"getTemplatedFiles\",\n            value: function getTemplatedFiles() {\n                this.templatedFiles = this.fileTypeConfig.getTemplatedFiles(this.zip);\n                pushArray(this.templatedFiles, this.targets);\n                this.templatedFiles = uniq(this.templatedFiles);\n                return this.templatedFiles;\n            }\n        },\n        {\n            key: \"getTags\",\n            value: function getTags() {\n                var result = {\n                    headers: [],\n                    footers: []\n                };\n                for(var key in this.compiled){\n                    var contentType = this.filesContentTypes[key];\n                    if (contentType === \"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml\") {\n                        result.document = {\n                            target: key,\n                            tags: _getTags(this.compiled[key].postparsed)\n                        };\n                    }\n                    if (contentType === \"application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml\") {\n                        result.headers.push({\n                            target: key,\n                            tags: _getTags(this.compiled[key].postparsed)\n                        });\n                    }\n                    if (contentType === \"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml\") {\n                        result.footers.push({\n                            target: key,\n                            tags: _getTags(this.compiled[key].postparsed)\n                        });\n                    }\n                }\n                return result;\n            }\n        },\n        {\n            key: \"toBuffer\",\n            value: function toBuffer(options) {\n                return this.getZip().generate(_objectSpread(_objectSpread({\n                    compression: \"DEFLATE\",\n                    fileOrder: zipFileOrder\n                }, options), {}, {\n                    type: \"nodebuffer\"\n                }));\n            }\n        },\n        {\n            key: \"toBlob\",\n            value: function toBlob(options) {\n                return this.getZip().generate(_objectSpread(_objectSpread({\n                    compression: \"DEFLATE\",\n                    fileOrder: zipFileOrder\n                }, options), {}, {\n                    type: \"blob\"\n                }));\n            }\n        },\n        {\n            key: \"toBase64\",\n            value: function toBase64(options) {\n                return this.getZip().generate(_objectSpread(_objectSpread({\n                    compression: \"DEFLATE\",\n                    fileOrder: zipFileOrder\n                }, options), {}, {\n                    type: \"base64\"\n                }));\n            }\n        },\n        {\n            key: \"toUint8Array\",\n            value: function toUint8Array(options) {\n                return this.getZip().generate(_objectSpread(_objectSpread({\n                    compression: \"DEFLATE\",\n                    fileOrder: zipFileOrder\n                }, options), {}, {\n                    type: \"uint8array\"\n                }));\n            }\n        },\n        {\n            key: \"toArrayBuffer\",\n            value: function toArrayBuffer(options) {\n                return this.getZip().generate(_objectSpread(_objectSpread({\n                    compression: \"DEFLATE\",\n                    fileOrder: zipFileOrder\n                }, options), {}, {\n                    type: \"arraybuffer\"\n                }));\n            }\n        }\n    ]);\n}();\nDocxtemplater.DocUtils = DocUtils;\nDocxtemplater.Errors = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\");\nDocxtemplater.XmlTemplater = __webpack_require__(/*! ./xml-templater.js */ \"(rsc)/./node_modules/docxtemplater/js/xml-templater.js\");\nDocxtemplater.FileTypeConfig = __webpack_require__(/*! ./file-type-config.js */ \"(rsc)/./node_modules/docxtemplater/js/file-type-config.js\");\nDocxtemplater.XmlMatcher = __webpack_require__(/*! ./xml-matcher.js */ \"(rsc)/./node_modules/docxtemplater/js/xml-matcher.js\");\nmodule.exports = Docxtemplater;\nmodule.exports[\"default\"] = Docxtemplater;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9kb2N4dGVtcGxhdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsWUFBWTtJQUFDO0NBQVU7QUFDM0IsU0FBU0MsUUFBUUMsQ0FBQyxFQUFFQyxDQUFDO0lBQUksSUFBSUMsSUFBSUMsT0FBT0MsSUFBSSxDQUFDSjtJQUFJLElBQUlHLE9BQU9FLHFCQUFxQixFQUFFO1FBQUUsSUFBSUMsSUFBSUgsT0FBT0UscUJBQXFCLENBQUNMO1FBQUlDLEtBQU1LLENBQUFBLElBQUlBLEVBQUVDLE1BQU0sQ0FBQyxTQUFVTixDQUFDO1lBQUksT0FBT0UsT0FBT0ssd0JBQXdCLENBQUNSLEdBQUdDLEdBQUdRLFVBQVU7UUFBRSxFQUFDLEdBQUlQLEVBQUVRLElBQUksQ0FBQ0MsS0FBSyxDQUFDVCxHQUFHSTtJQUFJO0lBQUUsT0FBT0o7QUFBRztBQUM5UCxTQUFTVSxjQUFjWixDQUFDO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlZLFVBQVVDLE1BQU0sRUFBRWIsSUFBSztRQUFFLElBQUlDLElBQUksUUFBUVcsU0FBUyxDQUFDWixFQUFFLEdBQUdZLFNBQVMsQ0FBQ1osRUFBRSxHQUFHLENBQUM7UUFBR0EsSUFBSSxJQUFJRixRQUFRSSxPQUFPRCxJQUFJLENBQUMsR0FBR2EsT0FBTyxDQUFDLFNBQVVkLENBQUM7WUFBSWUsZ0JBQWdCaEIsR0FBR0MsR0FBR0MsQ0FBQyxDQUFDRCxFQUFFO1FBQUcsS0FBS0UsT0FBT2MseUJBQXlCLEdBQUdkLE9BQU9lLGdCQUFnQixDQUFDbEIsR0FBR0csT0FBT2MseUJBQXlCLENBQUNmLE1BQU1ILFFBQVFJLE9BQU9ELElBQUlhLE9BQU8sQ0FBQyxTQUFVZCxDQUFDO1lBQUlFLE9BQU9nQixjQUFjLENBQUNuQixHQUFHQyxHQUFHRSxPQUFPSyx3QkFBd0IsQ0FBQ04sR0FBR0Q7UUFBSztJQUFJO0lBQUUsT0FBT0Q7QUFBRztBQUN0YixTQUFTZ0Is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TTtnQkFDUjtZQUNGO1FBQ0Y7S0FBRTtBQUNKO0FBQ0E1TCxjQUFjdkUsUUFBUSxHQUFHQTtBQUN6QnVFLGNBQWNpTSxNQUFNLEdBQUd2USxtQkFBT0EsQ0FBQyxvRUFBYTtBQUM1Q3NFLGNBQWNnTCxZQUFZLEdBQUd0UCxtQkFBT0EsQ0FBQyxrRkFBb0I7QUFDekRzRSxjQUFjOEksY0FBYyxHQUFHcE4sbUJBQU9BLENBQUMsd0ZBQXVCO0FBQzlEc0UsY0FBY2tNLFVBQVUsR0FBR3hRLG1CQUFPQSxDQUFDLDhFQUFrQjtBQUNyRHlELE9BQU9nTixPQUFPLEdBQUduTTtBQUNqQmIseUJBQXlCLEdBQUdhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlrZS1yZW50YWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2RvY3h0ZW1wbGF0ZXIuanM/MjBlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9leGNsdWRlZCA9IFtcIm1vZHVsZXNcIl07XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkociwgZSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpOyB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpOyByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHZvaWQgMDsgfSB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhyKSB7IGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gcjsgfVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGUsIHQpIHsgaWYgKG51bGwgPT0gZSkgcmV0dXJuIHt9OyB2YXIgbywgciwgaSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKGUsIHQpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IGZvciAociA9IDA7IHIgPCBuLmxlbmd0aDsgcisrKSBvID0gbltyXSwgLTEgPT09IHQuaW5kZXhPZihvKSAmJiB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsIG8pICYmIChpW29dID0gZVtvXSk7IH0gcmV0dXJuIGk7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHIsIGUpIHsgaWYgKG51bGwgPT0gcikgcmV0dXJuIHt9OyB2YXIgdCA9IHt9OyBmb3IgKHZhciBuIGluIHIpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsIG4pKSB7IGlmICgtMSAhPT0gZS5pbmRleE9mKG4pKSBjb250aW51ZTsgdFtuXSA9IHJbbl07IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciBEb2NVdGlscyA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKTtcbkRvY1V0aWxzLnRyYWl0cyA9IHJlcXVpcmUoXCIuL3RyYWl0cy5qc1wiKTtcbkRvY1V0aWxzLm1vZHVsZVdyYXBwZXIgPSByZXF1aXJlKFwiLi9tb2R1bGUtd3JhcHBlci5qc1wiKTtcbnZhciBjb21tb25Nb2R1bGUgPSByZXF1aXJlKFwiLi9tb2R1bGVzL2NvbW1vbi5qc1wiKTtcbnZhciBjcmVhdGVTY29wZSA9IHJlcXVpcmUoXCIuL3Njb3BlLW1hbmFnZXIuanNcIik7XG52YXIgTGV4ZXIgPSByZXF1aXJlKFwiLi9sZXhlci5qc1wiKTtcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2dldC10YWdzLmpzXCIpLFxuICBfZ2V0VGFncyA9IF9yZXF1aXJlLmdldFRhZ3M7XG52YXIgbG9nRXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3ItbG9nZ2VyLmpzXCIpO1xudmFyIGNvbGxlY3RDb250ZW50VHlwZXMgPSByZXF1aXJlKFwiLi9jb2xsZWN0LWNvbnRlbnQtdHlwZXMuanNcIik7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpLFxuICB0aHJvd011bHRpRXJyb3IgPSBfcmVxdWlyZTIudGhyb3dNdWx0aUVycm9yLFxuICB0aHJvd1Jlc29sdmVCZWZvcmVDb21waWxlID0gX3JlcXVpcmUyLnRocm93UmVzb2x2ZUJlZm9yZUNvbXBpbGUsXG4gIHRocm93UmVuZGVySW52YWxpZFRlbXBsYXRlID0gX3JlcXVpcmUyLnRocm93UmVuZGVySW52YWxpZFRlbXBsYXRlLFxuICB0aHJvd1JlbmRlclR3aWNlID0gX3JlcXVpcmUyLnRocm93UmVuZGVyVHdpY2UsXG4gIFhUSW50ZXJuYWxFcnJvciA9IF9yZXF1aXJlMi5YVEludGVybmFsRXJyb3IsXG4gIFhUVGVtcGxhdGVFcnJvciA9IF9yZXF1aXJlMi5YVFRlbXBsYXRlRXJyb3IsXG4gIHRocm93RmlsZVR5cGVOb3RJZGVudGlmaWVkID0gX3JlcXVpcmUyLnRocm93RmlsZVR5cGVOb3RJZGVudGlmaWVkLFxuICB0aHJvd0ZpbGVUeXBlTm90SGFuZGxlZCA9IF9yZXF1aXJlMi50aHJvd0ZpbGVUeXBlTm90SGFuZGxlZCxcbiAgdGhyb3dBcGlWZXJzaW9uRXJyb3IgPSBfcmVxdWlyZTIudGhyb3dBcGlWZXJzaW9uRXJyb3I7XG52YXIgZ2V0RGVmYXVsdHMgPSBEb2NVdGlscy5nZXREZWZhdWx0cyxcbiAgc3RyMnhtbCA9IERvY1V0aWxzLnN0cjJ4bWwsXG4gIHhtbDJzdHIgPSBEb2NVdGlscy54bWwyc3RyLFxuICBtb2R1bGVXcmFwcGVyID0gRG9jVXRpbHMubW9kdWxlV3JhcHBlcixcbiAgY29uY2F0QXJyYXlzID0gRG9jVXRpbHMuY29uY2F0QXJyYXlzLFxuICB1bmlxID0gRG9jVXRpbHMudW5pcSxcbiAgZ2V0RHVwbGljYXRlcyA9IERvY1V0aWxzLmdldER1cGxpY2F0ZXMsXG4gIHN0YWJsZVNvcnQgPSBEb2NVdGlscy5zdGFibGVTb3J0LFxuICBwdXNoQXJyYXkgPSBEb2NVdGlscy5wdXNoQXJyYXk7XG52YXIgY3RYTUwgPSBcIltDb250ZW50X1R5cGVzXS54bWxcIjtcbnZhciByZWxzRmlsZSA9IFwiX3JlbHMvLnJlbHNcIjtcbnZhciBjdXJyZW50TW9kdWxlQXBpVmVyc2lvbiA9IFszLCA0NiwgMF07XG5mdW5jdGlvbiB6aXBGaWxlT3JkZXIoZmlsZXMpIHtcbiAgdmFyIGFsbEZpbGVzID0gW107XG4gIGZvciAodmFyIG5hbWUgaW4gZmlsZXMpIHtcbiAgICBhbGxGaWxlcy5wdXNoKG5hbWUpO1xuICB9XG4gIC8qXG4gICAqIFRoZSBmaXJzdCBmaWxlcyB0aGF0IG5lZWQgdG8gYmUgcHV0IGluIHRoZSB6aXAgZmlsZSBhcmUgOlxuICAgKiBbQ29udGVudF9UeXBlc10ueG1sIGFuZCBfcmVscy8ucmVsc1xuICAgKi9cbiAgdmFyIHJlc3VsdEZpbGVzID0gW2N0WE1MLCByZWxzRmlsZV07XG5cbiAgLypcbiAgICogVGhlIG5leHQgZmlsZXMgdGhhdCBzaG91bGQgYmUgaW4gdGhlIHppcCBmaWxlIGFyZSA6XG4gICAqXG4gICAqIC0gd29yZC8qIChpZSB3b3JkL2RvY3VtZW50LnhtbCwgd29yZC9oZWFkZXIxLnhtbCwgLi4uKVxuICAgKiAtIHhsLyogKGllIHhsL3dvcmtzaGVldHMvc2hlZXQxLnhtbClcbiAgICogLSBwcHQvKiAoaWUgcHB0L3NsaWRlcy9zbGlkZTEueG1sKVxuICAgKi9cbiAgdmFyIHByZWZpeGVzID0gW1wid29yZC9cIiwgXCJ4bC9cIiwgXCJwcHQvXCJdO1xuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBhbGxGaWxlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9uYW1lID0gYWxsRmlsZXNbX2kyXTtcbiAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBwcmVmaXhlcy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbX2k0XTtcbiAgICAgIGlmIChfbmFtZS5pbmRleE9mKFwiXCIuY29uY2F0KHByZWZpeCkpID09PSAwKSB7XG4gICAgICAgIHJlc3VsdEZpbGVzLnB1c2goX25hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKlxuICAgKiBQdXNoIHRoZSByZXN0IG9mIGZpbGVzLCBzdWNoIGFzIGRvY1Byb3BzL2NvcmUueG1sIGFuZCBkb2NQcm9wcy9hcHAueG1sXG4gICAqL1xuICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBhbGxGaWxlcy5sZW5ndGg7IF9pNisrKSB7XG4gICAgdmFyIF9uYW1lMiA9IGFsbEZpbGVzW19pNl07XG4gICAgaWYgKHJlc3VsdEZpbGVzLmluZGV4T2YoX25hbWUyKSA9PT0gLTEpIHtcbiAgICAgIHJlc3VsdEZpbGVzLnB1c2goX25hbWUyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdEZpbGVzO1xufVxuZnVuY3Rpb24gZGVwcmVjYXRlZE1lc3NhZ2Uob2JqLCBtZXNzYWdlKSB7XG4gIGlmIChvYmouaGlkZURlcHJlY2F0aW9ucyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG59XG5mdW5jdGlvbiBkZXByZWNhdGVkTWV0aG9kKG9iaiwgbWV0aG9kKSB7XG4gIGlmIChvYmouaGlkZURlcHJlY2F0aW9ucyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gZGVwcmVjYXRlZE1lc3NhZ2Uob2JqLCBcIkRlcHJlY2F0ZWQgbWV0aG9kIFxcXCIuXCIuY29uY2F0KG1ldGhvZCwgXCJcXFwiLCB2aWV3IHVwZ3JhZGUgZ3VpZGUgOiBodHRwczovL2RvY3h0ZW1wbGF0ZXIuY29tL2RvY3MvYXBpLyN1cGdyYWRlLWd1aWRlLCBzdGFjayA6IFwiKS5jb25jYXQobmV3IEVycm9yKCkuc3RhY2spKTtcbn1cbmZ1bmN0aW9uIGRyb3BVbnN1cHBvcnRlZEZpbGVUeXBlc01vZHVsZXMoZG9jKSB7XG4gIGRvYy5tb2R1bGVzID0gZG9jLm1vZHVsZXMuZmlsdGVyKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICBpZiAoIW1vZHVsZS5zdXBwb3J0ZWRGaWxlVHlwZXMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobW9kdWxlLnN1cHBvcnRlZEZpbGVUeXBlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdXBwb3J0ZWRGaWxlVHlwZXMgZmllbGQgb2YgdGhlIG1vZHVsZSBtdXN0IGJlIGFuIGFycmF5XCIpO1xuICAgIH1cbiAgICB2YXIgaXNTdXBwb3J0ZWRNb2R1bGUgPSBtb2R1bGUuc3VwcG9ydGVkRmlsZVR5cGVzLmluY2x1ZGVzKGRvYy5maWxlVHlwZSk7XG4gICAgaWYgKCFpc1N1cHBvcnRlZE1vZHVsZSkge1xuICAgICAgbW9kdWxlLm9uKFwiZGV0YWNoZWRcIik7XG4gICAgfVxuICAgIHJldHVybiBpc1N1cHBvcnRlZE1vZHVsZTtcbiAgfSk7XG59XG5mdW5jdGlvbiB2ZXJpZnlFcnJvcnMoZG9jKSB7XG4gIHZhciBjb21waWxlZCA9IGRvYy5jb21waWxlZDtcbiAgZG9jLmVycm9ycyA9IGNvbmNhdEFycmF5cyhPYmplY3Qua2V5cyhjb21waWxlZCkubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIGNvbXBpbGVkW25hbWVdLmFsbEVycm9ycztcbiAgfSkpO1xuICBpZiAoZG9jLmVycm9ycy5sZW5ndGggIT09IDApIHtcbiAgICBpZiAoZG9jLm9wdGlvbnMuZXJyb3JMb2dnaW5nKSB7XG4gICAgICBsb2dFcnJvcnMoZG9jLmVycm9ycywgZG9jLm9wdGlvbnMuZXJyb3JMb2dnaW5nKTtcbiAgICB9XG4gICAgdGhyb3dNdWx0aUVycm9yKGRvYy5lcnJvcnMpO1xuICB9XG59XG52YXIgRG9jeHRlbXBsYXRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERvY3h0ZW1wbGF0ZXIoemlwKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgX3JlZiRtb2R1bGVzID0gX3JlZi5tb2R1bGVzLFxuICAgICAgbW9kdWxlcyA9IF9yZWYkbW9kdWxlcyA9PT0gdm9pZCAwID8gW10gOiBfcmVmJG1vZHVsZXMsXG4gICAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERvY3h0ZW1wbGF0ZXIpO1xuICAgIHRoaXMudGFyZ2V0cyA9IFtdO1xuICAgIHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNjb3BlTWFuYWdlcnMgPSB7fTtcbiAgICB0aGlzLmNvbXBpbGVkID0ge307XG4gICAgdGhpcy5tb2R1bGVzID0gW2NvbW1vbk1vZHVsZSgpXTtcbiAgICB0aGlzLnhtbERvY3VtZW50cyA9IHt9O1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBkZXByZWNhdGVkTWVzc2FnZSh0aGlzLCBcIkRlcHJlY2F0ZWQgZG9jeHRlbXBsYXRlciBjb25zdHJ1Y3RvciB3aXRoIG5vIGFyZ3VtZW50cywgdmlldyB1cGdyYWRlIGd1aWRlIDogaHR0cHM6Ly9kb2N4dGVtcGxhdGVyLmNvbS9kb2NzL2FwaS8jdXBncmFkZS1ndWlkZSwgc3RhY2sgOiBcIi5jb25jYXQobmV3IEVycm9yKCkuc3RhY2spKTtcbiAgICAgIHRoaXMuaGlkZURlcHJlY2F0aW9ucyA9IHRydWU7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZURlcHJlY2F0aW9ucyA9IHRydWU7XG4gICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICBpZiAoIXppcCB8fCAhemlwLmZpbGVzIHx8IHR5cGVvZiB6aXAuZmlsZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCBvZiBkb2N4dGVtcGxhdGVyJ3MgY29uc3RydWN0b3IgbXVzdCBiZSBhIHZhbGlkIHppcCBmaWxlIChqc3ppcCB2MiBvciBwaXp6aXAgdjMpXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1vZHVsZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBtb2R1bGVzIGFyZ3VtZW50IG9mIGRvY3h0ZW1wbGF0ZXIncyBjb25zdHJ1Y3RvciBtdXN0IGJlIGFuIGFycmF5XCIpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgbW9kdWxlcy5sZW5ndGg7IF9pOCsrKSB7XG4gICAgICAgIHZhciBfbW9kdWxlID0gbW9kdWxlc1tfaThdO1xuICAgICAgICB0aGlzLmF0dGFjaE1vZHVsZShfbW9kdWxlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9hZFppcCh6aXApO1xuICAgICAgdGhpcy5jb21waWxlKCk7XG4gICAgICB0aGlzLnY0Q29uc3RydWN0b3IgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmhpZGVEZXByZWNhdGlvbnMgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKERvY3h0ZW1wbGF0ZXIsIFt7XG4gICAga2V5OiBcInZlcmlmeUFwaVZlcnNpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmVyaWZ5QXBpVmVyc2lvbihuZWVkZWRWZXJzaW9uKSB7XG4gICAgICBuZWVkZWRWZXJzaW9uID0gbmVlZGVkVmVyc2lvbi5zcGxpdChcIi5cIikubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChpLCAxMCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChuZWVkZWRWZXJzaW9uLmxlbmd0aCAhPT0gMykge1xuICAgICAgICB0aHJvd0FwaVZlcnNpb25FcnJvcihcIm5lZWRlZFZlcnNpb24gaXMgbm90IGEgdmFsaWQgdmVyc2lvblwiLCB7XG4gICAgICAgICAgbmVlZGVkVmVyc2lvbjogbmVlZGVkVmVyc2lvbixcbiAgICAgICAgICBleHBsYW5hdGlvbjogXCJ0aGUgbmVlZGVkVmVyc2lvbiBtdXN0IGJlIGFuIGFycmF5IG9mIGxlbmd0aCAzXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAobmVlZGVkVmVyc2lvblswXSAhPT0gY3VycmVudE1vZHVsZUFwaVZlcnNpb25bMF0pIHtcbiAgICAgICAgdGhyb3dBcGlWZXJzaW9uRXJyb3IoXCJUaGUgbWFqb3IgYXBpIHZlcnNpb24gZG8gbm90IG1hdGNoLCB5b3UgcHJvYmFibHkgaGF2ZSB0byB1cGRhdGUgZG9jeHRlbXBsYXRlciB3aXRoIG5wbSBpbnN0YWxsIC0tc2F2ZSBkb2N4dGVtcGxhdGVyXCIsIHtcbiAgICAgICAgICBuZWVkZWRWZXJzaW9uOiBuZWVkZWRWZXJzaW9uLFxuICAgICAgICAgIGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uOiBjdXJyZW50TW9kdWxlQXBpVmVyc2lvbixcbiAgICAgICAgICBleHBsYW5hdGlvbjogXCJtb2R1bGVBUElWZXJzaW9uTWlzbWF0Y2ggOiBuZWVkZWQ9XCIuY29uY2F0KG5lZWRlZFZlcnNpb24uam9pbihcIi5cIiksIFwiLCBjdXJyZW50PVwiKS5jb25jYXQoY3VycmVudE1vZHVsZUFwaVZlcnNpb24uam9pbihcIi5cIikpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRlZFZlcnNpb25bMV0gPiBjdXJyZW50TW9kdWxlQXBpVmVyc2lvblsxXSkge1xuICAgICAgICB0aHJvd0FwaVZlcnNpb25FcnJvcihcIlRoZSBtaW5vciBhcGkgdmVyc2lvbiBpcyBub3QgdXB0b2RhdGUsIHlvdSBwcm9iYWJseSBoYXZlIHRvIHVwZGF0ZSBkb2N4dGVtcGxhdGVyIHdpdGggbnBtIGluc3RhbGwgLS1zYXZlIGRvY3h0ZW1wbGF0ZXJcIiwge1xuICAgICAgICAgIG5lZWRlZFZlcnNpb246IG5lZWRlZFZlcnNpb24sXG4gICAgICAgICAgY3VycmVudE1vZHVsZUFwaVZlcnNpb246IGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uLFxuICAgICAgICAgIGV4cGxhbmF0aW9uOiBcIm1vZHVsZUFQSVZlcnNpb25NaXNtYXRjaCA6IG5lZWRlZD1cIi5jb25jYXQobmVlZGVkVmVyc2lvbi5qb2luKFwiLlwiKSwgXCIsIGN1cnJlbnQ9XCIpLmNvbmNhdChjdXJyZW50TW9kdWxlQXBpVmVyc2lvbi5qb2luKFwiLlwiKSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAobmVlZGVkVmVyc2lvblsxXSA9PT0gY3VycmVudE1vZHVsZUFwaVZlcnNpb25bMV0gJiYgbmVlZGVkVmVyc2lvblsyXSA+IGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uWzJdKSB7XG4gICAgICAgIHRocm93QXBpVmVyc2lvbkVycm9yKFwiVGhlIHBhdGNoIGFwaSB2ZXJzaW9uIGlzIG5vdCB1cHRvZGF0ZSwgeW91IHByb2JhYmx5IGhhdmUgdG8gdXBkYXRlIGRvY3h0ZW1wbGF0ZXIgd2l0aCBucG0gaW5zdGFsbCAtLXNhdmUgZG9jeHRlbXBsYXRlclwiLCB7XG4gICAgICAgICAgbmVlZGVkVmVyc2lvbjogbmVlZGVkVmVyc2lvbixcbiAgICAgICAgICBjdXJyZW50TW9kdWxlQXBpVmVyc2lvbjogY3VycmVudE1vZHVsZUFwaVZlcnNpb24sXG4gICAgICAgICAgZXhwbGFuYXRpb246IFwibW9kdWxlQVBJVmVyc2lvbk1pc21hdGNoIDogbmVlZGVkPVwiLmNvbmNhdChuZWVkZWRWZXJzaW9uLmpvaW4oXCIuXCIpLCBcIiwgY3VycmVudD1cIikuY29uY2F0KGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uLmpvaW4oXCIuXCIpKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRNb2R1bGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1vZHVsZXMob2JqKSB7XG4gICAgICBmb3IgKHZhciBfaTEwID0gMCwgX3RoaXMkbW9kdWxlczIgPSB0aGlzLm1vZHVsZXM7IF9pMTAgPCBfdGhpcyRtb2R1bGVzMi5sZW5ndGg7IF9pMTArKykge1xuICAgICAgICB2YXIgX21vZHVsZTIgPSBfdGhpcyRtb2R1bGVzMltfaTEwXTtcbiAgICAgICAgX21vZHVsZTIuc2V0KG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlbmRFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kRXZlbnQoZXZlbnROYW1lKSB7XG4gICAgICBmb3IgKHZhciBfaTEyID0gMCwgX3RoaXMkbW9kdWxlczQgPSB0aGlzLm1vZHVsZXM7IF9pMTIgPCBfdGhpcyRtb2R1bGVzNC5sZW5ndGg7IF9pMTIrKykge1xuICAgICAgICB2YXIgX21vZHVsZTMgPSBfdGhpcyRtb2R1bGVzNFtfaTEyXTtcbiAgICAgICAgX21vZHVsZTMub24oZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXR0YWNoTW9kdWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaE1vZHVsZShtb2R1bGUpIHtcbiAgICAgIGlmICh0aGlzLnY0Q29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IFhUSW50ZXJuYWxFcnJvcihcImF0dGFjaE1vZHVsZSgpIHNob3VsZCBub3QgYmUgY2FsbGVkIG1hbnVhbGx5IHdoZW4gdXNpbmcgdGhlIHY0IGNvbnN0cnVjdG9yXCIpO1xuICAgICAgfVxuICAgICAgZGVwcmVjYXRlZE1ldGhvZCh0aGlzLCBcImF0dGFjaE1vZHVsZVwiKTtcbiAgICAgIHZhciBtb2R1bGVUeXBlID0gX3R5cGVvZihtb2R1bGUpO1xuICAgICAgaWYgKG1vZHVsZVR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgWFRJbnRlcm5hbEVycm9yKFwiQ2Fubm90IGF0dGFjaCBhIGNsYXNzL2Z1bmN0aW9uIGFzIGEgbW9kdWxlLiBNb3N0IHByb2JhYmx5IHlvdSBmb3Jnb3QgdG8gaW5zdGFudGlhdGUgdGhlIG1vZHVsZSBieSB1c2luZyBgbmV3YCBvbiB0aGUgbW9kdWxlLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghbW9kdWxlIHx8IG1vZHVsZVR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFhUSW50ZXJuYWxFcnJvcihcIkNhbm5vdCBhdHRhY2hNb2R1bGUgd2l0aCBhIGZhbHN5IHZhbHVlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG1vZHVsZS5yZXF1aXJlZEFQSVZlcnNpb24pIHtcbiAgICAgICAgdGhpcy52ZXJpZnlBcGlWZXJzaW9uKG1vZHVsZS5yZXF1aXJlZEFQSVZlcnNpb24pO1xuICAgICAgfVxuICAgICAgaWYgKG1vZHVsZS5hdHRhY2hlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZS5jbG9uZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgbW9kdWxlID0gbW9kdWxlLmNsb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGF0dGFjaCBhIG1vZHVsZSB0aGF0IHdhcyBhbHJlYWR5IGF0dGFjaGVkIDogXFxcIlwiLmNvbmNhdChtb2R1bGUubmFtZSwgXCJcXFwiLiBUaGUgbW9zdCBsaWtlbHkgY2F1c2UgaXMgdGhhdCB5b3UgYXJlIGluc3RhbnRpYXRpbmcgdGhlIG1vZHVsZSBhdCB0aGUgcm9vdCBsZXZlbCwgYW5kIHVzaW5nIGl0IGZvciBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgRG9jeHRlbXBsYXRlclwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1vZHVsZS5hdHRhY2hlZCA9IHRydWU7XG4gICAgICB2YXIgd3JhcHBlZE1vZHVsZSA9IG1vZHVsZVdyYXBwZXIobW9kdWxlKTtcbiAgICAgIHRoaXMubW9kdWxlcy5wdXNoKHdyYXBwZWRNb2R1bGUpO1xuICAgICAgd3JhcHBlZE1vZHVsZS5vbihcImF0dGFjaGVkXCIpO1xuICAgICAgaWYgKHRoaXMuZmlsZVR5cGUpIHtcbiAgICAgICAgZHJvcFVuc3VwcG9ydGVkRmlsZVR5cGVzTW9kdWxlcyh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzJGRlbGltaXRlcnMsIF90aGlzJGRlbGltaXRlcnMyO1xuICAgICAgaWYgKHRoaXMudjRDb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXRPcHRpb25zKCkgc2hvdWxkIG5vdCBiZSBjYWxsZWQgbWFudWFsbHkgd2hlbiB1c2luZyB0aGUgdjQgY29uc3RydWN0b3JcIik7XG4gICAgICB9XG4gICAgICBkZXByZWNhdGVkTWV0aG9kKHRoaXMsIFwic2V0T3B0aW9uc1wiKTtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXRPcHRpb25zIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBhbiBvYmplY3QgYXMgZmlyc3QgcGFyYW1ldGVyXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICB2YXIgZGVmYXVsdHMgPSBnZXREZWZhdWx0cygpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBkZWZhdWx0c1trZXldO1xuICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XSAhPSBudWxsID8gb3B0aW9uc1trZXldIDogdGhpc1trZXldIHx8IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgdGhpc1trZXldID0gdGhpcy5vcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgICAoX3RoaXMkZGVsaW1pdGVycyA9IHRoaXMuZGVsaW1pdGVycykuc3RhcnQgJiYgKF90aGlzJGRlbGltaXRlcnMuc3RhcnQgPSBEb2NVdGlscy51dGY4VG9Xb3JkKHRoaXMuZGVsaW1pdGVycy5zdGFydCkpO1xuICAgICAgKF90aGlzJGRlbGltaXRlcnMyID0gdGhpcy5kZWxpbWl0ZXJzKS5lbmQgJiYgKF90aGlzJGRlbGltaXRlcnMyLmVuZCA9IERvY1V0aWxzLnV0ZjhUb1dvcmQodGhpcy5kZWxpbWl0ZXJzLmVuZCkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvYWRaaXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZFppcCh6aXApIHtcbiAgICAgIGlmICh0aGlzLnY0Q29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9hZFppcCgpIHNob3VsZCBub3QgYmUgY2FsbGVkIG1hbnVhbGx5IHdoZW4gdXNpbmcgdGhlIHY0IGNvbnN0cnVjdG9yXCIpO1xuICAgICAgfVxuICAgICAgZGVwcmVjYXRlZE1ldGhvZCh0aGlzLCBcImxvYWRaaXBcIik7XG4gICAgICBpZiAoemlwLmxvYWRBc3luYykge1xuICAgICAgICB0aHJvdyBuZXcgWFRJbnRlcm5hbEVycm9yKFwiRG9jeHRlbXBsYXRlciBkb2Vzbid0IGhhbmRsZSBKU1ppcCB2ZXJzaW9uID49MywgcGxlYXNlIHVzZSBwaXp6aXBcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnppcCA9IHppcDtcbiAgICAgIHRoaXMudXBkYXRlRmlsZVR5cGVDb25maWcoKTtcbiAgICAgIHRoaXMubW9kdWxlcyA9IGNvbmNhdEFycmF5cyhbdGhpcy5maWxlVHlwZUNvbmZpZy5iYXNlTW9kdWxlcy5tYXAoZnVuY3Rpb24gKG1vZHVsZUZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGVGdW5jdGlvbigpO1xuICAgICAgfSksIHRoaXMubW9kdWxlc10pO1xuICAgICAgZm9yICh2YXIgX2kxNCA9IDAsIF90aGlzJG1vZHVsZXM2ID0gdGhpcy5tb2R1bGVzOyBfaTE0IDwgX3RoaXMkbW9kdWxlczYubGVuZ3RoOyBfaTE0KyspIHtcbiAgICAgICAgdmFyIF9tb2R1bGU0ID0gX3RoaXMkbW9kdWxlczZbX2kxNF07XG4gICAgICAgIF9tb2R1bGU0LnppcCA9IHRoaXMuemlwO1xuICAgICAgICBfbW9kdWxlNC5kb2N4dGVtcGxhdGVyID0gdGhpcztcbiAgICAgIH1cbiAgICAgIGRyb3BVbnN1cHBvcnRlZEZpbGVUeXBlc01vZHVsZXModGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlY29tcGlsZUZpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlY29tcGlsZUZpbGUoZmlsZU5hbWUpIHtcbiAgICAgIHZhciBjdXJyZW50RmlsZSA9IHRoaXMuY3JlYXRlVGVtcGxhdGVDbGFzcyhmaWxlTmFtZSk7XG4gICAgICBjdXJyZW50RmlsZS5wcmVwYXJzZSgpO1xuICAgICAgdGhpcy5jb21waWxlZFtmaWxlTmFtZV0gPSBjdXJyZW50RmlsZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGlsZUZpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGlsZUZpbGUoZmlsZU5hbWUpIHtcbiAgICAgIHRoaXMuY29tcGlsZWRbZmlsZU5hbWVdLnBhcnNlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNjb3BlTWFuYWdlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY29wZU1hbmFnZXIodG8sIGN1cnJlbnRGaWxlLCB0YWdzKSB7XG4gICAgICB2YXIgX3RoaXMkc2NvcGVNYW5hZ2VycztcbiAgICAgIChfdGhpcyRzY29wZU1hbmFnZXJzID0gdGhpcy5zY29wZU1hbmFnZXJzKVt0b10gfHwgKF90aGlzJHNjb3BlTWFuYWdlcnNbdG9dID0gY3JlYXRlU2NvcGUoe1xuICAgICAgICB0YWdzOiB0YWdzLFxuICAgICAgICBwYXJzZXI6IHRoaXMucGFyc2VyLFxuICAgICAgICBjYWNoZWRQYXJzZXJzOiBjdXJyZW50RmlsZS5jYWNoZWRQYXJzZXJzXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gdGhpcy5zY29wZU1hbmFnZXJzW3RvXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZURhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZURhdGEoZGF0YSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGRlcHJlY2F0ZWRNZXRob2QodGhpcywgXCJyZXNvbHZlRGF0YVwiKTtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5jb21waWxlZCkubGVuZ3RoKSB7XG4gICAgICAgIHRocm93UmVzb2x2ZUJlZm9yZUNvbXBpbGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBfdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgX3RoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgICAgZGF0YTogX3RoaXMuZGF0YSxcbiAgICAgICAgICBMZXhlcjogTGV4ZXJcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLm1hcHBlciA9IF90aGlzLm1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uICh2YWx1ZSwgbW9kdWxlKSB7XG4gICAgICAgICAgcmV0dXJuIG1vZHVsZS5nZXRSZW5kZXJlZE1hcCh2YWx1ZSk7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKF90aGlzLm1hcHBlcikubWFwKGZ1bmN0aW9uICh0bykge1xuICAgICAgICAgIHZhciBfdGhpcyRtYXBwZXIkdG8gPSBfdGhpcy5tYXBwZXJbdG9dLFxuICAgICAgICAgICAgZnJvbSA9IF90aGlzJG1hcHBlciR0by5mcm9tLFxuICAgICAgICAgICAgZGF0YSA9IF90aGlzJG1hcHBlciR0by5kYXRhO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRGaWxlID0gX3RoaXMuY29tcGlsZWRbZnJvbV07XG4gICAgICAgICAgICBjdXJyZW50RmlsZS5maWxlUGF0aCA9IHRvO1xuICAgICAgICAgICAgY3VycmVudEZpbGUuc2NvcGVNYW5hZ2VyID0gX3RoaXMuZ2V0U2NvcGVNYW5hZ2VyKHRvLCBjdXJyZW50RmlsZSwgZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEZpbGUucmVzb2x2ZVRhZ3MoZGF0YSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRGaWxlLnNjb3BlTWFuYWdlci5maW5pc2hlZFJlc29sdmluZyA9IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJycykge1xuICAgICAgICAgICAgICBwdXNoQXJyYXkoZXJyb3JzLCBlcnJzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuZXJyb3JMb2dnaW5nKSB7XG4gICAgICAgICAgICAgIGxvZ0Vycm9ycyhlcnJvcnMsIF90aGlzLm9wdGlvbnMuZXJyb3JMb2dnaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93TXVsdGlFcnJvcihlcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29uY2F0QXJyYXlzKHJlc29sdmVkKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVvcmRlck1vZHVsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVvcmRlck1vZHVsZXMoKSB7XG4gICAgICAvKipcbiAgICAgICAqIE1vZHVsZXMgd2lsbCBiZSBzb3J0ZWQgYWNjb3JkaW5nIHRvIHByaW9yaXR5LlxuICAgICAgICpcbiAgICAgICAqIElucHV0IGV4YW1wbGU6XG4gICAgICAgKiBbXG4gICAgICAgKiAgIHsgcHJpb3JpdHk6IDEsIG5hbWU6IFwiRm9vTW9kXCIgfSxcbiAgICAgICAqICAgeyBwcmlvcml0eTogLTEsIG5hbWU6IFwiWE1vZFwiIH0sXG4gICAgICAgKiAgIHsgcHJpb3JpdHk6IDQsIG5hbWU6IFwiT3RoZXJNb2RcIiB9XG4gICAgICAgKiBdXG4gICAgICAgKlxuICAgICAgICogT3V0cHV0IGV4YW1wbGUgKHNvcnRlZCBieSBwcmlvcml0eSBpbiBkZXNjZW5kaW5nIG9yZGVyKTpcbiAgICAgICAqIFtcbiAgICAgICAqICAgeyBwcmlvcml0eTogNCwgbmFtZTogXCJPdGhlck1vZFwiIH0sXG4gICAgICAgKiAgIHsgcHJpb3JpdHk6IDEsIG5hbWU6IFwiRm9vTW9kXCIgfSxcbiAgICAgICAqICAgeyBwcmlvcml0eTogLTEsIG5hbWU6IFwiWE1vZFwiIH1cbiAgICAgICAqIF1cbiAgICAgICAqIFRlc3RlZCBpbiAjdGVzdC1yZW9yZGVyLW1vZHVsZXNcbiAgICAgICAqL1xuICAgICAgdGhpcy5tb2R1bGVzID0gc3RhYmxlU29ydCh0aGlzLm1vZHVsZXMsIGZ1bmN0aW9uIChtMSwgbTIpIHtcbiAgICAgICAgcmV0dXJuIChtMi5wcmlvcml0eSB8fCAwKSAtIChtMS5wcmlvcml0eSB8fCAwKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0aHJvd0lmRHVwbGljYXRlTW9kdWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aHJvd0lmRHVwbGljYXRlTW9kdWxlcygpIHtcbiAgICAgIHZhciBkdXBsaWNhdGVzID0gZ2V0RHVwbGljYXRlcyh0aGlzLm1vZHVsZXMubWFwKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYyLm5hbWU7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfSkpO1xuICAgICAgaWYgKGR1cGxpY2F0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgWFRJbnRlcm5hbEVycm9yKFwiRGV0ZWN0ZWQgZHVwbGljYXRlIG1vZHVsZSBcXFwiXCIuY29uY2F0KGR1cGxpY2F0ZXNbMF0sIFwiXFxcIlwiKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGlsZSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgZGVwcmVjYXRlZE1ldGhvZCh0aGlzLCBcImNvbXBpbGVcIik7XG4gICAgICB0aGlzLnVwZGF0ZUZpbGVUeXBlQ29uZmlnKCk7XG4gICAgICB0aGlzLnRocm93SWZEdXBsaWNhdGVNb2R1bGVzKCk7XG4gICAgICB0aGlzLnJlb3JkZXJNb2R1bGVzKCk7XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5jb21waWxlZCkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5tb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAob3B0aW9ucywgbW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGUub3B0aW9uc1RyYW5zZm9ybWVyKG9wdGlvbnMsIF90aGlzMik7XG4gICAgICB9LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5vcHRpb25zLnhtbEZpbGVOYW1lcyA9IHVuaXEodGhpcy5vcHRpb25zLnhtbEZpbGVOYW1lcyk7XG4gICAgICBmb3IgKHZhciBfaTE2ID0gMCwgX3RoaXMkb3B0aW9ucyR4bWxGaWxlMiA9IHRoaXMub3B0aW9ucy54bWxGaWxlTmFtZXM7IF9pMTYgPCBfdGhpcyRvcHRpb25zJHhtbEZpbGUyLmxlbmd0aDsgX2kxNisrKSB7XG4gICAgICAgIHZhciBmaWxlTmFtZSA9IF90aGlzJG9wdGlvbnMkeG1sRmlsZTJbX2kxNl07XG4gICAgICAgIHZhciBjb250ZW50ID0gdGhpcy56aXAuZmlsZXNbZmlsZU5hbWVdLmFzVGV4dCgpO1xuICAgICAgICB0aGlzLnhtbERvY3VtZW50c1tmaWxlTmFtZV0gPSBzdHIyeG1sKGNvbnRlbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgemlwOiB0aGlzLnppcCxcbiAgICAgICAgeG1sRG9jdW1lbnRzOiB0aGlzLnhtbERvY3VtZW50c1xuICAgICAgfSk7XG4gICAgICB0aGlzLmdldFRlbXBsYXRlZEZpbGVzKCk7XG4gICAgICAvKlxuICAgICAgICogTG9vcCBpbnNpZGUgYWxsIHRlbXBsYXRlZEZpbGVzIChpZSB4bWwgZmlsZXMgd2l0aCBjb250ZW50KS5cbiAgICAgICAqIFNvbWV0aW1lcyB0aGV5IGRvbid0IGV4aXN0IChmb290ZXIueG1sIGZvciBleGFtcGxlKVxuICAgICAgICovXG4gICAgICB0aGlzLnNlbmRFdmVudChcImJlZm9yZS1wcmVwYXJzZVwiKTtcbiAgICAgIGZvciAodmFyIF9pMTggPSAwLCBfdGhpcyR0ZW1wbGF0ZWRGaWxlczIgPSB0aGlzLnRlbXBsYXRlZEZpbGVzOyBfaTE4IDwgX3RoaXMkdGVtcGxhdGVkRmlsZXMyLmxlbmd0aDsgX2kxOCsrKSB7XG4gICAgICAgIHZhciBfZmlsZU5hbWUgPSBfdGhpcyR0ZW1wbGF0ZWRGaWxlczJbX2kxOF07XG4gICAgICAgIGlmICh0aGlzLnppcC5maWxlc1tfZmlsZU5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnByZWNvbXBpbGVGaWxlKF9maWxlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc2VuZEV2ZW50KFwiYWZ0ZXItcHJlcGFyc2VcIik7XG4gICAgICBmb3IgKHZhciBfaTIwID0gMCwgX3RoaXMkdGVtcGxhdGVkRmlsZXM0ID0gdGhpcy50ZW1wbGF0ZWRGaWxlczsgX2kyMCA8IF90aGlzJHRlbXBsYXRlZEZpbGVzNC5sZW5ndGg7IF9pMjArKykge1xuICAgICAgICB2YXIgX2ZpbGVOYW1lMiA9IF90aGlzJHRlbXBsYXRlZEZpbGVzNFtfaTIwXTtcbiAgICAgICAgaWYgKHRoaXMuemlwLmZpbGVzW19maWxlTmFtZTJdICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmNvbXBpbGVkW19maWxlTmFtZTJdLnBhcnNlKHtcbiAgICAgICAgICAgIG5vUG9zdFBhcnNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuc2VuZEV2ZW50KFwiYWZ0ZXItcGFyc2VcIik7XG4gICAgICBmb3IgKHZhciBfaTIyID0gMCwgX3RoaXMkdGVtcGxhdGVkRmlsZXM2ID0gdGhpcy50ZW1wbGF0ZWRGaWxlczsgX2kyMiA8IF90aGlzJHRlbXBsYXRlZEZpbGVzNi5sZW5ndGg7IF9pMjIrKykge1xuICAgICAgICB2YXIgX2ZpbGVOYW1lMyA9IF90aGlzJHRlbXBsYXRlZEZpbGVzNltfaTIyXTtcbiAgICAgICAgaWYgKHRoaXMuemlwLmZpbGVzW19maWxlTmFtZTNdICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmNvbXBpbGVkW19maWxlTmFtZTNdLnBvc3RwYXJzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnNlbmRFdmVudChcImFmdGVyLXBvc3RwYXJzZVwiKTtcbiAgICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgIGNvbXBpbGVkOiB0aGlzLmNvbXBpbGVkXG4gICAgICB9KTtcbiAgICAgIHZlcmlmeUVycm9ycyh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRSZWxzVHlwZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVsc1R5cGVzKCkge1xuICAgICAgdmFyIHJvb3RSZWxzID0gdGhpcy56aXAuZmlsZXNbcmVsc0ZpbGVdO1xuICAgICAgdmFyIHJvb3RSZWxzWG1sID0gcm9vdFJlbHMgPyBzdHIyeG1sKHJvb3RSZWxzLmFzVGV4dCgpKSA6IG51bGw7XG4gICAgICB2YXIgcm9vdFJlbGF0aW9uc2hpcHMgPSByb290UmVsc1htbCA/IHJvb3RSZWxzWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiUmVsYXRpb25zaGlwXCIpIDogW107XG4gICAgICB2YXIgcmVsc1R5cGVzID0ge307XG4gICAgICBmb3IgKHZhciBfaTI0ID0gMDsgX2kyNCA8IHJvb3RSZWxhdGlvbnNoaXBzLmxlbmd0aDsgX2kyNCsrKSB7XG4gICAgICAgIHZhciByZWxhdGlvbiA9IHJvb3RSZWxhdGlvbnNoaXBzW19pMjRdO1xuICAgICAgICByZWxzVHlwZXNbcmVsYXRpb24uZ2V0QXR0cmlidXRlKFwiVGFyZ2V0XCIpXSA9IHJlbGF0aW9uLmdldEF0dHJpYnV0ZShcIlR5cGVcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVsc1R5cGVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb250ZW50VHlwZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGVudFR5cGVzKCkge1xuICAgICAgdmFyIGNvbnRlbnRUeXBlcyA9IHRoaXMuemlwLmZpbGVzW2N0WE1MXTtcbiAgICAgIHZhciBjb250ZW50VHlwZVhtbCA9IGNvbnRlbnRUeXBlcyA/IHN0cjJ4bWwoY29udGVudFR5cGVzLmFzVGV4dCgpKSA6IG51bGw7XG4gICAgICB2YXIgb3ZlcnJpZGVzID0gY29udGVudFR5cGVYbWwgPyBjb250ZW50VHlwZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIk92ZXJyaWRlXCIpIDogbnVsbDtcbiAgICAgIHZhciBkZWZhdWx0cyA9IGNvbnRlbnRUeXBlWG1sID8gY29udGVudFR5cGVYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJEZWZhdWx0XCIpIDogbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG92ZXJyaWRlczogb3ZlcnJpZGVzLFxuICAgICAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgICAgIGNvbnRlbnRUeXBlczogY29udGVudFR5cGVzLFxuICAgICAgICBjb250ZW50VHlwZVhtbDogY29udGVudFR5cGVYbWxcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUZpbGVUeXBlQ29uZmlnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUZpbGVUeXBlQ29uZmlnKCkge1xuICAgICAgdGhpcy5yZWxzVHlwZXMgPSB0aGlzLmdldFJlbHNUeXBlcygpO1xuICAgICAgdmFyIF90aGlzJGdldENvbnRlbnRUeXBlcyA9IHRoaXMuZ2V0Q29udGVudFR5cGVzKCksXG4gICAgICAgIG92ZXJyaWRlcyA9IF90aGlzJGdldENvbnRlbnRUeXBlcy5vdmVycmlkZXMsXG4gICAgICAgIGRlZmF1bHRzID0gX3RoaXMkZ2V0Q29udGVudFR5cGVzLmRlZmF1bHRzLFxuICAgICAgICBjb250ZW50VHlwZXMgPSBfdGhpcyRnZXRDb250ZW50VHlwZXMuY29udGVudFR5cGVzLFxuICAgICAgICBjb250ZW50VHlwZVhtbCA9IF90aGlzJGdldENvbnRlbnRUeXBlcy5jb250ZW50VHlwZVhtbDtcbiAgICAgIGlmIChjb250ZW50VHlwZVhtbCkge1xuICAgICAgICB0aGlzLmZpbGVzQ29udGVudFR5cGVzID0gY29sbGVjdENvbnRlbnRUeXBlcyhvdmVycmlkZXMsIGRlZmF1bHRzLCB0aGlzLnppcCk7XG4gICAgICAgIHRoaXMuaW52ZXJ0ZWRDb250ZW50VHlwZXMgPSBEb2NVdGlscy5pbnZlcnRNYXAodGhpcy5maWxlc0NvbnRlbnRUeXBlcyk7XG4gICAgICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgICAgY29udGVudFR5cGVzOiB0aGlzLmNvbnRlbnRUeXBlcyxcbiAgICAgICAgICBpbnZlcnRlZENvbnRlbnRUeXBlczogdGhpcy5pbnZlcnRlZENvbnRlbnRUeXBlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBmaWxlVHlwZTtcbiAgICAgIGlmICh0aGlzLnppcC5maWxlcy5taW1ldHlwZSkge1xuICAgICAgICBmaWxlVHlwZSA9IFwib2R0XCI7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaTI2ID0gMCwgX3RoaXMkbW9kdWxlczggPSB0aGlzLm1vZHVsZXM7IF9pMjYgPCBfdGhpcyRtb2R1bGVzOC5sZW5ndGg7IF9pMjYrKykge1xuICAgICAgICB2YXIgX21vZHVsZTUgPSBfdGhpcyRtb2R1bGVzOFtfaTI2XTtcbiAgICAgICAgZmlsZVR5cGUgPSBfbW9kdWxlNS5nZXRGaWxlVHlwZSh7XG4gICAgICAgICAgemlwOiB0aGlzLnppcCxcbiAgICAgICAgICBjb250ZW50VHlwZXM6IGNvbnRlbnRUeXBlcyxcbiAgICAgICAgICBjb250ZW50VHlwZVhtbDogY29udGVudFR5cGVYbWwsXG4gICAgICAgICAgb3ZlcnJpZGVzOiBvdmVycmlkZXMsXG4gICAgICAgICAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuICAgICAgICAgIGRvYzogdGhpc1xuICAgICAgICB9KSB8fCBmaWxlVHlwZTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxlVHlwZSA9PT0gXCJvZHRcIikge1xuICAgICAgICB0aHJvd0ZpbGVUeXBlTm90SGFuZGxlZChmaWxlVHlwZSk7XG4gICAgICB9XG4gICAgICBpZiAoIWZpbGVUeXBlKSB7XG4gICAgICAgIHRocm93RmlsZVR5cGVOb3RJZGVudGlmaWVkKHRoaXMuemlwKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pMjggPSAwLCBfdGhpcyRtb2R1bGVzMTAgPSB0aGlzLm1vZHVsZXM7IF9pMjggPCBfdGhpcyRtb2R1bGVzMTAubGVuZ3RoOyBfaTI4KyspIHtcbiAgICAgICAgdmFyIF9tb2R1bGU2ID0gX3RoaXMkbW9kdWxlczEwW19pMjhdO1xuICAgICAgICBmb3IgKHZhciBfaTMwID0gMCwgX3JlZjQgPSBfbW9kdWxlNi54bWxDb250ZW50VHlwZXMgfHwgW107IF9pMzAgPCBfcmVmNC5sZW5ndGg7IF9pMzArKykge1xuICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IF9yZWY0W19pMzBdO1xuICAgICAgICAgIHB1c2hBcnJheSh0aGlzLm9wdGlvbnMueG1sRmlsZU5hbWVzLCB0aGlzLmludmVydGVkQ29udGVudFR5cGVzW2NvbnRlbnRUeXBlXSB8fCBbXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZmlsZVR5cGUgPSBmaWxlVHlwZTtcbiAgICAgIGRyb3BVbnN1cHBvcnRlZEZpbGVUeXBlc01vZHVsZXModGhpcyk7XG4gICAgICB0aGlzLmZpbGVUeXBlQ29uZmlnID0gdGhpcy5vcHRpb25zLmZpbGVUeXBlQ29uZmlnIHx8IHRoaXMuZmlsZVR5cGVDb25maWc7XG4gICAgICBpZiAoIXRoaXMuZmlsZVR5cGVDb25maWcpIHtcbiAgICAgICAgaWYgKERvY3h0ZW1wbGF0ZXIuRmlsZVR5cGVDb25maWdbdGhpcy5maWxlVHlwZV0pIHtcbiAgICAgICAgICB0aGlzLmZpbGVUeXBlQ29uZmlnID0gRG9jeHRlbXBsYXRlci5GaWxlVHlwZUNvbmZpZ1t0aGlzLmZpbGVUeXBlXSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICogRXJyb3IgY2FzZSBoYW5kbGVkIHNpbmNlIHYzLjYwLjJcbiAgICAgICAgICAgKiBUaHJvdyBzcGVjaWZpYyBlcnJvciB3aGVuIHRyeWluZyB0byB0ZW1wbGF0ZSB4bHN4IGZpbGUgd2l0aG91dCB4bHN4bW9kdWxlXG4gICAgICAgICAgICovXG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIkZpbGV0eXBlIFxcXCJcIi5jb25jYXQodGhpcy5maWxlVHlwZSwgXCJcXFwiIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgdmFyIGlkID0gXCJmaWxldHlwZV9ub3Rfc3VwcG9ydGVkXCI7XG4gICAgICAgICAgaWYgKHRoaXMuZmlsZVR5cGUgPT09IFwieGxzeFwiKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJGaWxldHlwZSBcXFwiXCIuY29uY2F0KHRoaXMuZmlsZVR5cGUsIFwiXFxcIiBpcyBzdXBwb3J0ZWQgb25seSB3aXRoIHRoZSBwYWlkIFhsc3hNb2R1bGVcIik7XG4gICAgICAgICAgICBpZCA9IFwieGxzeF9maWxldHlwZV9uZWVkc194bHN4X21vZHVsZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICBlcnIucHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGV4cGxhbmF0aW9uOiBtZXNzYWdlXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJBc3luY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJBc3luYyhkYXRhKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHRoaXMuaGlkZURlcHJlY2F0aW9ucyA9IHRydWU7XG4gICAgICB2YXIgcHJvbWlzZSA9IHRoaXMucmVzb2x2ZURhdGEoZGF0YSk7XG4gICAgICB0aGlzLmhpZGVEZXByZWNhdGlvbnMgPSBmYWxzZTtcbiAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLnJlbmRlcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoZGF0YSkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgICAgICAgdGhyb3dSZW5kZXJUd2ljZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5jb21waWxlZCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuY29tcGlsZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3dSZW5kZXJJbnZhbGlkVGVtcGxhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICBMZXhlcjogTGV4ZXJcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tYXBwZXIgfHwgKHRoaXMubWFwcGVyID0gdGhpcy5tb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAodmFsdWUsIG1vZHVsZSkge1xuICAgICAgICByZXR1cm4gbW9kdWxlLmdldFJlbmRlcmVkTWFwKHZhbHVlKTtcbiAgICAgIH0sIHt9KSk7XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICBmb3IgKHZhciB0byBpbiB0aGlzLm1hcHBlcikge1xuICAgICAgICB2YXIgX3RoaXMkbWFwcGVyJHRvMiA9IHRoaXMubWFwcGVyW3RvXSxcbiAgICAgICAgICBmcm9tID0gX3RoaXMkbWFwcGVyJHRvMi5mcm9tLFxuICAgICAgICAgIF9kYXRhID0gX3RoaXMkbWFwcGVyJHRvMi5kYXRhO1xuICAgICAgICB2YXIgY3VycmVudEZpbGUgPSB0aGlzLmNvbXBpbGVkW2Zyb21dO1xuICAgICAgICBjdXJyZW50RmlsZS5zY29wZU1hbmFnZXIgPSB0aGlzLmdldFNjb3BlTWFuYWdlcih0bywgY3VycmVudEZpbGUsIF9kYXRhKTtcbiAgICAgICAgY3VycmVudEZpbGUucmVuZGVyKHRvKTtcbiAgICAgICAgb3V0cHV0LnB1c2goW3RvLCBjdXJyZW50RmlsZS5jb250ZW50LCBjdXJyZW50RmlsZV0pO1xuICAgICAgICBkZWxldGUgY3VycmVudEZpbGUuY29udGVudDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pMzIgPSAwOyBfaTMyIDwgb3V0cHV0Lmxlbmd0aDsgX2kzMisrKSB7XG4gICAgICAgIHZhciBvdXRwdXRQYXJ0ID0gb3V0cHV0W19pMzJdO1xuICAgICAgICB2YXIgX291dHB1dFBhcnQgPSBfc2xpY2VkVG9BcnJheShvdXRwdXRQYXJ0LCAzKSxcbiAgICAgICAgICBjb250ZW50ID0gX291dHB1dFBhcnRbMV0sXG4gICAgICAgICAgX2N1cnJlbnRGaWxlID0gX291dHB1dFBhcnRbMl07XG4gICAgICAgIGZvciAodmFyIF9pMzQgPSAwLCBfdGhpcyRtb2R1bGVzMTIgPSB0aGlzLm1vZHVsZXM7IF9pMzQgPCBfdGhpcyRtb2R1bGVzMTIubGVuZ3RoOyBfaTM0KyspIHtcbiAgICAgICAgICB2YXIgX21vZHVsZTcgPSBfdGhpcyRtb2R1bGVzMTJbX2kzNF07XG4gICAgICAgICAgaWYgKF9tb2R1bGU3LnByZVppcCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF9tb2R1bGU3LnByZVppcChjb250ZW50LCBfY3VycmVudEZpbGUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgb3V0cHV0UGFydFsxXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pMzYgPSAwOyBfaTM2IDwgb3V0cHV0Lmxlbmd0aDsgX2kzNisrKSB7XG4gICAgICAgIHZhciBfb3V0cHV0JF9pID0gX3NsaWNlZFRvQXJyYXkob3V0cHV0W19pMzZdLCAyKSxcbiAgICAgICAgICBfdG8gPSBfb3V0cHV0JF9pWzBdLFxuICAgICAgICAgIF9jb250ZW50ID0gX291dHB1dCRfaVsxXTtcbiAgICAgICAgdGhpcy56aXAuZmlsZShfdG8sIF9jb250ZW50LCB7XG4gICAgICAgICAgY3JlYXRlRm9sZGVyczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZlcmlmeUVycm9ycyh0aGlzKTtcbiAgICAgIHRoaXMuc2VuZEV2ZW50KFwic3luY2luZy16aXBcIik7XG4gICAgICB0aGlzLnN5bmNaaXAoKTtcbiAgICAgIC8vIFRoZSBzeW5jZWQtemlwIGV2ZW50IGlzIHVzZWQgaW4gdGhlIHN1YnRlbXBsYXRlIG1vZHVsZSBmb3IgZXhhbXBsZVxuICAgICAgdGhpcy5zZW5kRXZlbnQoXCJzeW5jZWQtemlwXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN5bmNaaXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3luY1ppcCgpIHtcbiAgICAgIGZvciAodmFyIGZpbGVOYW1lIGluIHRoaXMueG1sRG9jdW1lbnRzKSB7XG4gICAgICAgIHRoaXMuemlwLnJlbW92ZShmaWxlTmFtZSk7XG4gICAgICAgIHZhciBjb250ZW50ID0geG1sMnN0cih0aGlzLnhtbERvY3VtZW50c1tmaWxlTmFtZV0pO1xuICAgICAgICB0aGlzLnppcC5maWxlKGZpbGVOYW1lLCBjb250ZW50LCB7XG4gICAgICAgICAgY3JlYXRlRm9sZGVyczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREYXRhKGRhdGEpIHtcbiAgICAgIGRlcHJlY2F0ZWRNZXRob2QodGhpcywgXCJzZXREYXRhXCIpO1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRaaXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0WmlwKCkge1xuICAgICAgcmV0dXJuIHRoaXMuemlwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVUZW1wbGF0ZUNsYXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRlQ2xhc3MocGF0aCkge1xuICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLnppcC5maWxlc1twYXRoXS5hc1RleHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRlbXBsYXRlQ2xhc3NGcm9tQ29udGVudChjb250ZW50LCBwYXRoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlVGVtcGxhdGVDbGFzc0Zyb21Db250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRlQ2xhc3NGcm9tQ29udGVudChjb250ZW50LCBmaWxlUGF0aCkge1xuICAgICAgdmFyIHhtbHRPcHRpb25zID0ge1xuICAgICAgICBmaWxlUGF0aDogZmlsZVBhdGgsXG4gICAgICAgIGNvbnRlbnRUeXBlOiB0aGlzLmZpbGVzQ29udGVudFR5cGVzW2ZpbGVQYXRoXSxcbiAgICAgICAgcmVsc1R5cGU6IHRoaXMucmVsc1R5cGVzW2ZpbGVQYXRoXVxuICAgICAgfTtcbiAgICAgIHZhciBkZWZhdWx0cyA9IGdldERlZmF1bHRzKCk7XG4gICAgICB2YXIgZGVmYXVsdEtleXMgPSBwdXNoQXJyYXkoT2JqZWN0LmtleXMoZGVmYXVsdHMpLCBbXCJmaWxlc0NvbnRlbnRUeXBlc1wiLCBcImZpbGVUeXBlQ29uZmlnXCIsIFwiZmlsZVR5cGVcIiwgXCJtb2R1bGVzXCJdKTtcbiAgICAgIGZvciAodmFyIF9pMzggPSAwOyBfaTM4IDwgZGVmYXVsdEtleXMubGVuZ3RoOyBfaTM4KyspIHtcbiAgICAgICAgdmFyIGtleSA9IGRlZmF1bHRLZXlzW19pMzhdO1xuICAgICAgICB4bWx0T3B0aW9uc1trZXldID0gdGhpc1trZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBEb2N4dGVtcGxhdGVyLlhtbFRlbXBsYXRlcihjb250ZW50LCB4bWx0T3B0aW9ucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZ1bGxUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZ1bGxUZXh0KHBhdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRlbXBsYXRlQ2xhc3MocGF0aCB8fCB0aGlzLmZpbGVUeXBlQ29uZmlnLnRleHRQYXRoKHRoaXMpKS5nZXRGdWxsVGV4dCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUZW1wbGF0ZWRGaWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZW1wbGF0ZWRGaWxlcygpIHtcbiAgICAgIHRoaXMudGVtcGxhdGVkRmlsZXMgPSB0aGlzLmZpbGVUeXBlQ29uZmlnLmdldFRlbXBsYXRlZEZpbGVzKHRoaXMuemlwKTtcbiAgICAgIHB1c2hBcnJheSh0aGlzLnRlbXBsYXRlZEZpbGVzLCB0aGlzLnRhcmdldHMpO1xuICAgICAgdGhpcy50ZW1wbGF0ZWRGaWxlcyA9IHVuaXEodGhpcy50ZW1wbGF0ZWRGaWxlcyk7XG4gICAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZWRGaWxlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGFnc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUYWdzKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgaGVhZGVyczogW10sXG4gICAgICAgIGZvb3RlcnM6IFtdXG4gICAgICB9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuY29tcGlsZWQpIHtcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gdGhpcy5maWxlc0NvbnRlbnRUeXBlc1trZXldO1xuICAgICAgICBpZiAoY29udGVudFR5cGUgPT09IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQubWFpbit4bWxcIikge1xuICAgICAgICAgIHJlc3VsdC5kb2N1bWVudCA9IHtcbiAgICAgICAgICAgIHRhcmdldDoga2V5LFxuICAgICAgICAgICAgdGFnczogX2dldFRhZ3ModGhpcy5jb21waWxlZFtrZXldLnBvc3RwYXJzZWQpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudFR5cGUgPT09IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuaGVhZGVyK3htbFwiKSB7XG4gICAgICAgICAgcmVzdWx0LmhlYWRlcnMucHVzaCh7XG4gICAgICAgICAgICB0YXJnZXQ6IGtleSxcbiAgICAgICAgICAgIHRhZ3M6IF9nZXRUYWdzKHRoaXMuY29tcGlsZWRba2V5XS5wb3N0cGFyc2VkKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50VHlwZSA9PT0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5mb290ZXIreG1sXCIpIHtcbiAgICAgICAgICByZXN1bHQuZm9vdGVycy5wdXNoKHtcbiAgICAgICAgICAgIHRhcmdldDoga2V5LFxuICAgICAgICAgICAgdGFnczogX2dldFRhZ3ModGhpcy5jb21waWxlZFtrZXldLnBvc3RwYXJzZWQpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyogRXhwb3J0IGZ1bmN0aW9ucywgcHJlc2VudCBzaW5jZSAzLjYyLjAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0b0J1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0J1ZmZlcihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRaaXAoKS5nZW5lcmF0ZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBjb21wcmVzc2lvbjogXCJERUZMQVRFXCIsXG4gICAgICAgIGZpbGVPcmRlcjogemlwRmlsZU9yZGVyXG4gICAgICB9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgdHlwZTogXCJub2RlYnVmZmVyXCJcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9CbG9iXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvQmxvYihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRaaXAoKS5nZW5lcmF0ZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBjb21wcmVzc2lvbjogXCJERUZMQVRFXCIsXG4gICAgICAgIGZpbGVPcmRlcjogemlwRmlsZU9yZGVyXG4gICAgICB9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgdHlwZTogXCJibG9iXCJcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9CYXNlNjRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9CYXNlNjQob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0WmlwKCkuZ2VuZXJhdGUoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgY29tcHJlc3Npb246IFwiREVGTEFURVwiLFxuICAgICAgICBmaWxlT3JkZXI6IHppcEZpbGVPcmRlclxuICAgICAgfSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgIHR5cGU6IFwiYmFzZTY0XCJcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9VaW50OEFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvVWludDhBcnJheShvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRaaXAoKS5nZW5lcmF0ZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBjb21wcmVzc2lvbjogXCJERUZMQVRFXCIsXG4gICAgICAgIGZpbGVPcmRlcjogemlwRmlsZU9yZGVyXG4gICAgICB9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgdHlwZTogXCJ1aW50OGFycmF5XCJcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9BcnJheUJ1ZmZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0FycmF5QnVmZmVyKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFppcCgpLmdlbmVyYXRlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGNvbXByZXNzaW9uOiBcIkRFRkxBVEVcIixcbiAgICAgICAgZmlsZU9yZGVyOiB6aXBGaWxlT3JkZXJcbiAgICAgIH0sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICB0eXBlOiBcImFycmF5YnVmZmVyXCJcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbkRvY3h0ZW1wbGF0ZXIuRG9jVXRpbHMgPSBEb2NVdGlscztcbkRvY3h0ZW1wbGF0ZXIuRXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpO1xuRG9jeHRlbXBsYXRlci5YbWxUZW1wbGF0ZXIgPSByZXF1aXJlKFwiLi94bWwtdGVtcGxhdGVyLmpzXCIpO1xuRG9jeHRlbXBsYXRlci5GaWxlVHlwZUNvbmZpZyA9IHJlcXVpcmUoXCIuL2ZpbGUtdHlwZS1jb25maWcuanNcIik7XG5Eb2N4dGVtcGxhdGVyLlhtbE1hdGNoZXIgPSByZXF1aXJlKFwiLi94bWwtbWF0Y2hlci5qc1wiKTtcbm1vZHVsZS5leHBvcnRzID0gRG9jeHRlbXBsYXRlcjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IERvY3h0ZW1wbGF0ZXI7Il0sIm5hbWVzIjpbIl9leGNsdWRlZCIsIm93bktleXMiLCJlIiwiciIsInQiLCJPYmplY3QiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwibyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfc2xpY2VkVG9BcnJheSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJUeXBlRXJyb3IiLCJhIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJuIiwibCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiaSIsInUiLCJmIiwibmV4dCIsImRvbmUiLCJpc0FycmF5IiwiX3R5cGVvZiIsInByb3RvdHlwZSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiaW5kZXhPZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiaGFzT3duUHJvcGVydHkiLCJfY2xhc3NDYWxsQ2hlY2siLCJfZGVmaW5lUHJvcGVydGllcyIsImtleSIsIl9jcmVhdGVDbGFzcyIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiRG9jVXRpbHMiLCJyZXF1aXJlIiwidHJhaXRzIiwibW9kdWxlV3JhcHBlciIsImNvbW1vbk1vZHVsZSIsImNyZWF0ZVNjb3BlIiwiTGV4ZXIiLCJfcmVxdWlyZSIsIl9nZXRUYWdzIiwiZ2V0VGFncyIsImxvZ0Vycm9ycyIsImNvbGxlY3RDb250ZW50VHlwZXMiLCJfcmVxdWlyZTIiLCJ0aHJvd011bHRpRXJyb3IiLCJ0aHJvd1Jlc29sdmVCZWZvcmVDb21waWxlIiwidGhyb3dSZW5kZXJJbnZhbGlkVGVtcGxhdGUiLCJ0aHJvd1JlbmRlclR3aWNlIiwiWFRJbnRlcm5hbEVycm9yIiwiWFRUZW1wbGF0ZUVycm9yIiwidGhyb3dGaWxlVHlwZU5vdElkZW50aWZpZWQiLCJ0aHJvd0ZpbGVUeXBlTm90SGFuZGxlZCIsInRocm93QXBpVmVyc2lvbkVycm9yIiwiZ2V0RGVmYXVsdHMiLCJzdHIyeG1sIiwieG1sMnN0ciIsImNvbmNhdEFycmF5cyIsInVuaXEiLCJnZXREdXBsaWNhdGVzIiwic3RhYmxlU29ydCIsInB1c2hBcnJheSIsImN0WE1MIiwicmVsc0ZpbGUiLCJjdXJyZW50TW9kdWxlQXBpVmVyc2lvbiIsInppcEZpbGVPcmRlciIsImZpbGVzIiwiYWxsRmlsZXMiLCJyZXN1bHRGaWxlcyIsInByZWZpeGVzIiwiX2kyIiwiX25hbWUiLCJfaTQiLCJwcmVmaXgiLCJjb25jYXQiLCJfaTYiLCJfbmFtZTIiLCJkZXByZWNhdGVkTWVzc2FnZSIsIm9iaiIsIm1lc3NhZ2UiLCJoaWRlRGVwcmVjYXRpb25zIiwiY29uc29sZSIsIndhcm4iLCJkZXByZWNhdGVkTWV0aG9kIiwibWV0aG9kIiwiRXJyb3IiLCJzdGFjayIsImRyb3BVbnN1cHBvcnRlZEZpbGVUeXBlc01vZHVsZXMiLCJkb2MiLCJtb2R1bGVzIiwibW9kdWxlIiwic3VwcG9ydGVkRmlsZVR5cGVzIiwiaXNTdXBwb3J0ZWRNb2R1bGUiLCJpbmNsdWRlcyIsImZpbGVUeXBlIiwib24iLCJ2ZXJpZnlFcnJvcnMiLCJjb21waWxlZCIsImVycm9ycyIsIm1hcCIsImFsbEVycm9ycyIsIm9wdGlvbnMiLCJlcnJvckxvZ2dpbmciLCJEb2N4dGVtcGxhdGVyIiwiemlwIiwiX3JlZiIsInVuZGVmaW5lZCIsIl9yZWYkbW9kdWxlcyIsInRhcmdldHMiLCJyZW5kZXJlZCIsInNjb3BlTWFuYWdlcnMiLCJ4bWxEb2N1bWVudHMiLCJzZXRPcHRpb25zIiwiZmlsZSIsIl9pOCIsIl9tb2R1bGUiLCJhdHRhY2hNb2R1bGUiLCJsb2FkWmlwIiwiY29tcGlsZSIsInY0Q29uc3RydWN0b3IiLCJ2ZXJpZnlBcGlWZXJzaW9uIiwibmVlZGVkVmVyc2lvbiIsInNwbGl0IiwicGFyc2VJbnQiLCJleHBsYW5hdGlvbiIsImpvaW4iLCJzZXRNb2R1bGVzIiwiX2kxMCIsIl90aGlzJG1vZHVsZXMyIiwiX21vZHVsZTIiLCJzZXQiLCJzZW5kRXZlbnQiLCJldmVudE5hbWUiLCJfaTEyIiwiX3RoaXMkbW9kdWxlczQiLCJfbW9kdWxlMyIsIm1vZHVsZVR5cGUiLCJyZXF1aXJlZEFQSVZlcnNpb24iLCJhdHRhY2hlZCIsImNsb25lIiwid3JhcHBlZE1vZHVsZSIsIl90aGlzJGRlbGltaXRlcnMiLCJfdGhpcyRkZWxpbWl0ZXJzMiIsImRlZmF1bHRzIiwiZGVmYXVsdFZhbHVlIiwiZGVsaW1pdGVycyIsInN0YXJ0IiwidXRmOFRvV29yZCIsImVuZCIsImxvYWRBc3luYyIsInVwZGF0ZUZpbGVUeXBlQ29uZmlnIiwiZmlsZVR5cGVDb25maWciLCJiYXNlTW9kdWxlcyIsIm1vZHVsZUZ1bmN0aW9uIiwiX2kxNCIsIl90aGlzJG1vZHVsZXM2IiwiX21vZHVsZTQiLCJkb2N4dGVtcGxhdGVyIiwicHJlY29tcGlsZUZpbGUiLCJmaWxlTmFtZSIsImN1cnJlbnRGaWxlIiwiY3JlYXRlVGVtcGxhdGVDbGFzcyIsInByZXBhcnNlIiwiY29tcGlsZUZpbGUiLCJwYXJzZSIsImdldFNjb3BlTWFuYWdlciIsInRvIiwidGFncyIsIl90aGlzJHNjb3BlTWFuYWdlcnMiLCJwYXJzZXIiLCJjYWNoZWRQYXJzZXJzIiwicmVzb2x2ZURhdGEiLCJkYXRhIiwiX3RoaXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJtYXBwZXIiLCJyZWR1Y2UiLCJnZXRSZW5kZXJlZE1hcCIsImFsbCIsIl90aGlzJG1hcHBlciR0byIsImZpbGVQYXRoIiwic2NvcGVNYW5hZ2VyIiwicmVzb2x2ZVRhZ3MiLCJyZXN1bHQiLCJmaW5pc2hlZFJlc29sdmluZyIsImVycnMiLCJyZXNvbHZlZCIsInJlb3JkZXJNb2R1bGVzIiwibTEiLCJtMiIsInByaW9yaXR5IiwidGhyb3dJZkR1cGxpY2F0ZU1vZHVsZXMiLCJkdXBsaWNhdGVzIiwiX3JlZjIiLCJfdGhpczIiLCJvcHRpb25zVHJhbnNmb3JtZXIiLCJ4bWxGaWxlTmFtZXMiLCJfaTE2IiwiX3RoaXMkb3B0aW9ucyR4bWxGaWxlMiIsImNvbnRlbnQiLCJhc1RleHQiLCJnZXRUZW1wbGF0ZWRGaWxlcyIsIl9pMTgiLCJfdGhpcyR0ZW1wbGF0ZWRGaWxlczIiLCJ0ZW1wbGF0ZWRGaWxlcyIsIl9maWxlTmFtZSIsIl9pMjAiLCJfdGhpcyR0ZW1wbGF0ZWRGaWxlczQiLCJfZmlsZU5hbWUyIiwibm9Qb3N0UGFyc2UiLCJfaTIyIiwiX3RoaXMkdGVtcGxhdGVkRmlsZXM2IiwiX2ZpbGVOYW1lMyIsInBvc3RwYXJzZSIsImdldFJlbHNUeXBlcyIsInJvb3RSZWxzIiwicm9vdFJlbHNYbWwiLCJyb290UmVsYXRpb25zaGlwcyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwicmVsc1R5cGVzIiwiX2kyNCIsInJlbGF0aW9uIiwiZ2V0QXR0cmlidXRlIiwiZ2V0Q29udGVudFR5cGVzIiwiY29udGVudFR5cGVzIiwiY29udGVudFR5cGVYbWwiLCJvdmVycmlkZXMiLCJfdGhpcyRnZXRDb250ZW50VHlwZXMiLCJmaWxlc0NvbnRlbnRUeXBlcyIsImludmVydGVkQ29udGVudFR5cGVzIiwiaW52ZXJ0TWFwIiwibWltZXR5cGUiLCJfaTI2IiwiX3RoaXMkbW9kdWxlczgiLCJfbW9kdWxlNSIsImdldEZpbGVUeXBlIiwiX2kyOCIsIl90aGlzJG1vZHVsZXMxMCIsIl9tb2R1bGU2IiwiX2kzMCIsIl9yZWY0IiwieG1sQ29udGVudFR5cGVzIiwiY29udGVudFR5cGUiLCJGaWxlVHlwZUNvbmZpZyIsImlkIiwiZXJyIiwicHJvcGVydGllcyIsInJlbmRlckFzeW5jIiwiX3RoaXMzIiwicHJvbWlzZSIsInJlbmRlciIsIm91dHB1dCIsIl90aGlzJG1hcHBlciR0bzIiLCJfZGF0YSIsIl9pMzIiLCJvdXRwdXRQYXJ0IiwiX291dHB1dFBhcnQiLCJfY3VycmVudEZpbGUiLCJfaTM0IiwiX3RoaXMkbW9kdWxlczEyIiwiX21vZHVsZTciLCJwcmVaaXAiLCJfaTM2IiwiX291dHB1dCRfaSIsIl90byIsIl9jb250ZW50IiwiY3JlYXRlRm9sZGVycyIsInN5bmNaaXAiLCJyZW1vdmUiLCJzZXREYXRhIiwiZ2V0WmlwIiwicGF0aCIsImNyZWF0ZVRlbXBsYXRlQ2xhc3NGcm9tQ29udGVudCIsInhtbHRPcHRpb25zIiwicmVsc1R5cGUiLCJkZWZhdWx0S2V5cyIsIl9pMzgiLCJYbWxUZW1wbGF0ZXIiLCJnZXRGdWxsVGV4dCIsInRleHRQYXRoIiwiaGVhZGVycyIsImZvb3RlcnMiLCJkb2N1bWVudCIsInRhcmdldCIsInBvc3RwYXJzZWQiLCJ0b0J1ZmZlciIsImdlbmVyYXRlIiwiY29tcHJlc3Npb24iLCJmaWxlT3JkZXIiLCJ0eXBlIiwidG9CbG9iIiwidG9CYXNlNjQiLCJ0b1VpbnQ4QXJyYXkiLCJ0b0FycmF5QnVmZmVyIiwiRXJyb3JzIiwiWG1sTWF0Y2hlciIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/docxtemplater.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/error-logger.js":
/*!*******************************************************!*\
  !*** ./node_modules/docxtemplater/js/error-logger.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"), pushArray = _require.pushArray;\n// The error thrown here contains additional information when logged with JSON.stringify (it contains a properties object containing all suberrors).\nfunction replaceErrors(key, value) {\n    if (value instanceof Error) {\n        return pushArray(Object.getOwnPropertyNames(value), [\n            \"stack\"\n        ]).reduce(function(error, key) {\n            error[key] = value[key];\n            if (key === \"stack\") {\n                // This is used because in Firefox, stack is not an own property\n                error[key] = value[key].toString();\n            }\n            return error;\n        }, {});\n    }\n    return value;\n}\nfunction logger(error, logging) {\n    // eslint-disable-next-line no-console\n    console.log(JSON.stringify({\n        error: error\n    }, replaceErrors, logging === \"json\" ? 2 : null));\n    if (error.properties && error.properties.errors instanceof Array) {\n        var errorMessages = error.properties.errors.map(function(error) {\n            return error.properties.explanation;\n        }).join(\"\\n\");\n        // eslint-disable-next-line no-console\n        console.log(\"errorMessages\", errorMessages);\n    /*\n     * errorMessages is a humanly readable message looking like this :\n     * 'The tag beginning with \"foobar\" is unopened'\n     */ }\n}\nmodule.exports = logger;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9lcnJvci1sb2dnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxXQUFXQyxtQkFBT0EsQ0FBQywwRUFBZ0IsR0FDckNDLFlBQVlGLFNBQVNFLFNBQVM7QUFDaEMsb0pBQW9KO0FBQ3BKLFNBQVNDLGNBQWNDLEdBQUcsRUFBRUMsS0FBSztJQUMvQixJQUFJQSxpQkFBaUJDLE9BQU87UUFDMUIsT0FBT0osVUFBVUssT0FBT0MsbUJBQW1CLENBQUNILFFBQVE7WUFBQztTQUFRLEVBQUVJLE1BQU0sQ0FBQyxTQUFVQyxLQUFLLEVBQUVOLEdBQUc7WUFDeEZNLEtBQUssQ0FBQ04sSUFBSSxHQUFHQyxLQUFLLENBQUNELElBQUk7WUFDdkIsSUFBSUEsUUFBUSxTQUFTO2dCQUNuQixnRUFBZ0U7Z0JBQ2hFTSxLQUFLLENBQUNOLElBQUksR0FBR0MsS0FBSyxDQUFDRCxJQUFJLENBQUNPLFFBQVE7WUFDbEM7WUFDQSxPQUFPRDtRQUNULEdBQUcsQ0FBQztJQUNOO0lBQ0EsT0FBT0w7QUFDVDtBQUNBLFNBQVNPLE9BQU9GLEtBQUssRUFBRUcsT0FBTztJQUM1QixzQ0FBc0M7SUFDdENDLFFBQVFDLEdBQUcsQ0FBQ0MsS0FBS0MsU0FBUyxDQUFDO1FBQ3pCUCxPQUFPQTtJQUNULEdBQUdQLGVBQWVVLFlBQVksU0FBUyxJQUFJO0lBQzNDLElBQUlILE1BQU1RLFVBQVUsSUFBSVIsTUFBTVEsVUFBVSxDQUFDQyxNQUFNLFlBQVlDLE9BQU87UUFDaEUsSUFBSUMsZ0JBQWdCWCxNQUFNUSxVQUFVLENBQUNDLE1BQU0sQ0FBQ0csR0FBRyxDQUFDLFNBQVVaLEtBQUs7WUFDN0QsT0FBT0EsTUFBTVEsVUFBVSxDQUFDSyxXQUFXO1FBQ3JDLEdBQUdDLElBQUksQ0FBQztRQUNSLHNDQUFzQztRQUN0Q1YsUUFBUUMsR0FBRyxDQUFDLGlCQUFpQk07SUFDN0I7OztLQUdDLEdBQ0g7QUFDRjtBQUNBSSxPQUFPQyxPQUFPLEdBQUdkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlrZS1yZW50YWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2Vycm9yLWxvZ2dlci5qcz9lNzZhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9kb2MtdXRpbHMuanNcIiksXG4gIHB1c2hBcnJheSA9IF9yZXF1aXJlLnB1c2hBcnJheTtcbi8vIFRoZSBlcnJvciB0aHJvd24gaGVyZSBjb250YWlucyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHdoZW4gbG9nZ2VkIHdpdGggSlNPTi5zdHJpbmdpZnkgKGl0IGNvbnRhaW5zIGEgcHJvcGVydGllcyBvYmplY3QgY29udGFpbmluZyBhbGwgc3ViZXJyb3JzKS5cbmZ1bmN0aW9uIHJlcGxhY2VFcnJvcnMoa2V5LCB2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBwdXNoQXJyYXkoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLCBbXCJzdGFja1wiXSkucmVkdWNlKGZ1bmN0aW9uIChlcnJvciwga2V5KSB7XG4gICAgICBlcnJvcltrZXldID0gdmFsdWVba2V5XTtcbiAgICAgIGlmIChrZXkgPT09IFwic3RhY2tcIikge1xuICAgICAgICAvLyBUaGlzIGlzIHVzZWQgYmVjYXVzZSBpbiBGaXJlZm94LCBzdGFjayBpcyBub3QgYW4gb3duIHByb3BlcnR5XG4gICAgICAgIGVycm9yW2tleV0gPSB2YWx1ZVtrZXldLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSwge30pO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGxvZ2dlcihlcnJvciwgbG9nZ2luZykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeSh7XG4gICAgZXJyb3I6IGVycm9yXG4gIH0sIHJlcGxhY2VFcnJvcnMsIGxvZ2dpbmcgPT09IFwianNvblwiID8gMiA6IG51bGwpKTtcbiAgaWYgKGVycm9yLnByb3BlcnRpZXMgJiYgZXJyb3IucHJvcGVydGllcy5lcnJvcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHZhciBlcnJvck1lc3NhZ2VzID0gZXJyb3IucHJvcGVydGllcy5lcnJvcnMubWFwKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgcmV0dXJuIGVycm9yLnByb3BlcnRpZXMuZXhwbGFuYXRpb247XG4gICAgfSkuam9pbihcIlxcblwiKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKFwiZXJyb3JNZXNzYWdlc1wiLCBlcnJvck1lc3NhZ2VzKTtcbiAgICAvKlxuICAgICAqIGVycm9yTWVzc2FnZXMgaXMgYSBodW1hbmx5IHJlYWRhYmxlIG1lc3NhZ2UgbG9va2luZyBsaWtlIHRoaXMgOlxuICAgICAqICdUaGUgdGFnIGJlZ2lubmluZyB3aXRoIFwiZm9vYmFyXCIgaXMgdW5vcGVuZWQnXG4gICAgICovXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gbG9nZ2VyOyJdLCJuYW1lcyI6WyJfcmVxdWlyZSIsInJlcXVpcmUiLCJwdXNoQXJyYXkiLCJyZXBsYWNlRXJyb3JzIiwia2V5IiwidmFsdWUiLCJFcnJvciIsIk9iamVjdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJyZWR1Y2UiLCJlcnJvciIsInRvU3RyaW5nIiwibG9nZ2VyIiwibG9nZ2luZyIsImNvbnNvbGUiLCJsb2ciLCJKU09OIiwic3RyaW5naWZ5IiwicHJvcGVydGllcyIsImVycm9ycyIsIkFycmF5IiwiZXJyb3JNZXNzYWdlcyIsIm1hcCIsImV4cGxhbmF0aW9uIiwiam9pbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/error-logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/errors.js":
/*!*************************************************!*\
  !*** ./node_modules/docxtemplater/js/errors.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar _require = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/docxtemplater/js/utils.js\"), last = _require.last, first = _require.first;\nfunction XTError(message) {\n    this.name = \"GenericError\";\n    this.message = message;\n    this.stack = new Error(message).stack;\n}\nXTError.prototype = Error.prototype;\nfunction XTTemplateError(message) {\n    this.name = \"TemplateError\";\n    this.message = message;\n    this.stack = new Error(message).stack;\n}\nXTTemplateError.prototype = new XTError();\nfunction XTRenderingError(message) {\n    this.name = \"RenderingError\";\n    this.message = message;\n    this.stack = new Error(message).stack;\n}\nXTRenderingError.prototype = new XTError();\nfunction XTScopeParserError(message) {\n    this.name = \"ScopeParserError\";\n    this.message = message;\n    this.stack = new Error(message).stack;\n}\nXTScopeParserError.prototype = new XTError();\nfunction XTInternalError(message) {\n    this.name = \"InternalError\";\n    this.properties = {\n        explanation: \"InternalError\"\n    };\n    this.message = message;\n    this.stack = new Error(message).stack;\n}\nXTInternalError.prototype = new XTError();\nfunction XTAPIVersionError(message) {\n    this.name = \"APIVersionError\";\n    this.properties = {\n        explanation: \"APIVersionError\"\n    };\n    this.message = message;\n    this.stack = new Error(message).stack;\n}\nXTAPIVersionError.prototype = new XTError();\nfunction throwApiVersionError(msg, properties) {\n    var err = new XTAPIVersionError(msg);\n    err.properties = _objectSpread({\n        id: \"api_version_error\"\n    }, properties);\n    throw err;\n}\nfunction throwMultiError(errors) {\n    var err = new XTTemplateError(\"Multi error\");\n    err.properties = {\n        errors: errors,\n        id: \"multi_error\",\n        explanation: \"The template has multiple errors\"\n    };\n    throw err;\n}\nfunction getUnopenedTagException(options) {\n    var err = new XTTemplateError(\"Unopened tag\");\n    err.properties = {\n        xtag: last(options.xtag.split(\" \")),\n        id: \"unopened_tag\",\n        context: options.xtag,\n        offset: options.offset,\n        lIndex: options.lIndex,\n        explanation: 'The tag beginning with \"'.concat(options.xtag.substr(0, 10), '\" is unopened')\n    };\n    return err;\n}\nfunction getDuplicateOpenTagException(options) {\n    var err = new XTTemplateError(\"Duplicate open tag, expected one open tag\");\n    err.properties = {\n        xtag: first(options.xtag.split(\" \")),\n        id: \"duplicate_open_tag\",\n        context: options.xtag,\n        offset: options.offset,\n        lIndex: options.lIndex,\n        explanation: 'The tag beginning with \"'.concat(options.xtag.substr(0, 10), '\" has duplicate open tags')\n    };\n    return err;\n}\nfunction getDuplicateCloseTagException(options) {\n    var err = new XTTemplateError(\"Duplicate close tag, expected one close tag\");\n    err.properties = {\n        xtag: first(options.xtag.split(\" \")),\n        id: \"duplicate_close_tag\",\n        context: options.xtag,\n        offset: options.offset,\n        lIndex: options.lIndex,\n        explanation: 'The tag ending with \"'.concat(options.xtag.substr(0, 10), '\" has duplicate close tags')\n    };\n    return err;\n}\nfunction getUnclosedTagException(options) {\n    var err = new XTTemplateError(\"Unclosed tag\");\n    err.properties = {\n        xtag: first(options.xtag.split(\" \")).substr(1),\n        id: \"unclosed_tag\",\n        context: options.xtag,\n        offset: options.offset,\n        lIndex: options.lIndex,\n        explanation: 'The tag beginning with \"'.concat(options.xtag.substr(0, 10), '\" is unclosed')\n    };\n    return err;\n}\nfunction throwXmlTagNotFound(options) {\n    var err = new XTTemplateError('No tag \"'.concat(options.element, '\" was found at the ').concat(options.position));\n    var part = options.parsed[options.index];\n    err.properties = {\n        id: \"no_xml_tag_found_at_\".concat(options.position),\n        explanation: 'No tag \"'.concat(options.element, '\" was found at the ').concat(options.position),\n        offset: part.offset,\n        part: part,\n        parsed: options.parsed,\n        index: options.index,\n        element: options.element\n    };\n    throw err;\n}\nfunction getCorruptCharactersException(_ref) {\n    var tag = _ref.tag, value = _ref.value, offset = _ref.offset;\n    var err = new XTRenderingError(\"There are some XML corrupt characters\");\n    err.properties = {\n        id: \"invalid_xml_characters\",\n        xtag: tag,\n        value: value,\n        offset: offset,\n        explanation: \"There are some corrupt characters for the field \".concat(tag)\n    };\n    return err;\n}\nfunction getInvalidRawXMLValueException(_ref2) {\n    var tag = _ref2.tag, value = _ref2.value, offset = _ref2.offset;\n    var err = new XTRenderingError(\"Non string values are not allowed for rawXML tags\");\n    err.properties = {\n        id: \"invalid_raw_xml_value\",\n        xtag: tag,\n        value: value,\n        offset: offset,\n        explanation: \"The value of the raw tag : '\".concat(tag, \"' is not a string\")\n    };\n    return err;\n}\nfunction throwExpandNotFound(options) {\n    var _options$part = options.part, value = _options$part.value, offset = _options$part.offset, _options$id = options.id, id = _options$id === void 0 ? \"raw_tag_outerxml_invalid\" : _options$id, _options$message = options.message, message = _options$message === void 0 ? \"Raw tag not in paragraph\" : _options$message;\n    var part = options.part;\n    var _options$explanation = options.explanation, explanation = _options$explanation === void 0 ? 'The tag \"'.concat(value, '\" is not inside a paragraph') : _options$explanation;\n    if (typeof explanation === \"function\") {\n        explanation = explanation(part);\n    }\n    var err = new XTTemplateError(message);\n    err.properties = {\n        id: id,\n        explanation: explanation,\n        rootError: options.rootError,\n        xtag: value,\n        offset: offset,\n        postparsed: options.postparsed,\n        expandTo: options.expandTo,\n        index: options.index\n    };\n    throw err;\n}\nfunction throwRawTagShouldBeOnlyTextInParagraph(options) {\n    var err = new XTTemplateError(\"Raw tag should be the only text in paragraph\");\n    var tag = options.part.value;\n    err.properties = {\n        id: \"raw_xml_tag_should_be_only_text_in_paragraph\",\n        explanation: 'The raw tag \"'.concat(tag, '\" should be the only text in this paragraph. This means that this tag should not be surrounded by any text or spaces.'),\n        xtag: tag,\n        offset: options.part.offset,\n        paragraphParts: options.paragraphParts\n    };\n    throw err;\n}\nfunction getUnmatchedLoopException(part) {\n    var location = part.location, offset = part.offset, square = part.square;\n    var t = location === \"start\" ? \"unclosed\" : \"unopened\";\n    var T = location === \"start\" ? \"Unclosed\" : \"Unopened\";\n    var err = new XTTemplateError(\"\".concat(T, \" loop\"));\n    var tag = part.value;\n    err.properties = {\n        id: \"\".concat(t, \"_loop\"),\n        explanation: 'The loop with tag \"'.concat(tag, '\" is ').concat(t),\n        xtag: tag,\n        offset: offset\n    };\n    if (square) {\n        err.properties.square = square;\n    }\n    return err;\n}\nfunction getUnbalancedLoopException(pair, lastPair) {\n    var err = new XTTemplateError(\"Unbalanced loop tag\");\n    var lastL = lastPair[0].part.value;\n    var lastR = lastPair[1].part.value;\n    var l = pair[0].part.value;\n    var r = pair[1].part.value;\n    err.properties = {\n        id: \"unbalanced_loop_tags\",\n        explanation: \"Unbalanced loop tags {#\".concat(lastL, \"}{/\").concat(lastR, \"}{#\").concat(l, \"}{/\").concat(r, \"}\"),\n        offset: [\n            lastPair[0].part.offset,\n            pair[1].part.offset\n        ],\n        lastPair: {\n            left: lastPair[0].part.value,\n            right: lastPair[1].part.value\n        },\n        pair: {\n            left: pair[0].part.value,\n            right: pair[1].part.value\n        }\n    };\n    return err;\n}\nfunction getClosingTagNotMatchOpeningTag(_ref3) {\n    var tags = _ref3.tags;\n    var err = new XTTemplateError(\"Closing tag does not match opening tag\");\n    err.properties = {\n        id: \"closing_tag_does_not_match_opening_tag\",\n        explanation: 'The tag \"'.concat(tags[0].value, '\" is closed by the tag \"').concat(tags[1].value, '\"'),\n        openingtag: first(tags).value,\n        offset: [\n            first(tags).offset,\n            last(tags).offset\n        ],\n        closingtag: last(tags).value\n    };\n    return err;\n}\nfunction getScopeCompilationError(_ref4) {\n    var tag = _ref4.tag, rootError = _ref4.rootError, offset = _ref4.offset;\n    var err = new XTScopeParserError(\"Scope parser compilation failed\");\n    err.properties = {\n        id: \"scopeparser_compilation_failed\",\n        offset: offset,\n        xtag: tag,\n        explanation: 'The scope parser for the tag \"'.concat(tag, '\" failed to compile'),\n        rootError: rootError\n    };\n    return err;\n}\nfunction getScopeParserExecutionError(_ref5) {\n    var tag = _ref5.tag, scope = _ref5.scope, error = _ref5.error, offset = _ref5.offset;\n    var err = new XTScopeParserError(\"Scope parser execution failed\");\n    err.properties = {\n        id: \"scopeparser_execution_failed\",\n        explanation: \"The scope parser for the tag \".concat(tag, \" failed to execute\"),\n        scope: scope,\n        offset: offset,\n        xtag: tag,\n        rootError: error\n    };\n    return err;\n}\nfunction getLoopPositionProducesInvalidXMLError(_ref6) {\n    var tag = _ref6.tag, offset = _ref6.offset;\n    var err = new XTTemplateError('The position of the loop tags \"'.concat(tag, '\" would produce invalid XML'));\n    err.properties = {\n        xtag: tag,\n        id: \"loop_position_invalid\",\n        explanation: 'The tags \"'.concat(tag, '\" are misplaced in the document, for example one of them is in a table and the other one outside the table'),\n        offset: offset\n    };\n    return err;\n}\nfunction throwUnimplementedTagType(part, index) {\n    var errorMsg = 'Unimplemented tag type \"'.concat(part.type, '\"');\n    if (part.module) {\n        errorMsg += ' \"'.concat(part.module, '\"');\n    }\n    var err = new XTTemplateError(errorMsg);\n    err.properties = {\n        part: part,\n        index: index,\n        id: \"unimplemented_tag_type\"\n    };\n    throw err;\n}\nfunction throwMalformedXml() {\n    var err = new XTInternalError(\"Malformed xml\");\n    err.properties = {\n        explanation: \"The template contains malformed xml\",\n        id: \"malformed_xml\"\n    };\n    throw err;\n}\nfunction throwResolveBeforeCompile() {\n    var err = new XTInternalError(\"You must run `.compile()` before running `.resolveData()`\");\n    err.properties = {\n        id: \"resolve_before_compile\",\n        explanation: \"You must run `.compile()` before running `.resolveData()`\"\n    };\n    throw err;\n}\nfunction throwRenderInvalidTemplate() {\n    var err = new XTInternalError(\"You should not call .render on a document that had compilation errors\");\n    err.properties = {\n        id: \"render_on_invalid_template\",\n        explanation: \"You should not call .render on a document that had compilation errors\"\n    };\n    throw err;\n}\nfunction throwRenderTwice() {\n    var err = new XTInternalError(\"You should not call .render twice on the same docxtemplater instance\");\n    err.properties = {\n        id: \"render_twice\",\n        explanation: \"You should not call .render twice on the same docxtemplater instance\"\n    };\n    throw err;\n}\nfunction throwFileTypeNotIdentified(zip) {\n    var files = Object.keys(zip.files).slice(0, 10);\n    var msg = \"\";\n    if (files.length === 0) {\n        msg = \"Empty zip file\";\n    } else {\n        msg = \"Zip file contains : \".concat(files.join(\",\"));\n    }\n    var err = new XTInternalError(\"The filetype for this file could not be identified, is this file corrupted ? \".concat(msg));\n    err.properties = {\n        id: \"filetype_not_identified\",\n        explanation: \"The filetype for this file could not be identified, is this file corrupted ? \".concat(msg)\n    };\n    throw err;\n}\nfunction throwXmlInvalid(content, offset) {\n    var err = new XTTemplateError(\"An XML file has invalid xml\");\n    err.properties = {\n        id: \"file_has_invalid_xml\",\n        content: content,\n        offset: offset,\n        explanation: \"The docx contains invalid XML, it is most likely corrupt\"\n    };\n    throw err;\n}\nfunction throwFileTypeNotHandled(fileType) {\n    var err = new XTInternalError('The filetype \"'.concat(fileType, '\" is not handled by docxtemplater'));\n    err.properties = {\n        id: \"filetype_not_handled\",\n        explanation: 'The file you are trying to generate is of type \"'.concat(fileType, '\", but only docx and pptx formats are handled'),\n        fileType: fileType\n    };\n    throw err;\n}\nmodule.exports = {\n    XTError: XTError,\n    XTTemplateError: XTTemplateError,\n    XTInternalError: XTInternalError,\n    XTScopeParserError: XTScopeParserError,\n    XTAPIVersionError: XTAPIVersionError,\n    // Remove this alias in v4\n    RenderingError: XTRenderingError,\n    XTRenderingError: XTRenderingError,\n    getClosingTagNotMatchOpeningTag: getClosingTagNotMatchOpeningTag,\n    getLoopPositionProducesInvalidXMLError: getLoopPositionProducesInvalidXMLError,\n    getScopeCompilationError: getScopeCompilationError,\n    getScopeParserExecutionError: getScopeParserExecutionError,\n    getUnclosedTagException: getUnclosedTagException,\n    getUnopenedTagException: getUnopenedTagException,\n    getUnmatchedLoopException: getUnmatchedLoopException,\n    getDuplicateCloseTagException: getDuplicateCloseTagException,\n    getDuplicateOpenTagException: getDuplicateOpenTagException,\n    getCorruptCharactersException: getCorruptCharactersException,\n    getInvalidRawXMLValueException: getInvalidRawXMLValueException,\n    getUnbalancedLoopException: getUnbalancedLoopException,\n    throwApiVersionError: throwApiVersionError,\n    throwFileTypeNotHandled: throwFileTypeNotHandled,\n    throwFileTypeNotIdentified: throwFileTypeNotIdentified,\n    throwMalformedXml: throwMalformedXml,\n    throwMultiError: throwMultiError,\n    throwExpandNotFound: throwExpandNotFound,\n    throwRawTagShouldBeOnlyTextInParagraph: throwRawTagShouldBeOnlyTextInParagraph,\n    throwUnimplementedTagType: throwUnimplementedTagType,\n    throwXmlTagNotFound: throwXmlTagNotFound,\n    throwXmlInvalid: throwXmlInvalid,\n    throwResolveBeforeCompile: throwResolveBeforeCompile,\n    throwRenderInvalidTemplate: throwRenderInvalidTemplate,\n    throwRenderTwice: throwRenderTwice\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRUcsV0FBVyxLQUFLRixVQUFVRCxNQUFNQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1QsU0FBU0ssUUFBUUMsQ0FBQyxFQUFFQyxDQUFDO0lBQUksSUFBSUMsSUFBSUMsT0FBT0MsSUFBSSxDQUFDSjtJQUFJLElBQUlHLE9BQU9FLHFCQUFxQixFQUFFO1FBQUUsSUFBSVgsSUFBSVMsT0FBT0UscUJBQXFCLENBQUNMO1FBQUlDLEtBQU1QLENBQUFBLElBQUlBLEVBQUVZLE1BQU0sQ0FBQyxTQUFVTCxDQUFDO1lBQUksT0FBT0UsT0FBT0ksd0JBQXdCLENBQUNQLEdBQUdDLEdBQUdPLFVBQVU7UUFBRSxFQUFDLEdBQUlOLEVBQUVPLElBQUksQ0FBQ0MsS0FBSyxDQUFDUixHQUFHUjtJQUFJO0lBQUUsT0FBT1E7QUFBRztBQUM5UCxTQUFTUyxjQUFjWCxDQUFDO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlXLFVBQVVDLE1BQU0sRUFBRVosSUFBSztRQUFFLElBQUlDLElBQUksUUFBUVUsU0FBUyxDQUFDWCxFQUFFLEdBQUdXLFNBQVMsQ0FBQ1gsRUFBRSxHQUFHLENBQUM7UUFBR0EsSUFBSSxJQUFJRixRQUFRSSxPQUFPRCxJQUFJLENBQUMsR0FBR1ksT0FBTyxDQUFDLFNBQVViLENBQUM7WUFBSWMsZ0JBQWdCZixHQUFHQyxHQUFHQyxDQUFDLENBQUNELEVBQUU7UUFBRyxLQUFL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aWtlLXJlbnRhbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZXJyb3JzLmpzPzJhNTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIiksXG4gIGxhc3QgPSBfcmVxdWlyZS5sYXN0LFxuICBmaXJzdCA9IF9yZXF1aXJlLmZpcnN0O1xuZnVuY3Rpb24gWFRFcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9IFwiR2VuZXJpY0Vycm9yXCI7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IobWVzc2FnZSkuc3RhY2s7XG59XG5YVEVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcbmZ1bmN0aW9uIFhUVGVtcGxhdGVFcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9IFwiVGVtcGxhdGVFcnJvclwiO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKG1lc3NhZ2UpLnN0YWNrO1xufVxuWFRUZW1wbGF0ZUVycm9yLnByb3RvdHlwZSA9IG5ldyBYVEVycm9yKCk7XG5mdW5jdGlvbiBYVFJlbmRlcmluZ0Vycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gXCJSZW5kZXJpbmdFcnJvclwiO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKG1lc3NhZ2UpLnN0YWNrO1xufVxuWFRSZW5kZXJpbmdFcnJvci5wcm90b3R5cGUgPSBuZXcgWFRFcnJvcigpO1xuZnVuY3Rpb24gWFRTY29wZVBhcnNlckVycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gXCJTY29wZVBhcnNlckVycm9yXCI7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IobWVzc2FnZSkuc3RhY2s7XG59XG5YVFNjb3BlUGFyc2VyRXJyb3IucHJvdG90eXBlID0gbmV3IFhURXJyb3IoKTtcbmZ1bmN0aW9uIFhUSW50ZXJuYWxFcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9IFwiSW50ZXJuYWxFcnJvclwiO1xuICB0aGlzLnByb3BlcnRpZXMgPSB7XG4gICAgZXhwbGFuYXRpb246IFwiSW50ZXJuYWxFcnJvclwiXG4gIH07XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IobWVzc2FnZSkuc3RhY2s7XG59XG5YVEludGVybmFsRXJyb3IucHJvdG90eXBlID0gbmV3IFhURXJyb3IoKTtcbmZ1bmN0aW9uIFhUQVBJVmVyc2lvbkVycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gXCJBUElWZXJzaW9uRXJyb3JcIjtcbiAgdGhpcy5wcm9wZXJ0aWVzID0ge1xuICAgIGV4cGxhbmF0aW9uOiBcIkFQSVZlcnNpb25FcnJvclwiXG4gIH07XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IobWVzc2FnZSkuc3RhY2s7XG59XG5YVEFQSVZlcnNpb25FcnJvci5wcm90b3R5cGUgPSBuZXcgWFRFcnJvcigpO1xuZnVuY3Rpb24gdGhyb3dBcGlWZXJzaW9uRXJyb3IobXNnLCBwcm9wZXJ0aWVzKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRBUElWZXJzaW9uRXJyb3IobXNnKTtcbiAgZXJyLnByb3BlcnRpZXMgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICBpZDogXCJhcGlfdmVyc2lvbl9lcnJvclwiXG4gIH0sIHByb3BlcnRpZXMpO1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd011bHRpRXJyb3IoZXJyb3JzKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiTXVsdGkgZXJyb3JcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGVycm9yczogZXJyb3JzLFxuICAgIGlkOiBcIm11bHRpX2Vycm9yXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHRlbXBsYXRlIGhhcyBtdWx0aXBsZSBlcnJvcnNcIlxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiBnZXRVbm9wZW5lZFRhZ0V4Y2VwdGlvbihvcHRpb25zKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiVW5vcGVuZWQgdGFnXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICB4dGFnOiBsYXN0KG9wdGlvbnMueHRhZy5zcGxpdChcIiBcIikpLFxuICAgIGlkOiBcInVub3BlbmVkX3RhZ1wiLFxuICAgIGNvbnRleHQ6IG9wdGlvbnMueHRhZyxcbiAgICBvZmZzZXQ6IG9wdGlvbnMub2Zmc2V0LFxuICAgIGxJbmRleDogb3B0aW9ucy5sSW5kZXgsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHRhZyBiZWdpbm5pbmcgd2l0aCBcXFwiXCIuY29uY2F0KG9wdGlvbnMueHRhZy5zdWJzdHIoMCwgMTApLCBcIlxcXCIgaXMgdW5vcGVuZWRcIilcbiAgfTtcbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIGdldER1cGxpY2F0ZU9wZW5UYWdFeGNlcHRpb24ob3B0aW9ucykge1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIkR1cGxpY2F0ZSBvcGVuIHRhZywgZXhwZWN0ZWQgb25lIG9wZW4gdGFnXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICB4dGFnOiBmaXJzdChvcHRpb25zLnh0YWcuc3BsaXQoXCIgXCIpKSxcbiAgICBpZDogXCJkdXBsaWNhdGVfb3Blbl90YWdcIixcbiAgICBjb250ZXh0OiBvcHRpb25zLnh0YWcsXG4gICAgb2Zmc2V0OiBvcHRpb25zLm9mZnNldCxcbiAgICBsSW5kZXg6IG9wdGlvbnMubEluZGV4LFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSB0YWcgYmVnaW5uaW5nIHdpdGggXFxcIlwiLmNvbmNhdChvcHRpb25zLnh0YWcuc3Vic3RyKDAsIDEwKSwgXCJcXFwiIGhhcyBkdXBsaWNhdGUgb3BlbiB0YWdzXCIpXG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiBnZXREdXBsaWNhdGVDbG9zZVRhZ0V4Y2VwdGlvbihvcHRpb25zKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiRHVwbGljYXRlIGNsb3NlIHRhZywgZXhwZWN0ZWQgb25lIGNsb3NlIHRhZ1wiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgeHRhZzogZmlyc3Qob3B0aW9ucy54dGFnLnNwbGl0KFwiIFwiKSksXG4gICAgaWQ6IFwiZHVwbGljYXRlX2Nsb3NlX3RhZ1wiLFxuICAgIGNvbnRleHQ6IG9wdGlvbnMueHRhZyxcbiAgICBvZmZzZXQ6IG9wdGlvbnMub2Zmc2V0LFxuICAgIGxJbmRleDogb3B0aW9ucy5sSW5kZXgsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHRhZyBlbmRpbmcgd2l0aCBcXFwiXCIuY29uY2F0KG9wdGlvbnMueHRhZy5zdWJzdHIoMCwgMTApLCBcIlxcXCIgaGFzIGR1cGxpY2F0ZSBjbG9zZSB0YWdzXCIpXG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiBnZXRVbmNsb3NlZFRhZ0V4Y2VwdGlvbihvcHRpb25zKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiVW5jbG9zZWQgdGFnXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICB4dGFnOiBmaXJzdChvcHRpb25zLnh0YWcuc3BsaXQoXCIgXCIpKS5zdWJzdHIoMSksXG4gICAgaWQ6IFwidW5jbG9zZWRfdGFnXCIsXG4gICAgY29udGV4dDogb3B0aW9ucy54dGFnLFxuICAgIG9mZnNldDogb3B0aW9ucy5vZmZzZXQsXG4gICAgbEluZGV4OiBvcHRpb25zLmxJbmRleCxcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgdGFnIGJlZ2lubmluZyB3aXRoIFxcXCJcIi5jb25jYXQob3B0aW9ucy54dGFnLnN1YnN0cigwLCAxMCksIFwiXFxcIiBpcyB1bmNsb3NlZFwiKVxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dYbWxUYWdOb3RGb3VuZChvcHRpb25zKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiTm8gdGFnIFxcXCJcIi5jb25jYXQob3B0aW9ucy5lbGVtZW50LCBcIlxcXCIgd2FzIGZvdW5kIGF0IHRoZSBcIikuY29uY2F0KG9wdGlvbnMucG9zaXRpb24pKTtcbiAgdmFyIHBhcnQgPSBvcHRpb25zLnBhcnNlZFtvcHRpb25zLmluZGV4XTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwibm9feG1sX3RhZ19mb3VuZF9hdF9cIi5jb25jYXQob3B0aW9ucy5wb3NpdGlvbiksXG4gICAgZXhwbGFuYXRpb246IFwiTm8gdGFnIFxcXCJcIi5jb25jYXQob3B0aW9ucy5lbGVtZW50LCBcIlxcXCIgd2FzIGZvdW5kIGF0IHRoZSBcIikuY29uY2F0KG9wdGlvbnMucG9zaXRpb24pLFxuICAgIG9mZnNldDogcGFydC5vZmZzZXQsXG4gICAgcGFydDogcGFydCxcbiAgICBwYXJzZWQ6IG9wdGlvbnMucGFyc2VkLFxuICAgIGluZGV4OiBvcHRpb25zLmluZGV4LFxuICAgIGVsZW1lbnQ6IG9wdGlvbnMuZWxlbWVudFxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiBnZXRDb3JydXB0Q2hhcmFjdGVyc0V4Y2VwdGlvbihfcmVmKSB7XG4gIHZhciB0YWcgPSBfcmVmLnRhZyxcbiAgICB2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG4gIHZhciBlcnIgPSBuZXcgWFRSZW5kZXJpbmdFcnJvcihcIlRoZXJlIGFyZSBzb21lIFhNTCBjb3JydXB0IGNoYXJhY3RlcnNcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcImludmFsaWRfeG1sX2NoYXJhY3RlcnNcIixcbiAgICB4dGFnOiB0YWcsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZXJlIGFyZSBzb21lIGNvcnJ1cHQgY2hhcmFjdGVycyBmb3IgdGhlIGZpZWxkIFwiLmNvbmNhdCh0YWcpXG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiBnZXRJbnZhbGlkUmF3WE1MVmFsdWVFeGNlcHRpb24oX3JlZjIpIHtcbiAgdmFyIHRhZyA9IF9yZWYyLnRhZyxcbiAgICB2YWx1ZSA9IF9yZWYyLnZhbHVlLFxuICAgIG9mZnNldCA9IF9yZWYyLm9mZnNldDtcbiAgdmFyIGVyciA9IG5ldyBYVFJlbmRlcmluZ0Vycm9yKFwiTm9uIHN0cmluZyB2YWx1ZXMgYXJlIG5vdCBhbGxvd2VkIGZvciByYXdYTUwgdGFnc1wiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwiaW52YWxpZF9yYXdfeG1sX3ZhbHVlXCIsXG4gICAgeHRhZzogdGFnLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgdmFsdWUgb2YgdGhlIHJhdyB0YWcgOiAnXCIuY29uY2F0KHRhZywgXCInIGlzIG5vdCBhIHN0cmluZ1wiKVxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dFeHBhbmROb3RGb3VuZChvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRwYXJ0ID0gb3B0aW9ucy5wYXJ0LFxuICAgIHZhbHVlID0gX29wdGlvbnMkcGFydC52YWx1ZSxcbiAgICBvZmZzZXQgPSBfb3B0aW9ucyRwYXJ0Lm9mZnNldCxcbiAgICBfb3B0aW9ucyRpZCA9IG9wdGlvbnMuaWQsXG4gICAgaWQgPSBfb3B0aW9ucyRpZCA9PT0gdm9pZCAwID8gXCJyYXdfdGFnX291dGVyeG1sX2ludmFsaWRcIiA6IF9vcHRpb25zJGlkLFxuICAgIF9vcHRpb25zJG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UsXG4gICAgbWVzc2FnZSA9IF9vcHRpb25zJG1lc3NhZ2UgPT09IHZvaWQgMCA/IFwiUmF3IHRhZyBub3QgaW4gcGFyYWdyYXBoXCIgOiBfb3B0aW9ucyRtZXNzYWdlO1xuICB2YXIgcGFydCA9IG9wdGlvbnMucGFydDtcbiAgdmFyIF9vcHRpb25zJGV4cGxhbmF0aW9uID0gb3B0aW9ucy5leHBsYW5hdGlvbixcbiAgICBleHBsYW5hdGlvbiA9IF9vcHRpb25zJGV4cGxhbmF0aW9uID09PSB2b2lkIDAgPyBcIlRoZSB0YWcgXFxcIlwiLmNvbmNhdCh2YWx1ZSwgXCJcXFwiIGlzIG5vdCBpbnNpZGUgYSBwYXJhZ3JhcGhcIikgOiBfb3B0aW9ucyRleHBsYW5hdGlvbjtcbiAgaWYgKHR5cGVvZiBleHBsYW5hdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZXhwbGFuYXRpb24gPSBleHBsYW5hdGlvbihwYXJ0KTtcbiAgfVxuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihtZXNzYWdlKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IGlkLFxuICAgIGV4cGxhbmF0aW9uOiBleHBsYW5hdGlvbixcbiAgICByb290RXJyb3I6IG9wdGlvbnMucm9vdEVycm9yLFxuICAgIHh0YWc6IHZhbHVlLFxuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIHBvc3RwYXJzZWQ6IG9wdGlvbnMucG9zdHBhcnNlZCxcbiAgICBleHBhbmRUbzogb3B0aW9ucy5leHBhbmRUbyxcbiAgICBpbmRleDogb3B0aW9ucy5pbmRleFxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd1Jhd1RhZ1Nob3VsZEJlT25seVRleHRJblBhcmFncmFwaChvcHRpb25zKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiUmF3IHRhZyBzaG91bGQgYmUgdGhlIG9ubHkgdGV4dCBpbiBwYXJhZ3JhcGhcIik7XG4gIHZhciB0YWcgPSBvcHRpb25zLnBhcnQudmFsdWU7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcInJhd194bWxfdGFnX3Nob3VsZF9iZV9vbmx5X3RleHRfaW5fcGFyYWdyYXBoXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHJhdyB0YWcgXFxcIlwiLmNvbmNhdCh0YWcsIFwiXFxcIiBzaG91bGQgYmUgdGhlIG9ubHkgdGV4dCBpbiB0aGlzIHBhcmFncmFwaC4gVGhpcyBtZWFucyB0aGF0IHRoaXMgdGFnIHNob3VsZCBub3QgYmUgc3Vycm91bmRlZCBieSBhbnkgdGV4dCBvciBzcGFjZXMuXCIpLFxuICAgIHh0YWc6IHRhZyxcbiAgICBvZmZzZXQ6IG9wdGlvbnMucGFydC5vZmZzZXQsXG4gICAgcGFyYWdyYXBoUGFydHM6IG9wdGlvbnMucGFyYWdyYXBoUGFydHNcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gZ2V0VW5tYXRjaGVkTG9vcEV4Y2VwdGlvbihwYXJ0KSB7XG4gIHZhciBsb2NhdGlvbiA9IHBhcnQubG9jYXRpb24sXG4gICAgb2Zmc2V0ID0gcGFydC5vZmZzZXQsXG4gICAgc3F1YXJlID0gcGFydC5zcXVhcmU7XG4gIHZhciB0ID0gbG9jYXRpb24gPT09IFwic3RhcnRcIiA/IFwidW5jbG9zZWRcIiA6IFwidW5vcGVuZWRcIjtcbiAgdmFyIFQgPSBsb2NhdGlvbiA9PT0gXCJzdGFydFwiID8gXCJVbmNsb3NlZFwiIDogXCJVbm9wZW5lZFwiO1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIlwiLmNvbmNhdChULCBcIiBsb29wXCIpKTtcbiAgdmFyIHRhZyA9IHBhcnQudmFsdWU7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcIlwiLmNvbmNhdCh0LCBcIl9sb29wXCIpLFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSBsb29wIHdpdGggdGFnIFxcXCJcIi5jb25jYXQodGFnLCBcIlxcXCIgaXMgXCIpLmNvbmNhdCh0KSxcbiAgICB4dGFnOiB0YWcsXG4gICAgb2Zmc2V0OiBvZmZzZXRcbiAgfTtcbiAgaWYgKHNxdWFyZSkge1xuICAgIGVyci5wcm9wZXJ0aWVzLnNxdWFyZSA9IHNxdWFyZTtcbiAgfVxuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gZ2V0VW5iYWxhbmNlZExvb3BFeGNlcHRpb24ocGFpciwgbGFzdFBhaXIpIHtcbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJVbmJhbGFuY2VkIGxvb3AgdGFnXCIpO1xuICB2YXIgbGFzdEwgPSBsYXN0UGFpclswXS5wYXJ0LnZhbHVlO1xuICB2YXIgbGFzdFIgPSBsYXN0UGFpclsxXS5wYXJ0LnZhbHVlO1xuICB2YXIgbCA9IHBhaXJbMF0ucGFydC52YWx1ZTtcbiAgdmFyIHIgPSBwYWlyWzFdLnBhcnQudmFsdWU7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcInVuYmFsYW5jZWRfbG9vcF90YWdzXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVW5iYWxhbmNlZCBsb29wIHRhZ3MgeyNcIi5jb25jYXQobGFzdEwsIFwifXsvXCIpLmNvbmNhdChsYXN0UiwgXCJ9eyNcIikuY29uY2F0KGwsIFwifXsvXCIpLmNvbmNhdChyLCBcIn1cIiksXG4gICAgb2Zmc2V0OiBbbGFzdFBhaXJbMF0ucGFydC5vZmZzZXQsIHBhaXJbMV0ucGFydC5vZmZzZXRdLFxuICAgIGxhc3RQYWlyOiB7XG4gICAgICBsZWZ0OiBsYXN0UGFpclswXS5wYXJ0LnZhbHVlLFxuICAgICAgcmlnaHQ6IGxhc3RQYWlyWzFdLnBhcnQudmFsdWVcbiAgICB9LFxuICAgIHBhaXI6IHtcbiAgICAgIGxlZnQ6IHBhaXJbMF0ucGFydC52YWx1ZSxcbiAgICAgIHJpZ2h0OiBwYWlyWzFdLnBhcnQudmFsdWVcbiAgICB9XG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiBnZXRDbG9zaW5nVGFnTm90TWF0Y2hPcGVuaW5nVGFnKF9yZWYzKSB7XG4gIHZhciB0YWdzID0gX3JlZjMudGFncztcbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJDbG9zaW5nIHRhZyBkb2VzIG5vdCBtYXRjaCBvcGVuaW5nIHRhZ1wiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwiY2xvc2luZ190YWdfZG9lc19ub3RfbWF0Y2hfb3BlbmluZ190YWdcIixcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgdGFnIFxcXCJcIi5jb25jYXQodGFnc1swXS52YWx1ZSwgXCJcXFwiIGlzIGNsb3NlZCBieSB0aGUgdGFnIFxcXCJcIikuY29uY2F0KHRhZ3NbMV0udmFsdWUsIFwiXFxcIlwiKSxcbiAgICBvcGVuaW5ndGFnOiBmaXJzdCh0YWdzKS52YWx1ZSxcbiAgICBvZmZzZXQ6IFtmaXJzdCh0YWdzKS5vZmZzZXQsIGxhc3QodGFncykub2Zmc2V0XSxcbiAgICBjbG9zaW5ndGFnOiBsYXN0KHRhZ3MpLnZhbHVlXG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiBnZXRTY29wZUNvbXBpbGF0aW9uRXJyb3IoX3JlZjQpIHtcbiAgdmFyIHRhZyA9IF9yZWY0LnRhZyxcbiAgICByb290RXJyb3IgPSBfcmVmNC5yb290RXJyb3IsXG4gICAgb2Zmc2V0ID0gX3JlZjQub2Zmc2V0O1xuICB2YXIgZXJyID0gbmV3IFhUU2NvcGVQYXJzZXJFcnJvcihcIlNjb3BlIHBhcnNlciBjb21waWxhdGlvbiBmYWlsZWRcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcInNjb3BlcGFyc2VyX2NvbXBpbGF0aW9uX2ZhaWxlZFwiLFxuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIHh0YWc6IHRhZyxcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgc2NvcGUgcGFyc2VyIGZvciB0aGUgdGFnIFxcXCJcIi5jb25jYXQodGFnLCBcIlxcXCIgZmFpbGVkIHRvIGNvbXBpbGVcIiksXG4gICAgcm9vdEVycm9yOiByb290RXJyb3JcbiAgfTtcbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIGdldFNjb3BlUGFyc2VyRXhlY3V0aW9uRXJyb3IoX3JlZjUpIHtcbiAgdmFyIHRhZyA9IF9yZWY1LnRhZyxcbiAgICBzY29wZSA9IF9yZWY1LnNjb3BlLFxuICAgIGVycm9yID0gX3JlZjUuZXJyb3IsXG4gICAgb2Zmc2V0ID0gX3JlZjUub2Zmc2V0O1xuICB2YXIgZXJyID0gbmV3IFhUU2NvcGVQYXJzZXJFcnJvcihcIlNjb3BlIHBhcnNlciBleGVjdXRpb24gZmFpbGVkXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJzY29wZXBhcnNlcl9leGVjdXRpb25fZmFpbGVkXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHNjb3BlIHBhcnNlciBmb3IgdGhlIHRhZyBcIi5jb25jYXQodGFnLCBcIiBmYWlsZWQgdG8gZXhlY3V0ZVwiKSxcbiAgICBzY29wZTogc2NvcGUsXG4gICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgeHRhZzogdGFnLFxuICAgIHJvb3RFcnJvcjogZXJyb3JcbiAgfTtcbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIGdldExvb3BQb3NpdGlvblByb2R1Y2VzSW52YWxpZFhNTEVycm9yKF9yZWY2KSB7XG4gIHZhciB0YWcgPSBfcmVmNi50YWcsXG4gICAgb2Zmc2V0ID0gX3JlZjYub2Zmc2V0O1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIlRoZSBwb3NpdGlvbiBvZiB0aGUgbG9vcCB0YWdzIFxcXCJcIi5jb25jYXQodGFnLCBcIlxcXCIgd291bGQgcHJvZHVjZSBpbnZhbGlkIFhNTFwiKSk7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIHh0YWc6IHRhZyxcbiAgICBpZDogXCJsb29wX3Bvc2l0aW9uX2ludmFsaWRcIixcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgdGFncyBcXFwiXCIuY29uY2F0KHRhZywgXCJcXFwiIGFyZSBtaXNwbGFjZWQgaW4gdGhlIGRvY3VtZW50LCBmb3IgZXhhbXBsZSBvbmUgb2YgdGhlbSBpcyBpbiBhIHRhYmxlIGFuZCB0aGUgb3RoZXIgb25lIG91dHNpZGUgdGhlIHRhYmxlXCIpLFxuICAgIG9mZnNldDogb2Zmc2V0XG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd1VuaW1wbGVtZW50ZWRUYWdUeXBlKHBhcnQsIGluZGV4KSB7XG4gIHZhciBlcnJvck1zZyA9IFwiVW5pbXBsZW1lbnRlZCB0YWcgdHlwZSBcXFwiXCIuY29uY2F0KHBhcnQudHlwZSwgXCJcXFwiXCIpO1xuICBpZiAocGFydC5tb2R1bGUpIHtcbiAgICBlcnJvck1zZyArPSBcIiBcXFwiXCIuY29uY2F0KHBhcnQubW9kdWxlLCBcIlxcXCJcIik7XG4gIH1cbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoZXJyb3JNc2cpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBwYXJ0OiBwYXJ0LFxuICAgIGluZGV4OiBpbmRleCxcbiAgICBpZDogXCJ1bmltcGxlbWVudGVkX3RhZ190eXBlXCJcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dNYWxmb3JtZWRYbWwoKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRJbnRlcm5hbEVycm9yKFwiTWFsZm9ybWVkIHhtbFwiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHRlbXBsYXRlIGNvbnRhaW5zIG1hbGZvcm1lZCB4bWxcIixcbiAgICBpZDogXCJtYWxmb3JtZWRfeG1sXCJcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dSZXNvbHZlQmVmb3JlQ29tcGlsZSgpIHtcbiAgdmFyIGVyciA9IG5ldyBYVEludGVybmFsRXJyb3IoXCJZb3UgbXVzdCBydW4gYC5jb21waWxlKClgIGJlZm9yZSBydW5uaW5nIGAucmVzb2x2ZURhdGEoKWBcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcInJlc29sdmVfYmVmb3JlX2NvbXBpbGVcIixcbiAgICBleHBsYW5hdGlvbjogXCJZb3UgbXVzdCBydW4gYC5jb21waWxlKClgIGJlZm9yZSBydW5uaW5nIGAucmVzb2x2ZURhdGEoKWBcIlxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd1JlbmRlckludmFsaWRUZW1wbGF0ZSgpIHtcbiAgdmFyIGVyciA9IG5ldyBYVEludGVybmFsRXJyb3IoXCJZb3Ugc2hvdWxkIG5vdCBjYWxsIC5yZW5kZXIgb24gYSBkb2N1bWVudCB0aGF0IGhhZCBjb21waWxhdGlvbiBlcnJvcnNcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcInJlbmRlcl9vbl9pbnZhbGlkX3RlbXBsYXRlXCIsXG4gICAgZXhwbGFuYXRpb246IFwiWW91IHNob3VsZCBub3QgY2FsbCAucmVuZGVyIG9uIGEgZG9jdW1lbnQgdGhhdCBoYWQgY29tcGlsYXRpb24gZXJyb3JzXCJcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dSZW5kZXJUd2ljZSgpIHtcbiAgdmFyIGVyciA9IG5ldyBYVEludGVybmFsRXJyb3IoXCJZb3Ugc2hvdWxkIG5vdCBjYWxsIC5yZW5kZXIgdHdpY2Ugb24gdGhlIHNhbWUgZG9jeHRlbXBsYXRlciBpbnN0YW5jZVwiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwicmVuZGVyX3R3aWNlXCIsXG4gICAgZXhwbGFuYXRpb246IFwiWW91IHNob3VsZCBub3QgY2FsbCAucmVuZGVyIHR3aWNlIG9uIHRoZSBzYW1lIGRvY3h0ZW1wbGF0ZXIgaW5zdGFuY2VcIlxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd0ZpbGVUeXBlTm90SWRlbnRpZmllZCh6aXApIHtcbiAgdmFyIGZpbGVzID0gT2JqZWN0LmtleXMoemlwLmZpbGVzKS5zbGljZSgwLCAxMCk7XG4gIHZhciBtc2cgPSBcIlwiO1xuICBpZiAoZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgbXNnID0gXCJFbXB0eSB6aXAgZmlsZVwiO1xuICB9IGVsc2Uge1xuICAgIG1zZyA9IFwiWmlwIGZpbGUgY29udGFpbnMgOiBcIi5jb25jYXQoZmlsZXMuam9pbihcIixcIikpO1xuICB9XG4gIHZhciBlcnIgPSBuZXcgWFRJbnRlcm5hbEVycm9yKFwiVGhlIGZpbGV0eXBlIGZvciB0aGlzIGZpbGUgY291bGQgbm90IGJlIGlkZW50aWZpZWQsIGlzIHRoaXMgZmlsZSBjb3JydXB0ZWQgPyBcIi5jb25jYXQobXNnKSk7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcImZpbGV0eXBlX25vdF9pZGVudGlmaWVkXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIGZpbGV0eXBlIGZvciB0aGlzIGZpbGUgY291bGQgbm90IGJlIGlkZW50aWZpZWQsIGlzIHRoaXMgZmlsZSBjb3JydXB0ZWQgPyBcIi5jb25jYXQobXNnKVxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd1htbEludmFsaWQoY29udGVudCwgb2Zmc2V0KSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiQW4gWE1MIGZpbGUgaGFzIGludmFsaWQgeG1sXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJmaWxlX2hhc19pbnZhbGlkX3htbFwiLFxuICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIGRvY3ggY29udGFpbnMgaW52YWxpZCBYTUwsIGl0IGlzIG1vc3QgbGlrZWx5IGNvcnJ1cHRcIlxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd0ZpbGVUeXBlTm90SGFuZGxlZChmaWxlVHlwZSkge1xuICB2YXIgZXJyID0gbmV3IFhUSW50ZXJuYWxFcnJvcihcIlRoZSBmaWxldHlwZSBcXFwiXCIuY29uY2F0KGZpbGVUeXBlLCBcIlxcXCIgaXMgbm90IGhhbmRsZWQgYnkgZG9jeHRlbXBsYXRlclwiKSk7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcImZpbGV0eXBlX25vdF9oYW5kbGVkXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIGZpbGUgeW91IGFyZSB0cnlpbmcgdG8gZ2VuZXJhdGUgaXMgb2YgdHlwZSBcXFwiXCIuY29uY2F0KGZpbGVUeXBlLCBcIlxcXCIsIGJ1dCBvbmx5IGRvY3ggYW5kIHBwdHggZm9ybWF0cyBhcmUgaGFuZGxlZFwiKSxcbiAgICBmaWxlVHlwZTogZmlsZVR5cGVcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFhURXJyb3I6IFhURXJyb3IsXG4gIFhUVGVtcGxhdGVFcnJvcjogWFRUZW1wbGF0ZUVycm9yLFxuICBYVEludGVybmFsRXJyb3I6IFhUSW50ZXJuYWxFcnJvcixcbiAgWFRTY29wZVBhcnNlckVycm9yOiBYVFNjb3BlUGFyc2VyRXJyb3IsXG4gIFhUQVBJVmVyc2lvbkVycm9yOiBYVEFQSVZlcnNpb25FcnJvcixcbiAgLy8gUmVtb3ZlIHRoaXMgYWxpYXMgaW4gdjRcbiAgUmVuZGVyaW5nRXJyb3I6IFhUUmVuZGVyaW5nRXJyb3IsXG4gIFhUUmVuZGVyaW5nRXJyb3I6IFhUUmVuZGVyaW5nRXJyb3IsXG4gIGdldENsb3NpbmdUYWdOb3RNYXRjaE9wZW5pbmdUYWc6IGdldENsb3NpbmdUYWdOb3RNYXRjaE9wZW5pbmdUYWcsXG4gIGdldExvb3BQb3NpdGlvblByb2R1Y2VzSW52YWxpZFhNTEVycm9yOiBnZXRMb29wUG9zaXRpb25Qcm9kdWNlc0ludmFsaWRYTUxFcnJvcixcbiAgZ2V0U2NvcGVDb21waWxhdGlvbkVycm9yOiBnZXRTY29wZUNvbXBpbGF0aW9uRXJyb3IsXG4gIGdldFNjb3BlUGFyc2VyRXhlY3V0aW9uRXJyb3I6IGdldFNjb3BlUGFyc2VyRXhlY3V0aW9uRXJyb3IsXG4gIGdldFVuY2xvc2VkVGFnRXhjZXB0aW9uOiBnZXRVbmNsb3NlZFRhZ0V4Y2VwdGlvbixcbiAgZ2V0VW5vcGVuZWRUYWdFeGNlcHRpb246IGdldFVub3BlbmVkVGFnRXhjZXB0aW9uLFxuICBnZXRVbm1hdGNoZWRMb29wRXhjZXB0aW9uOiBnZXRVbm1hdGNoZWRMb29wRXhjZXB0aW9uLFxuICBnZXREdXBsaWNhdGVDbG9zZVRhZ0V4Y2VwdGlvbjogZ2V0RHVwbGljYXRlQ2xvc2VUYWdFeGNlcHRpb24sXG4gIGdldER1cGxpY2F0ZU9wZW5UYWdFeGNlcHRpb246IGdldER1cGxpY2F0ZU9wZW5UYWdFeGNlcHRpb24sXG4gIGdldENvcnJ1cHRDaGFyYWN0ZXJzRXhjZXB0aW9uOiBnZXRDb3JydXB0Q2hhcmFjdGVyc0V4Y2VwdGlvbixcbiAgZ2V0SW52YWxpZFJhd1hNTFZhbHVlRXhjZXB0aW9uOiBnZXRJbnZhbGlkUmF3WE1MVmFsdWVFeGNlcHRpb24sXG4gIGdldFVuYmFsYW5jZWRMb29wRXhjZXB0aW9uOiBnZXRVbmJhbGFuY2VkTG9vcEV4Y2VwdGlvbixcbiAgdGhyb3dBcGlWZXJzaW9uRXJyb3I6IHRocm93QXBpVmVyc2lvbkVycm9yLFxuICB0aHJvd0ZpbGVUeXBlTm90SGFuZGxlZDogdGhyb3dGaWxlVHlwZU5vdEhhbmRsZWQsXG4gIHRocm93RmlsZVR5cGVOb3RJZGVudGlmaWVkOiB0aHJvd0ZpbGVUeXBlTm90SWRlbnRpZmllZCxcbiAgdGhyb3dNYWxmb3JtZWRYbWw6IHRocm93TWFsZm9ybWVkWG1sLFxuICB0aHJvd011bHRpRXJyb3I6IHRocm93TXVsdGlFcnJvcixcbiAgdGhyb3dFeHBhbmROb3RGb3VuZDogdGhyb3dFeHBhbmROb3RGb3VuZCxcbiAgdGhyb3dSYXdUYWdTaG91bGRCZU9ubHlUZXh0SW5QYXJhZ3JhcGg6IHRocm93UmF3VGFnU2hvdWxkQmVPbmx5VGV4dEluUGFyYWdyYXBoLFxuICB0aHJvd1VuaW1wbGVtZW50ZWRUYWdUeXBlOiB0aHJvd1VuaW1wbGVtZW50ZWRUYWdUeXBlLFxuICB0aHJvd1htbFRhZ05vdEZvdW5kOiB0aHJvd1htbFRhZ05vdEZvdW5kLFxuICB0aHJvd1htbEludmFsaWQ6IHRocm93WG1sSW52YWxpZCxcbiAgdGhyb3dSZXNvbHZlQmVmb3JlQ29tcGlsZTogdGhyb3dSZXNvbHZlQmVmb3JlQ29tcGlsZSxcbiAgdGhyb3dSZW5kZXJJbnZhbGlkVGVtcGxhdGU6IHRocm93UmVuZGVySW52YWxpZFRlbXBsYXRlLFxuICB0aHJvd1JlbmRlclR3aWNlOiB0aHJvd1JlbmRlclR3aWNlXG59OyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJvd25LZXlzIiwiZSIsInIiLCJ0IiwiT2JqZWN0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJpIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiX3JlcXVpcmUiLCJyZXF1aXJlIiwibGFzdCIsImZpcnN0IiwiWFRFcnJvciIsIm1lc3NhZ2UiLCJuYW1lIiwic3RhY2siLCJFcnJvciIsIlhUVGVtcGxhdGVFcnJvciIsIlhUUmVuZGVyaW5nRXJyb3IiLCJYVFNjb3BlUGFyc2VyRXJyb3IiLCJYVEludGVybmFsRXJyb3IiLCJwcm9wZXJ0aWVzIiwiZXhwbGFuYXRpb24iLCJYVEFQSVZlcnNpb25FcnJvciIsInRocm93QXBpVmVyc2lvbkVycm9yIiwibXNnIiwiZXJyIiwiaWQiLCJ0aHJvd011bHRpRXJyb3IiLCJlcnJvcnMiLCJnZXRVbm9wZW5lZFRhZ0V4Y2VwdGlvbiIsIm9wdGlvbnMiLCJ4dGFnIiwic3BsaXQiLCJjb250ZXh0Iiwib2Zmc2V0IiwibEluZGV4IiwiY29uY2F0Iiwic3Vic3RyIiwiZ2V0RHVwbGljYXRlT3BlblRhZ0V4Y2VwdGlvbiIsImdldER1cGxpY2F0ZUNsb3NlVGFnRXhjZXB0aW9uIiwiZ2V0VW5jbG9zZWRUYWdFeGNlcHRpb24iLCJ0aHJvd1htbFRhZ05vdEZvdW5kIiwiZWxlbWVudCIsInBvc2l0aW9uIiwicGFydCIsInBhcnNlZCIsImluZGV4IiwiZ2V0Q29ycnVwdENoYXJhY3RlcnNFeGNlcHRpb24iLCJfcmVmIiwidGFnIiwiZ2V0SW52YWxpZFJhd1hNTFZhbHVlRXhjZXB0aW9uIiwiX3JlZjIiLCJ0aHJvd0V4cGFuZE5vdEZvdW5kIiwiX29wdGlvbnMkcGFydCIsIl9vcHRpb25zJGlkIiwiX29wdGlvbnMkbWVzc2FnZSIsIl9vcHRpb25zJGV4cGxhbmF0aW9uIiwicm9vdEVycm9yIiwicG9zdHBhcnNlZCIsImV4cGFuZFRvIiwidGhyb3dSYXdUYWdTaG91bGRCZU9ubHlUZXh0SW5QYXJhZ3JhcGgiLCJwYXJhZ3JhcGhQYXJ0cyIsImdldFVubWF0Y2hlZExvb3BFeGNlcHRpb24iLCJsb2NhdGlvbiIsInNxdWFyZSIsIlQiLCJnZXRVbmJhbGFuY2VkTG9vcEV4Y2VwdGlvbiIsInBhaXIiLCJsYXN0UGFpciIsImxhc3RMIiwibGFzdFIiLCJsIiwibGVmdCIsInJpZ2h0IiwiZ2V0Q2xvc2luZ1RhZ05vdE1hdGNoT3BlbmluZ1RhZyIsIl9yZWYzIiwidGFncyIsIm9wZW5pbmd0YWciLCJjbG9zaW5ndGFnIiwiZ2V0U2NvcGVDb21waWxhdGlvbkVycm9yIiwiX3JlZjQiLCJnZXRTY29wZVBhcnNlckV4ZWN1dGlvbkVycm9yIiwiX3JlZjUiLCJzY29wZSIsImVycm9yIiwiZ2V0TG9vcFBvc2l0aW9uUHJvZHVjZXNJbnZhbGlkWE1MRXJyb3IiLCJfcmVmNiIsInRocm93VW5pbXBsZW1lbnRlZFRhZ1R5cGUiLCJlcnJvck1zZyIsInR5cGUiLCJtb2R1bGUiLCJ0aHJvd01hbGZvcm1lZFhtbCIsInRocm93UmVzb2x2ZUJlZm9yZUNvbXBpbGUiLCJ0aHJvd1JlbmRlckludmFsaWRUZW1wbGF0ZSIsInRocm93UmVuZGVyVHdpY2UiLCJ0aHJvd0ZpbGVUeXBlTm90SWRlbnRpZmllZCIsInppcCIsImZpbGVzIiwic2xpY2UiLCJqb2luIiwidGhyb3dYbWxJbnZhbGlkIiwiY29udGVudCIsInRocm93RmlsZVR5cGVOb3RIYW5kbGVkIiwiZmlsZVR5cGUiLCJleHBvcnRzIiwiUmVuZGVyaW5nRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/file-type-config.js":
/*!***********************************************************!*\
  !*** ./node_modules/docxtemplater/js/file-type-config.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar loopModule = __webpack_require__(/*! ./modules/loop.js */ \"(rsc)/./node_modules/docxtemplater/js/modules/loop.js\");\nvar spacePreserveModule = __webpack_require__(/*! ./modules/space-preserve.js */ \"(rsc)/./node_modules/docxtemplater/js/modules/space-preserve.js\");\nvar rawXmlModule = __webpack_require__(/*! ./modules/rawxml.js */ \"(rsc)/./node_modules/docxtemplater/js/modules/rawxml.js\");\nvar expandPairTrait = __webpack_require__(/*! ./modules/expand-pair-trait.js */ \"(rsc)/./node_modules/docxtemplater/js/modules/expand-pair-trait.js\");\nvar render = __webpack_require__(/*! ./modules/render.js */ \"(rsc)/./node_modules/docxtemplater/js/modules/render.js\");\nfunction DocXFileTypeConfig() {\n    return {\n        getTemplatedFiles: function getTemplatedFiles() {\n            return [];\n        },\n        textPath: function textPath(doc) {\n            return doc.textTarget;\n        },\n        tagsXmlTextArray: [\n            \"Company\",\n            \"HyperlinkBase\",\n            \"Manager\",\n            \"cp:category\",\n            \"cp:keywords\",\n            \"dc:creator\",\n            \"dc:description\",\n            \"dc:subject\",\n            \"dc:title\",\n            \"cp:contentStatus\",\n            \"w:t\",\n            \"a:t\",\n            \"m:t\",\n            \"vt:lpstr\",\n            \"vt:lpwstr\"\n        ],\n        tagsXmlLexedArray: [\n            \"w:proofState\",\n            \"w:tc\",\n            \"w:tr\",\n            \"w:tbl\",\n            \"w:body\",\n            \"w:document\",\n            \"w:p\",\n            \"w:r\",\n            \"w:br\",\n            \"w:rPr\",\n            \"w:pPr\",\n            \"w:spacing\",\n            \"w:sdtContent\",\n            \"w:sdt\",\n            \"w:drawing\",\n            \"w:sectPr\",\n            \"w:type\",\n            \"w:headerReference\",\n            \"w:footerReference\",\n            \"w:bookmarkStart\",\n            \"w:bookmarkEnd\",\n            \"w:commentRangeStart\",\n            \"w:commentRangeEnd\",\n            \"w:commentReference\"\n        ],\n        droppedTagsInsidePlaceholder: [\n            \"w:p\",\n            \"w:br\",\n            \"w:bookmarkStart\",\n            \"w:bookmarkEnd\"\n        ],\n        expandTags: [\n            {\n                contains: \"w:tc\",\n                expand: \"w:tr\"\n            }\n        ],\n        onParagraphLoop: [\n            {\n                contains: \"w:p\",\n                expand: \"w:p\",\n                onlyTextInTag: true\n            }\n        ],\n        tagRawXml: \"w:p\",\n        baseModules: [\n            loopModule,\n            spacePreserveModule,\n            expandPairTrait,\n            rawXmlModule,\n            render\n        ],\n        tagShouldContain: [\n            {\n                tag: \"w:sdtContent\",\n                shouldContain: [\n                    \"w:p\",\n                    \"w:r\",\n                    \"w:commentRangeStart\",\n                    \"w:sdt\"\n                ],\n                value: \"<w:p></w:p>\"\n            },\n            {\n                tag: \"w:tc\",\n                shouldContain: [\n                    \"w:p\"\n                ],\n                value: \"<w:p></w:p>\"\n            },\n            {\n                tag: \"w:tr\",\n                shouldContain: [\n                    \"w:tc\"\n                ],\n                drop: true\n            },\n            {\n                tag: \"w:tbl\",\n                shouldContain: [\n                    \"w:tr\"\n                ],\n                drop: true\n            }\n        ]\n    };\n}\nfunction PptXFileTypeConfig() {\n    return {\n        getTemplatedFiles: function getTemplatedFiles() {\n            return [];\n        },\n        textPath: function textPath(doc) {\n            return doc.textTarget;\n        },\n        tagsXmlTextArray: [\n            \"Company\",\n            \"HyperlinkBase\",\n            \"Manager\",\n            \"cp:category\",\n            \"cp:keywords\",\n            \"dc:creator\",\n            \"dc:description\",\n            \"dc:subject\",\n            \"dc:title\",\n            \"a:t\",\n            \"m:t\",\n            \"vt:lpstr\",\n            \"vt:lpwstr\"\n        ],\n        tagsXmlLexedArray: [\n            \"p:sp\",\n            \"a:tc\",\n            \"a:tr\",\n            \"a:tbl\",\n            \"a:graphicData\",\n            \"a:p\",\n            \"a:r\",\n            \"a:rPr\",\n            \"p:txBody\",\n            \"a:txBody\",\n            \"a:off\",\n            \"a:ext\",\n            \"p:graphicFrame\",\n            \"p:xfrm\",\n            \"a16:rowId\",\n            \"a:endParaRPr\"\n        ],\n        droppedTagsInsidePlaceholder: [\n            \"a:p\",\n            \"a:endParaRPr\"\n        ],\n        expandTags: [\n            {\n                contains: \"a:tc\",\n                expand: \"a:tr\"\n            }\n        ],\n        onParagraphLoop: [\n            {\n                contains: \"a:p\",\n                expand: \"a:p\",\n                onlyTextInTag: true\n            }\n        ],\n        tagRawXml: \"p:sp\",\n        baseModules: [\n            loopModule,\n            expandPairTrait,\n            rawXmlModule,\n            render\n        ],\n        tagShouldContain: [\n            {\n                tag: \"a:tbl\",\n                shouldContain: [\n                    \"a:tr\"\n                ],\n                dropParent: \"p:graphicFrame\"\n            },\n            {\n                tag: \"p:txBody\",\n                shouldContain: [\n                    \"a:p\"\n                ],\n                value: \"<a:p></a:p>\"\n            },\n            {\n                tag: \"a:txBody\",\n                shouldContain: [\n                    \"a:p\"\n                ],\n                value: \"<a:p></a:p>\"\n            }\n        ]\n    };\n}\nmodule.exports = {\n    docx: DocXFileTypeConfig,\n    pptx: PptXFileTypeConfig\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9maWxlLXR5cGUtY29uZmlnLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsSUFBSUEsYUFBYUMsbUJBQU9BLENBQUMsZ0ZBQW1CO0FBQzVDLElBQUlDLHNCQUFzQkQsbUJBQU9BLENBQUMsb0dBQTZCO0FBQy9ELElBQUlFLGVBQWVGLG1CQUFPQSxDQUFDLG9GQUFxQjtBQUNoRCxJQUFJRyxrQkFBa0JILG1CQUFPQSxDQUFDLDBHQUFnQztBQUM5RCxJQUFJSSxTQUFTSixtQkFBT0EsQ0FBQyxvRkFBcUI7QUFDMUMsU0FBU0s7SUFDUCxPQUFPO1FBQ0xDLG1CQUFtQixTQUFTQTtZQUMxQixPQUFPLEVBQUU7UUFDWDtRQUNBQyxVQUFVLFNBQVNBLFNBQVNDLEdBQUc7WUFDN0IsT0FBT0EsSUFBSUMsVUFBVTtRQUN2QjtRQUNBQyxrQkFBa0I7WUFBQztZQUFXO1lBQWlCO1lBQVc7WUFBZTtZQUFlO1lBQWM7WUFBa0I7WUFBYztZQUFZO1lBQW9CO1lBQU87WUFBTztZQUFPO1lBQVk7U0FBWTtRQUNuTkMsbUJBQW1CO1lBQUM7WUFBZ0I7WUFBUTtZQUFRO1lBQVM7WUFBVTtZQUFjO1lBQU87WUFBTztZQUFRO1lBQVM7WUFBUztZQUFhO1lBQWdCO1lBQVM7WUFBYTtZQUFZO1lBQVU7WUFBcUI7WUFBcUI7WUFBbUI7WUFBaUI7WUFBdUI7WUFBcUI7U0FBcUI7UUFDclZDLDhCQUE4QjtZQUFDO1lBQU87WUFBUTtZQUFtQjtTQUFnQjtRQUNqRkMsWUFBWTtZQUFDO2dCQUNYQyxVQUFVO2dCQUNWQyxRQUFRO1lBQ1Y7U0FBRTtRQUNGQyxpQkFBaUI7WUFBQztnQkFDaEJGLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JFLGVBQWU7WUFDakI7U0FBRTtRQUNGQyxXQUFXO1FBQ1hDLGFBQWE7WUFBQ3BCO1lBQVlFO1lBQXFCRTtZQUFpQkQ7WUFBY0U7U0FBTztRQUNyRmdCLGtCQUFrQjtZQUFDO2dCQUNqQkMsS0FBSztnQkFDTEMsZUFBZTtvQkFBQztvQkFBTztvQkFBTztvQkFBdUI7aUJBQVE7Z0JBQzdEQyxPQUFPO1lBQ1Q7WUFBRztnQkFDREYsS0FBSztnQkFDTEMsZUFBZTtvQkFBQztpQkFBTTtnQkFDdEJDLE9BQU87WUFDVDtZQUFHO2dCQUNERixLQUFLO2dCQUNMQyxlQUFlO29CQUFDO2lCQUFPO2dCQUN2QkUsTUFBTTtZQUNSO1lBQUc7Z0JBQ0RILEtBQUs7Z0JBQ0xDLGVBQWU7b0JBQUM7aUJBQU87Z0JBQ3ZCRSxNQUFNO1lBQ1I7U0FBRTtJQUNKO0FBQ0Y7QUFDQSxTQUFTQztJQUNQLE9BQU87UUFDTG5CLG1CQUFtQixTQUFTQTtZQUMxQixPQUFPLEVBQUU7UUFDWDtRQUNBQyxVQUFVLFNBQVNBLFNBQVNDLEdBQUc7WUFDN0IsT0FBT0EsSUFBSUMsVUFBVTtRQUN2QjtRQUNBQyxrQkFBa0I7WUFBQztZQUFXO1lBQWlCO1lBQVc7WUFBZTtZQUFlO1lBQWM7WUFBa0I7WUFBYztZQUFZO1lBQU87WUFBTztZQUFZO1NBQVk7UUFDeExDLG1CQUFtQjtZQUFDO1lBQVE7WUFBUTtZQUFRO1lBQVM7WUFBaUI7WUFBTztZQUFPO1lBQVM7WUFBWTtZQUFZO1lBQVM7WUFBUztZQUFrQjtZQUFVO1lBQWE7U0FBZTtRQUMvTEMsOEJBQThCO1lBQUM7WUFBTztTQUFlO1FBQ3JEQyxZQUFZO1lBQUM7Z0JBQ1hDLFVBQVU7Z0JBQ1ZDLFFBQVE7WUFDVjtTQUFFO1FBQ0ZDLGlCQUFpQjtZQUFDO2dCQUNoQkYsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkUsZUFBZTtZQUNqQjtTQUFFO1FBQ0ZDLFdBQVc7UUFDWEMsYUFBYTtZQUFDcEI7WUFBWUk7WUFBaUJEO1lBQWNFO1NBQU87UUFDaEVnQixrQkFBa0I7WUFBQztnQkFDakJDLEtBQUs7Z0JBQ0xDLGVBQWU7b0JBQUM7aUJBQU87Z0JBQ3ZCSSxZQUFZO1lBQ2Q7WUFBRztnQkFDREwsS0FBSztnQkFDTEMsZUFBZTtvQkFBQztpQkFBTTtnQkFDdEJDLE9BQU87WUFDVDtZQUFHO2dCQUNERixLQUFLO2dCQUNMQyxlQUFlO29CQUFDO2lCQUFNO2dCQUN0QkMsT0FBTztZQUNUO1NBQUU7SUFDSjtBQUNGO0FBQ0FJLE9BQU9DLE9BQU8sR0FBRztJQUNmQyxNQUFNeEI7SUFDTnlCLE1BQU1MO0FBQ1IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaWtlLXJlbnRhbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZmlsZS10eXBlLWNvbmZpZy5qcz80MWY3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbG9vcE1vZHVsZSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvbG9vcC5qc1wiKTtcbnZhciBzcGFjZVByZXNlcnZlTW9kdWxlID0gcmVxdWlyZShcIi4vbW9kdWxlcy9zcGFjZS1wcmVzZXJ2ZS5qc1wiKTtcbnZhciByYXdYbWxNb2R1bGUgPSByZXF1aXJlKFwiLi9tb2R1bGVzL3Jhd3htbC5qc1wiKTtcbnZhciBleHBhbmRQYWlyVHJhaXQgPSByZXF1aXJlKFwiLi9tb2R1bGVzL2V4cGFuZC1wYWlyLXRyYWl0LmpzXCIpO1xudmFyIHJlbmRlciA9IHJlcXVpcmUoXCIuL21vZHVsZXMvcmVuZGVyLmpzXCIpO1xuZnVuY3Rpb24gRG9jWEZpbGVUeXBlQ29uZmlnKCkge1xuICByZXR1cm4ge1xuICAgIGdldFRlbXBsYXRlZEZpbGVzOiBmdW5jdGlvbiBnZXRUZW1wbGF0ZWRGaWxlcygpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIHRleHRQYXRoOiBmdW5jdGlvbiB0ZXh0UGF0aChkb2MpIHtcbiAgICAgIHJldHVybiBkb2MudGV4dFRhcmdldDtcbiAgICB9LFxuICAgIHRhZ3NYbWxUZXh0QXJyYXk6IFtcIkNvbXBhbnlcIiwgXCJIeXBlcmxpbmtCYXNlXCIsIFwiTWFuYWdlclwiLCBcImNwOmNhdGVnb3J5XCIsIFwiY3A6a2V5d29yZHNcIiwgXCJkYzpjcmVhdG9yXCIsIFwiZGM6ZGVzY3JpcHRpb25cIiwgXCJkYzpzdWJqZWN0XCIsIFwiZGM6dGl0bGVcIiwgXCJjcDpjb250ZW50U3RhdHVzXCIsIFwidzp0XCIsIFwiYTp0XCIsIFwibTp0XCIsIFwidnQ6bHBzdHJcIiwgXCJ2dDpscHdzdHJcIl0sXG4gICAgdGFnc1htbExleGVkQXJyYXk6IFtcInc6cHJvb2ZTdGF0ZVwiLCBcInc6dGNcIiwgXCJ3OnRyXCIsIFwidzp0YmxcIiwgXCJ3OmJvZHlcIiwgXCJ3OmRvY3VtZW50XCIsIFwidzpwXCIsIFwidzpyXCIsIFwidzpiclwiLCBcInc6clByXCIsIFwidzpwUHJcIiwgXCJ3OnNwYWNpbmdcIiwgXCJ3OnNkdENvbnRlbnRcIiwgXCJ3OnNkdFwiLCBcInc6ZHJhd2luZ1wiLCBcInc6c2VjdFByXCIsIFwidzp0eXBlXCIsIFwidzpoZWFkZXJSZWZlcmVuY2VcIiwgXCJ3OmZvb3RlclJlZmVyZW5jZVwiLCBcInc6Ym9va21hcmtTdGFydFwiLCBcInc6Ym9va21hcmtFbmRcIiwgXCJ3OmNvbW1lbnRSYW5nZVN0YXJ0XCIsIFwidzpjb21tZW50UmFuZ2VFbmRcIiwgXCJ3OmNvbW1lbnRSZWZlcmVuY2VcIl0sXG4gICAgZHJvcHBlZFRhZ3NJbnNpZGVQbGFjZWhvbGRlcjogW1widzpwXCIsIFwidzpiclwiLCBcInc6Ym9va21hcmtTdGFydFwiLCBcInc6Ym9va21hcmtFbmRcIl0sXG4gICAgZXhwYW5kVGFnczogW3tcbiAgICAgIGNvbnRhaW5zOiBcInc6dGNcIixcbiAgICAgIGV4cGFuZDogXCJ3OnRyXCJcbiAgICB9XSxcbiAgICBvblBhcmFncmFwaExvb3A6IFt7XG4gICAgICBjb250YWluczogXCJ3OnBcIixcbiAgICAgIGV4cGFuZDogXCJ3OnBcIixcbiAgICAgIG9ubHlUZXh0SW5UYWc6IHRydWVcbiAgICB9XSxcbiAgICB0YWdSYXdYbWw6IFwidzpwXCIsXG4gICAgYmFzZU1vZHVsZXM6IFtsb29wTW9kdWxlLCBzcGFjZVByZXNlcnZlTW9kdWxlLCBleHBhbmRQYWlyVHJhaXQsIHJhd1htbE1vZHVsZSwgcmVuZGVyXSxcbiAgICB0YWdTaG91bGRDb250YWluOiBbe1xuICAgICAgdGFnOiBcInc6c2R0Q29udGVudFwiLFxuICAgICAgc2hvdWxkQ29udGFpbjogW1widzpwXCIsIFwidzpyXCIsIFwidzpjb21tZW50UmFuZ2VTdGFydFwiLCBcInc6c2R0XCJdLFxuICAgICAgdmFsdWU6IFwiPHc6cD48L3c6cD5cIlxuICAgIH0sIHtcbiAgICAgIHRhZzogXCJ3OnRjXCIsXG4gICAgICBzaG91bGRDb250YWluOiBbXCJ3OnBcIl0sXG4gICAgICB2YWx1ZTogXCI8dzpwPjwvdzpwPlwiXG4gICAgfSwge1xuICAgICAgdGFnOiBcInc6dHJcIixcbiAgICAgIHNob3VsZENvbnRhaW46IFtcInc6dGNcIl0sXG4gICAgICBkcm9wOiB0cnVlXG4gICAgfSwge1xuICAgICAgdGFnOiBcInc6dGJsXCIsXG4gICAgICBzaG91bGRDb250YWluOiBbXCJ3OnRyXCJdLFxuICAgICAgZHJvcDogdHJ1ZVxuICAgIH1dXG4gIH07XG59XG5mdW5jdGlvbiBQcHRYRmlsZVR5cGVDb25maWcoKSB7XG4gIHJldHVybiB7XG4gICAgZ2V0VGVtcGxhdGVkRmlsZXM6IGZ1bmN0aW9uIGdldFRlbXBsYXRlZEZpbGVzKCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgdGV4dFBhdGg6IGZ1bmN0aW9uIHRleHRQYXRoKGRvYykge1xuICAgICAgcmV0dXJuIGRvYy50ZXh0VGFyZ2V0O1xuICAgIH0sXG4gICAgdGFnc1htbFRleHRBcnJheTogW1wiQ29tcGFueVwiLCBcIkh5cGVybGlua0Jhc2VcIiwgXCJNYW5hZ2VyXCIsIFwiY3A6Y2F0ZWdvcnlcIiwgXCJjcDprZXl3b3Jkc1wiLCBcImRjOmNyZWF0b3JcIiwgXCJkYzpkZXNjcmlwdGlvblwiLCBcImRjOnN1YmplY3RcIiwgXCJkYzp0aXRsZVwiLCBcImE6dFwiLCBcIm06dFwiLCBcInZ0Omxwc3RyXCIsIFwidnQ6bHB3c3RyXCJdLFxuICAgIHRhZ3NYbWxMZXhlZEFycmF5OiBbXCJwOnNwXCIsIFwiYTp0Y1wiLCBcImE6dHJcIiwgXCJhOnRibFwiLCBcImE6Z3JhcGhpY0RhdGFcIiwgXCJhOnBcIiwgXCJhOnJcIiwgXCJhOnJQclwiLCBcInA6dHhCb2R5XCIsIFwiYTp0eEJvZHlcIiwgXCJhOm9mZlwiLCBcImE6ZXh0XCIsIFwicDpncmFwaGljRnJhbWVcIiwgXCJwOnhmcm1cIiwgXCJhMTY6cm93SWRcIiwgXCJhOmVuZFBhcmFSUHJcIl0sXG4gICAgZHJvcHBlZFRhZ3NJbnNpZGVQbGFjZWhvbGRlcjogW1wiYTpwXCIsIFwiYTplbmRQYXJhUlByXCJdLFxuICAgIGV4cGFuZFRhZ3M6IFt7XG4gICAgICBjb250YWluczogXCJhOnRjXCIsXG4gICAgICBleHBhbmQ6IFwiYTp0clwiXG4gICAgfV0sXG4gICAgb25QYXJhZ3JhcGhMb29wOiBbe1xuICAgICAgY29udGFpbnM6IFwiYTpwXCIsXG4gICAgICBleHBhbmQ6IFwiYTpwXCIsXG4gICAgICBvbmx5VGV4dEluVGFnOiB0cnVlXG4gICAgfV0sXG4gICAgdGFnUmF3WG1sOiBcInA6c3BcIixcbiAgICBiYXNlTW9kdWxlczogW2xvb3BNb2R1bGUsIGV4cGFuZFBhaXJUcmFpdCwgcmF3WG1sTW9kdWxlLCByZW5kZXJdLFxuICAgIHRhZ1Nob3VsZENvbnRhaW46IFt7XG4gICAgICB0YWc6IFwiYTp0YmxcIixcbiAgICAgIHNob3VsZENvbnRhaW46IFtcImE6dHJcIl0sXG4gICAgICBkcm9wUGFyZW50OiBcInA6Z3JhcGhpY0ZyYW1lXCJcbiAgICB9LCB7XG4gICAgICB0YWc6IFwicDp0eEJvZHlcIixcbiAgICAgIHNob3VsZENvbnRhaW46IFtcImE6cFwiXSxcbiAgICAgIHZhbHVlOiBcIjxhOnA+PC9hOnA+XCJcbiAgICB9LCB7XG4gICAgICB0YWc6IFwiYTp0eEJvZHlcIixcbiAgICAgIHNob3VsZENvbnRhaW46IFtcImE6cFwiXSxcbiAgICAgIHZhbHVlOiBcIjxhOnA+PC9hOnA+XCJcbiAgICB9XVxuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRvY3g6IERvY1hGaWxlVHlwZUNvbmZpZyxcbiAgcHB0eDogUHB0WEZpbGVUeXBlQ29uZmlnXG59OyJdLCJuYW1lcyI6WyJsb29wTW9kdWxlIiwicmVxdWlyZSIsInNwYWNlUHJlc2VydmVNb2R1bGUiLCJyYXdYbWxNb2R1bGUiLCJleHBhbmRQYWlyVHJhaXQiLCJyZW5kZXIiLCJEb2NYRmlsZVR5cGVDb25maWciLCJnZXRUZW1wbGF0ZWRGaWxlcyIsInRleHRQYXRoIiwiZG9jIiwidGV4dFRhcmdldCIsInRhZ3NYbWxUZXh0QXJyYXkiLCJ0YWdzWG1sTGV4ZWRBcnJheSIsImRyb3BwZWRUYWdzSW5zaWRlUGxhY2Vob2xkZXIiLCJleHBhbmRUYWdzIiwiY29udGFpbnMiLCJleHBhbmQiLCJvblBhcmFncmFwaExvb3AiLCJvbmx5VGV4dEluVGFnIiwidGFnUmF3WG1sIiwiYmFzZU1vZHVsZXMiLCJ0YWdTaG91bGRDb250YWluIiwidGFnIiwic2hvdWxkQ29udGFpbiIsInZhbHVlIiwiZHJvcCIsIlBwdFhGaWxlVHlwZUNvbmZpZyIsImRyb3BQYXJlbnQiLCJtb2R1bGUiLCJleHBvcnRzIiwiZG9jeCIsInBwdHgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/file-type-config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/filetypes.js":
/*!****************************************************!*\
  !*** ./node_modules/docxtemplater/js/filetypes.js ***!
  \****************************************************/
/***/ ((module) => {

eval("\nvar docxContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml\";\nvar docxmContentType = \"application/vnd.ms-word.document.macroEnabled.main+xml\";\nvar dotxContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml\";\nvar dotmContentType = \"application/vnd.ms-word.template.macroEnabledTemplate.main+xml\";\nvar headerContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml\";\nvar footnotesContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml\";\nvar commentsContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml\";\nvar footerContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml\";\nvar pptxContentType = \"application/vnd.openxmlformats-officedocument.presentationml.slide+xml\";\nvar pptxSlideMaster = \"application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml\";\nvar pptxSlideLayout = \"application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml\";\nvar pptxPresentationContentType = \"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml\";\nvar xlsxContentType = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\";\nvar xlsmContentType = \"application/vnd.ms-excel.sheet.macroEnabled.main+xml\";\nvar xlsxWorksheetContentType = \"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\";\n/*\n * This is used for the main part of the document, ie usually that would be the\n * type of word/document.xml\n */ var main = [\n    docxContentType,\n    docxmContentType,\n    dotxContentType,\n    dotmContentType\n];\nvar filetypes = {\n    main: main,\n    docx: [\n        headerContentType\n    ].concat(main, [\n        footerContentType,\n        footnotesContentType,\n        commentsContentType\n    ]),\n    pptx: [\n        pptxContentType,\n        pptxSlideMaster,\n        pptxSlideLayout,\n        pptxPresentationContentType\n    ],\n    xlsx: [\n        xlsxContentType,\n        xlsmContentType,\n        xlsxWorksheetContentType\n    ]\n};\nmodule.exports = filetypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9maWxldHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxrQkFBa0I7QUFDdEIsSUFBSUMsbUJBQW1CO0FBQ3ZCLElBQUlDLGtCQUFrQjtBQUN0QixJQUFJQyxrQkFBa0I7QUFDdEIsSUFBSUMsb0JBQW9CO0FBQ3hCLElBQUlDLHVCQUF1QjtBQUMzQixJQUFJQyxzQkFBc0I7QUFDMUIsSUFBSUMsb0JBQW9CO0FBQ3hCLElBQUlDLGtCQUFrQjtBQUN0QixJQUFJQyxrQkFBa0I7QUFDdEIsSUFBSUMsa0JBQWtCO0FBQ3RCLElBQUlDLDhCQUE4QjtBQUNsQyxJQUFJQyxrQkFBa0I7QUFDdEIsSUFBSUMsa0JBQWtCO0FBQ3RCLElBQUlDLDJCQUEyQjtBQUMvQjs7O0NBR0MsR0FDRCxJQUFJQyxPQUFPO0lBQUNmO0lBQWlCQztJQUFrQkM7SUFBaUJDO0NBQWdCO0FBQ2hGLElBQUlhLFlBQVk7SUFDZEQsTUFBTUE7SUFDTkUsTUFBTTtRQUFDYjtLQUFrQixDQUFDYyxNQUFNLENBQUNILE1BQU07UUFBQ1I7UUFBbUJGO1FBQXNCQztLQUFvQjtJQUNyR2EsTUFBTTtRQUFDWDtRQUFpQkM7UUFBaUJDO1FBQWlCQztLQUE0QjtJQUN0RlMsTUFBTTtRQUFDUjtRQUFpQkM7UUFBaUJDO0tBQXlCO0FBQ3BFO0FBQ0FPLE9BQU9DLE9BQU8sR0FBR04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaWtlLXJlbnRhbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZmlsZXR5cGVzLmpzPzc1YzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBkb2N4Q29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50Lm1haW4reG1sXCI7XG52YXIgZG9jeG1Db250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm1zLXdvcmQuZG9jdW1lbnQubWFjcm9FbmFibGVkLm1haW4reG1sXCI7XG52YXIgZG90eENvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC50ZW1wbGF0ZS5tYWluK3htbFwiO1xudmFyIGRvdG1Db250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm1zLXdvcmQudGVtcGxhdGUubWFjcm9FbmFibGVkVGVtcGxhdGUubWFpbit4bWxcIjtcbnZhciBoZWFkZXJDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuaGVhZGVyK3htbFwiO1xudmFyIGZvb3Rub3Rlc0NvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5mb290bm90ZXMreG1sXCI7XG52YXIgY29tbWVudHNDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuY29tbWVudHMreG1sXCI7XG52YXIgZm9vdGVyQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmZvb3Rlcit4bWxcIjtcbnZhciBwcHR4Q29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZSt4bWxcIjtcbnZhciBwcHR4U2xpZGVNYXN0ZXIgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZU1hc3Rlcit4bWxcIjtcbnZhciBwcHR4U2xpZGVMYXlvdXQgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZUxheW91dCt4bWxcIjtcbnZhciBwcHR4UHJlc2VudGF0aW9uQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5wcmVzZW50YXRpb24ubWFpbit4bWxcIjtcbnZhciB4bHN4Q29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0Lm1haW4reG1sXCI7XG52YXIgeGxzbUNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwuc2hlZXQubWFjcm9FbmFibGVkLm1haW4reG1sXCI7XG52YXIgeGxzeFdvcmtzaGVldENvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC53b3Jrc2hlZXQreG1sXCI7XG4vKlxuICogVGhpcyBpcyB1c2VkIGZvciB0aGUgbWFpbiBwYXJ0IG9mIHRoZSBkb2N1bWVudCwgaWUgdXN1YWxseSB0aGF0IHdvdWxkIGJlIHRoZVxuICogdHlwZSBvZiB3b3JkL2RvY3VtZW50LnhtbFxuICovXG52YXIgbWFpbiA9IFtkb2N4Q29udGVudFR5cGUsIGRvY3htQ29udGVudFR5cGUsIGRvdHhDb250ZW50VHlwZSwgZG90bUNvbnRlbnRUeXBlXTtcbnZhciBmaWxldHlwZXMgPSB7XG4gIG1haW46IG1haW4sXG4gIGRvY3g6IFtoZWFkZXJDb250ZW50VHlwZV0uY29uY2F0KG1haW4sIFtmb290ZXJDb250ZW50VHlwZSwgZm9vdG5vdGVzQ29udGVudFR5cGUsIGNvbW1lbnRzQ29udGVudFR5cGVdKSxcbiAgcHB0eDogW3BwdHhDb250ZW50VHlwZSwgcHB0eFNsaWRlTWFzdGVyLCBwcHR4U2xpZGVMYXlvdXQsIHBwdHhQcmVzZW50YXRpb25Db250ZW50VHlwZV0sXG4gIHhsc3g6IFt4bHN4Q29udGVudFR5cGUsIHhsc21Db250ZW50VHlwZSwgeGxzeFdvcmtzaGVldENvbnRlbnRUeXBlXVxufTtcbm1vZHVsZS5leHBvcnRzID0gZmlsZXR5cGVzOyJdLCJuYW1lcyI6WyJkb2N4Q29udGVudFR5cGUiLCJkb2N4bUNvbnRlbnRUeXBlIiwiZG90eENvbnRlbnRUeXBlIiwiZG90bUNvbnRlbnRUeXBlIiwiaGVhZGVyQ29udGVudFR5cGUiLCJmb290bm90ZXNDb250ZW50VHlwZSIsImNvbW1lbnRzQ29udGVudFR5cGUiLCJmb290ZXJDb250ZW50VHlwZSIsInBwdHhDb250ZW50VHlwZSIsInBwdHhTbGlkZU1hc3RlciIsInBwdHhTbGlkZUxheW91dCIsInBwdHhQcmVzZW50YXRpb25Db250ZW50VHlwZSIsInhsc3hDb250ZW50VHlwZSIsInhsc21Db250ZW50VHlwZSIsInhsc3hXb3Jrc2hlZXRDb250ZW50VHlwZSIsIm1haW4iLCJmaWxldHlwZXMiLCJkb2N4IiwiY29uY2F0IiwicHB0eCIsInhsc3giLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/filetypes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/get-resolved-id.js":
/*!**********************************************************!*\
  !*** ./node_modules/docxtemplater/js/get-resolved-id.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("\nfunction getResolvedId(part, options) {\n    if (part.lIndex == null) {\n        return null;\n    }\n    var path = options.scopeManager.scopePathItem;\n    if (part.parentPart) {\n        path = path.slice(0, path.length - 1);\n    }\n    var res = options.filePath + \"@\" + part.lIndex.toString() + \"-\" + path.join(\"-\");\n    return res;\n}\nmodule.exports = getResolvedId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9nZXQtcmVzb2x2ZWQtaWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxjQUFjQyxJQUFJLEVBQUVDLE9BQU87SUFDbEMsSUFBSUQsS0FBS0UsTUFBTSxJQUFJLE1BQU07UUFDdkIsT0FBTztJQUNUO0lBQ0EsSUFBSUMsT0FBT0YsUUFBUUcsWUFBWSxDQUFDQyxhQUFhO0lBQzdDLElBQUlMLEtBQUtNLFVBQVUsRUFBRTtRQUNuQkgsT0FBT0EsS0FBS0ksS0FBSyxDQUFDLEdBQUdKLEtBQUtLLE1BQU0sR0FBRztJQUNyQztJQUNBLElBQUlDLE1BQU1SLFFBQVFTLFFBQVEsR0FBRyxNQUFNVixLQUFLRSxNQUFNLENBQUNTLFFBQVEsS0FBSyxNQUFNUixLQUFLUyxJQUFJLENBQUM7SUFDNUUsT0FBT0g7QUFDVDtBQUNBSSxPQUFPQyxPQUFPLEdBQUdmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlrZS1yZW50YWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2dldC1yZXNvbHZlZC1pZC5qcz83ZmIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBnZXRSZXNvbHZlZElkKHBhcnQsIG9wdGlvbnMpIHtcbiAgaWYgKHBhcnQubEluZGV4ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcGF0aCA9IG9wdGlvbnMuc2NvcGVNYW5hZ2VyLnNjb3BlUGF0aEl0ZW07XG4gIGlmIChwYXJ0LnBhcmVudFBhcnQpIHtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDEpO1xuICB9XG4gIHZhciByZXMgPSBvcHRpb25zLmZpbGVQYXRoICsgXCJAXCIgKyBwYXJ0LmxJbmRleC50b1N0cmluZygpICsgXCItXCIgKyBwYXRoLmpvaW4oXCItXCIpO1xuICByZXR1cm4gcmVzO1xufVxubW9kdWxlLmV4cG9ydHMgPSBnZXRSZXNvbHZlZElkOyJdLCJuYW1lcyI6WyJnZXRSZXNvbHZlZElkIiwicGFydCIsIm9wdGlvbnMiLCJsSW5kZXgiLCJwYXRoIiwic2NvcGVNYW5hZ2VyIiwic2NvcGVQYXRoSXRlbSIsInBhcmVudFBhcnQiLCJzbGljZSIsImxlbmd0aCIsInJlcyIsImZpbGVQYXRoIiwidG9TdHJpbmciLCJqb2luIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/get-resolved-id.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/get-tags.js":
/*!***************************************************!*\
  !*** ./node_modules/docxtemplater/js/get-tags.js ***!
  \***************************************************/
/***/ ((module) => {

eval("\nfunction _toConsumableArray(r) {\n    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(r, a) {\n    if (r) {\n        if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n        var t = ({}).toString.call(r).slice(8, -1);\n        return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n    }\n}\nfunction _iterableToArray(r) {\n    if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _arrayWithoutHoles(r) {\n    if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];\n    return n;\n}\nfunction isPlaceholder(part) {\n    return part.type === \"placeholder\";\n}\n/* eslint-disable-next-line complexity */ function getTags(postParsed) {\n    var tags = {};\n    var stack = [\n        {\n            items: postParsed.filter(isPlaceholder),\n            parents: [],\n            path: []\n        }\n    ];\n    function processFiltered(part, current, filtered) {\n        if (filtered.length) {\n            stack.push({\n                items: filtered,\n                parents: [].concat(_toConsumableArray(current.parents), [\n                    part\n                ]),\n                path: part.dataBound !== false && !part.attrParsed && part.value && !part.attrParsed ? [].concat(_toConsumableArray(current.path), [\n                    part.value\n                ]) : _toConsumableArray(current.path)\n            });\n        }\n    }\n    function getLocalTags(tags, path) {\n        var sizeScope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path.length;\n        var localTags = tags;\n        for(var i = 0; i < sizeScope; i++){\n            localTags = localTags[path[i]];\n        }\n        return localTags;\n    }\n    function getScopeSize(part, parents) {\n        return parents.reduce(function(size, parent) {\n            var lIndexLoop = typeof parent.lIndex === \"number\" ? parent.lIndex : parseInt(parent.lIndex.split(\"-\")[0], 10);\n            return lIndexLoop > part.lIndex ? size - 1 : size;\n        }, parents.length);\n    }\n    while(stack.length > 0){\n        var current = stack.pop();\n        var localTags = getLocalTags(tags, current.path);\n        for(var _i2 = 0, _current$items2 = current.items; _i2 < _current$items2.length; _i2++){\n            var _localTags4, _part$value2;\n            var part = _current$items2[_i2];\n            if (part.attrParsed) {\n                for(var key in part.attrParsed){\n                    processFiltered(part, current, part.attrParsed[key].filter(isPlaceholder));\n                }\n                continue;\n            }\n            if (part.subparsed) {\n                if (part.dataBound !== false) {\n                    var _localTags, _part$value;\n                    (_localTags = localTags)[_part$value = part.value] || (_localTags[_part$value] = {});\n                }\n                processFiltered(part, current, part.subparsed.filter(isPlaceholder));\n                continue;\n            }\n            if (part.cellParsed) {\n                for(var _i4 = 0, _part$cellPostParsed2 = part.cellPostParsed; _i4 < _part$cellPostParsed2.length; _i4++){\n                    var cp = _part$cellPostParsed2[_i4];\n                    if (cp.type === \"placeholder\") {\n                        if (cp.module === \"pro-xml-templating/xls-module-loop\") {\n                            continue;\n                        } else if (cp.subparsed) {\n                            var _localTags2, _cp$value;\n                            (_localTags2 = localTags)[_cp$value = cp.value] || (_localTags2[_cp$value] = {});\n                            processFiltered(cp, current, cp.subparsed.filter(isPlaceholder));\n                        } else {\n                            var _localTags3, _cp$value2;\n                            var sizeScope = getScopeSize(part, current.parents);\n                            localTags = getLocalTags(tags, current.path, sizeScope);\n                            (_localTags3 = localTags)[_cp$value2 = cp.value] || (_localTags3[_cp$value2] = {});\n                        }\n                    }\n                }\n                continue;\n            }\n            if (part.dataBound === false) {\n                continue;\n            }\n            (_localTags4 = localTags)[_part$value2 = part.value] || (_localTags4[_part$value2] = {});\n        }\n    }\n    return tags;\n}\nmodule.exports = {\n    getTags: getTags,\n    isPlaceholder: isPlaceholder\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9nZXQtdGFncy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLG1CQUFtQkMsQ0FBQztJQUFJLE9BQU9DLG1CQUFtQkQsTUFBTUUsaUJBQWlCRixNQUFNRyw0QkFBNEJILE1BQU1JO0FBQXNCO0FBQ2hKLFNBQVNBO0lBQXVCLE1BQU0sSUFBSUMsVUFBVTtBQUF5STtBQUM3TCxTQUFTRiw0QkFBNEJILENBQUMsRUFBRU0sQ0FBQztJQUFJLElBQUlOLEdBQUc7UUFBRSxJQUFJLFlBQVksT0FBT0EsR0FBRyxPQUFPTyxrQkFBa0JQLEdBQUdNO1FBQUksSUFBSUUsSUFBSSxFQUFDLEdBQUVDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDVixHQUFHVyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQUksT0FBTyxhQUFhSCxLQUFLUixFQUFFWSxXQUFXLElBQUtKLENBQUFBLElBQUlSLEVBQUVZLFdBQVcsQ0FBQ0MsSUFBSSxHQUFHLFVBQVVMLEtBQUssVUFBVUEsSUFBSU0sTUFBTUMsSUFBSSxDQUFDZixLQUFLLGdCQUFnQlEsS0FBSywyQ0FBMkNRLElBQUksQ0FBQ1IsS0FBS0Qsa0JBQWtCUCxHQUFHTSxLQUFLLEtBQUs7SUFBRztBQUFFO0FBQ3pYLFNBQVNKLGlCQUFpQkYsQ0FBQztJQUFJLElBQUksZUFBZSxPQUFPaUIsVUFBVSxRQUFRakIsQ0FBQyxDQUFDaUIsT0FBT0MsUUFBUSxDQUFDLElBQUksUUFBUWxCLENBQUMsQ0FBQyxhQUFhLEVBQUUsT0FBT2MsTUFBTUMsSUFBSSxDQUFDZjtBQUFJO0FBQ2hKLFNBQVNDLG1CQUFtQkQsQ0FBQztJQUFJLElBQUljLE1BQU1LLE9BQU8sQ0FBQ25CLElBQUksT0FBT08sa0JBQWtCUDtBQUFJO0FBQ3BGLFNBQVNPLGtCQUFrQlAsQ0FBQyxFQUFFTSxDQUFDO0lBQUssU0FBUUEsS0FBS0EsSUFBSU4sRUFBRW9CLE1BQU0sS0FBTWQsQ0FBQUEsSUFBSU4sRUFBRW9C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YixTQUFRLENBQUUsQ0FBQ2MsZUFBZXBDLEtBQUtpQixLQUFLLENBQUMsSUFBS2tCLENBQUFBLFdBQVcsQ0FBQ0MsYUFBYSxHQUFHLENBQUM7UUFDeEY7SUFDRjtJQUNBLE9BQU9oQztBQUNUO0FBQ0EwQyxPQUFPSyxPQUFPLEdBQUc7SUFDZmpELFNBQVNBO0lBQ1RILGVBQWVBO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlrZS1yZW50YWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2dldC10YWdzLmpzPzFhNGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheShyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkocikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwOyB9IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkocikgeyBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIG51bGwgIT0gcltTeW1ib2wuaXRlcmF0b3JdIHx8IG51bGwgIT0gcltcIkBAaXRlcmF0b3JcIl0pIHJldHVybiBBcnJheS5mcm9tKHIpOyB9XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIpOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG5mdW5jdGlvbiBpc1BsYWNlaG9sZGVyKHBhcnQpIHtcbiAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJwbGFjZWhvbGRlclwiO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eSAqL1xuZnVuY3Rpb24gZ2V0VGFncyhwb3N0UGFyc2VkKSB7XG4gIHZhciB0YWdzID0ge307XG4gIHZhciBzdGFjayA9IFt7XG4gICAgaXRlbXM6IHBvc3RQYXJzZWQuZmlsdGVyKGlzUGxhY2Vob2xkZXIpLFxuICAgIHBhcmVudHM6IFtdLFxuICAgIHBhdGg6IFtdXG4gIH1dO1xuICBmdW5jdGlvbiBwcm9jZXNzRmlsdGVyZWQocGFydCwgY3VycmVudCwgZmlsdGVyZWQpIHtcbiAgICBpZiAoZmlsdGVyZWQubGVuZ3RoKSB7XG4gICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgaXRlbXM6IGZpbHRlcmVkLFxuICAgICAgICBwYXJlbnRzOiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGN1cnJlbnQucGFyZW50cyksIFtwYXJ0XSksXG4gICAgICAgIHBhdGg6IHBhcnQuZGF0YUJvdW5kICE9PSBmYWxzZSAmJiAhcGFydC5hdHRyUGFyc2VkICYmIHBhcnQudmFsdWUgJiYgIXBhcnQuYXR0clBhcnNlZCA/IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoY3VycmVudC5wYXRoKSwgW3BhcnQudmFsdWVdKSA6IF90b0NvbnN1bWFibGVBcnJheShjdXJyZW50LnBhdGgpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TG9jYWxUYWdzKHRhZ3MsIHBhdGgpIHtcbiAgICB2YXIgc2l6ZVNjb3BlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBwYXRoLmxlbmd0aDtcbiAgICB2YXIgbG9jYWxUYWdzID0gdGFncztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemVTY29wZTsgaSsrKSB7XG4gICAgICBsb2NhbFRhZ3MgPSBsb2NhbFRhZ3NbcGF0aFtpXV07XG4gICAgfVxuICAgIHJldHVybiBsb2NhbFRhZ3M7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U2NvcGVTaXplKHBhcnQsIHBhcmVudHMpIHtcbiAgICByZXR1cm4gcGFyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKHNpemUsIHBhcmVudCkge1xuICAgICAgdmFyIGxJbmRleExvb3AgPSB0eXBlb2YgcGFyZW50LmxJbmRleCA9PT0gXCJudW1iZXJcIiA/IHBhcmVudC5sSW5kZXggOiBwYXJzZUludChwYXJlbnQubEluZGV4LnNwbGl0KFwiLVwiKVswXSwgMTApO1xuICAgICAgcmV0dXJuIGxJbmRleExvb3AgPiBwYXJ0LmxJbmRleCA/IHNpemUgLSAxIDogc2l6ZTtcbiAgICB9LCBwYXJlbnRzLmxlbmd0aCk7XG4gIH1cbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgY3VycmVudCA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBsb2NhbFRhZ3MgPSBnZXRMb2NhbFRhZ3ModGFncywgY3VycmVudC5wYXRoKTtcbiAgICBmb3IgKHZhciBfaTIgPSAwLCBfY3VycmVudCRpdGVtczIgPSBjdXJyZW50Lml0ZW1zOyBfaTIgPCBfY3VycmVudCRpdGVtczIubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIF9sb2NhbFRhZ3M0LCBfcGFydCR2YWx1ZTI7XG4gICAgICB2YXIgcGFydCA9IF9jdXJyZW50JGl0ZW1zMltfaTJdO1xuICAgICAgaWYgKHBhcnQuYXR0clBhcnNlZCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcGFydC5hdHRyUGFyc2VkKSB7XG4gICAgICAgICAgcHJvY2Vzc0ZpbHRlcmVkKHBhcnQsIGN1cnJlbnQsIHBhcnQuYXR0clBhcnNlZFtrZXldLmZpbHRlcihpc1BsYWNlaG9sZGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocGFydC5zdWJwYXJzZWQpIHtcbiAgICAgICAgaWYgKHBhcnQuZGF0YUJvdW5kICE9PSBmYWxzZSkge1xuICAgICAgICAgIHZhciBfbG9jYWxUYWdzLCBfcGFydCR2YWx1ZTtcbiAgICAgICAgICAoX2xvY2FsVGFncyA9IGxvY2FsVGFncylbX3BhcnQkdmFsdWUgPSBwYXJ0LnZhbHVlXSB8fCAoX2xvY2FsVGFnc1tfcGFydCR2YWx1ZV0gPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0ZpbHRlcmVkKHBhcnQsIGN1cnJlbnQsIHBhcnQuc3VicGFyc2VkLmZpbHRlcihpc1BsYWNlaG9sZGVyKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnQuY2VsbFBhcnNlZCkge1xuICAgICAgICBmb3IgKHZhciBfaTQgPSAwLCBfcGFydCRjZWxsUG9zdFBhcnNlZDIgPSBwYXJ0LmNlbGxQb3N0UGFyc2VkOyBfaTQgPCBfcGFydCRjZWxsUG9zdFBhcnNlZDIubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICAgIHZhciBjcCA9IF9wYXJ0JGNlbGxQb3N0UGFyc2VkMltfaTRdO1xuICAgICAgICAgIGlmIChjcC50eXBlID09PSBcInBsYWNlaG9sZGVyXCIpIHtcbiAgICAgICAgICAgIGlmIChjcC5tb2R1bGUgPT09IFwicHJvLXhtbC10ZW1wbGF0aW5nL3hscy1tb2R1bGUtbG9vcFwiKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjcC5zdWJwYXJzZWQpIHtcbiAgICAgICAgICAgICAgdmFyIF9sb2NhbFRhZ3MyLCBfY3AkdmFsdWU7XG4gICAgICAgICAgICAgIChfbG9jYWxUYWdzMiA9IGxvY2FsVGFncylbX2NwJHZhbHVlID0gY3AudmFsdWVdIHx8IChfbG9jYWxUYWdzMltfY3AkdmFsdWVdID0ge30pO1xuICAgICAgICAgICAgICBwcm9jZXNzRmlsdGVyZWQoY3AsIGN1cnJlbnQsIGNwLnN1YnBhcnNlZC5maWx0ZXIoaXNQbGFjZWhvbGRlcikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9sb2NhbFRhZ3MzLCBfY3AkdmFsdWUyO1xuICAgICAgICAgICAgICB2YXIgc2l6ZVNjb3BlID0gZ2V0U2NvcGVTaXplKHBhcnQsIGN1cnJlbnQucGFyZW50cyk7XG4gICAgICAgICAgICAgIGxvY2FsVGFncyA9IGdldExvY2FsVGFncyh0YWdzLCBjdXJyZW50LnBhdGgsIHNpemVTY29wZSk7XG4gICAgICAgICAgICAgIChfbG9jYWxUYWdzMyA9IGxvY2FsVGFncylbX2NwJHZhbHVlMiA9IGNwLnZhbHVlXSB8fCAoX2xvY2FsVGFnczNbX2NwJHZhbHVlMl0gPSB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnQuZGF0YUJvdW5kID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIChfbG9jYWxUYWdzNCA9IGxvY2FsVGFncylbX3BhcnQkdmFsdWUyID0gcGFydC52YWx1ZV0gfHwgKF9sb2NhbFRhZ3M0W19wYXJ0JHZhbHVlMl0gPSB7fSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YWdzO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldFRhZ3M6IGdldFRhZ3MsXG4gIGlzUGxhY2Vob2xkZXI6IGlzUGxhY2Vob2xkZXJcbn07Il0sIm5hbWVzIjpbIl90b0NvbnN1bWFibGVBcnJheSIsInIiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiVHlwZUVycm9yIiwiYSIsIl9hcnJheUxpa2VUb0FycmF5IiwidCIsInRvU3RyaW5nIiwiY2FsbCIsInNsaWNlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiQXJyYXkiLCJmcm9tIiwidGVzdCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiaXNBcnJheSIsImxlbmd0aCIsImUiLCJuIiwiaXNQbGFjZWhvbGRlciIsInBhcnQiLCJ0eXBlIiwiZ2V0VGFncyIsInBvc3RQYXJzZWQiLCJ0YWdzIiwic3RhY2siLCJpdGVtcyIsImZpbHRlciIsInBhcmVudHMiLCJwYXRoIiwicHJvY2Vzc0ZpbHRlcmVkIiwiY3VycmVudCIsImZpbHRlcmVkIiwicHVzaCIsImNvbmNhdCIsImRhdGFCb3VuZCIsImF0dHJQYXJzZWQiLCJ2YWx1ZSIsImdldExvY2FsVGFncyIsInNpemVTY29wZSIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsImxvY2FsVGFncyIsImkiLCJnZXRTY29wZVNpemUiLCJyZWR1Y2UiLCJzaXplIiwicGFyZW50IiwibEluZGV4TG9vcCIsImxJbmRleCIsInBhcnNlSW50Iiwic3BsaXQiLCJwb3AiLCJfaTIiLCJfY3VycmVudCRpdGVtczIiLCJfbG9jYWxUYWdzNCIsIl9wYXJ0JHZhbHVlMiIsImtleSIsInN1YnBhcnNlZCIsIl9sb2NhbFRhZ3MiLCJfcGFydCR2YWx1ZSIsImNlbGxQYXJzZWQiLCJfaTQiLCJfcGFydCRjZWxsUG9zdFBhcnNlZDIiLCJjZWxsUG9zdFBhcnNlZCIsImNwIiwibW9kdWxlIiwiX2xvY2FsVGFnczIiLCJfY3AkdmFsdWUiLCJfbG9jYWxUYWdzMyIsIl9jcCR2YWx1ZTIiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/get-tags.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/join-uncorrupt.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/join-uncorrupt.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"), startsWith = _require.startsWith, endsWith = _require.endsWith, isStarting = _require.isStarting, isEnding = _require.isEnding, isWhiteSpace = _require.isWhiteSpace;\nvar filetypes = __webpack_require__(/*! ./filetypes.js */ \"(rsc)/./node_modules/docxtemplater/js/filetypes.js\");\nfunction addEmptyParagraphAfterTable(parts) {\n    var lastNonEmpty = \"\";\n    for(var i = 0, len = parts.length; i < len; i++){\n        var p = parts[i];\n        if (isWhiteSpace(p) || startsWith(p, \"<w:bookmarkEnd\")) {\n            continue;\n        }\n        if (endsWith(lastNonEmpty, \"</w:tbl>\")) {\n            if (!startsWith(p, \"<w:p\") && !startsWith(p, \"<w:tbl\") && !startsWith(p, \"<w:sectPr\")) {\n                p = \"<w:p/>\".concat(p);\n            }\n        }\n        lastNonEmpty = p;\n        parts[i] = p;\n    }\n    return parts;\n}\n// eslint-disable-next-line complexity\nfunction joinUncorrupt(parts, options) {\n    var contains = options.fileTypeConfig.tagShouldContain || [];\n    /*\n   * Before doing this \"uncorruption\" method here, this was done with the\n   * `part.emptyValue` trick, however, there were some corruptions that were\n   * not handled, for example with a template like this :\n   *\n   * ------------------------------------------------\n   * | {-w:p falsy}My para{/falsy}   |              |\n   * | {-w:p falsy}My para{/falsy}   |              |\n   * ------------------------------------------------\n   */ var collecting = \"\";\n    var currentlyCollecting = -1;\n    if (filetypes.docx.indexOf(options.contentType) !== -1) {\n        parts = addEmptyParagraphAfterTable(parts);\n    }\n    var startIndex = -1;\n    for(var j = 0, len2 = contains.length; j < len2; j++){\n        var _contains$j = contains[j], tag = _contains$j.tag, shouldContain = _contains$j.shouldContain, value = _contains$j.value, drop = _contains$j.drop, dropParent = _contains$j.dropParent;\n        for(var i = 0, len = parts.length; i < len; i++){\n            var part = parts[i];\n            if (currentlyCollecting === j) {\n                if (isEnding(part, tag)) {\n                    currentlyCollecting = -1;\n                    if (dropParent) {\n                        var start = -1;\n                        for(var k = startIndex; k > 0; k--){\n                            if (isStarting(parts[k], dropParent)) {\n                                start = k;\n                                break;\n                            }\n                        }\n                        for(var _k = start; _k <= parts.length; _k++){\n                            if (isEnding(parts[_k], dropParent)) {\n                                parts[_k] = \"\";\n                                break;\n                            }\n                            parts[_k] = \"\";\n                        }\n                    } else {\n                        for(var _k2 = startIndex; _k2 <= i; _k2++){\n                            parts[_k2] = \"\";\n                        }\n                        if (!drop) {\n                            parts[i] = collecting + value + part;\n                        }\n                    }\n                }\n                collecting += part;\n                for(var _k3 = 0, len3 = shouldContain.length; _k3 < len3; _k3++){\n                    var sc = shouldContain[_k3];\n                    if (isStarting(part, sc)) {\n                        currentlyCollecting = -1;\n                        break;\n                    }\n                }\n            }\n            if (currentlyCollecting === -1 && isStarting(part, tag) && /*\n       * To verify that the part doesn't have multiple tags,\n       * such as <w:tc><w:p>\n       */ part.substr(1).indexOf(\"<\") === -1) {\n                // self-closing tag such as <w:t/>\n                if (part[part.length - 2] === \"/\") {\n                    parts[i] = \"\";\n                } else {\n                    startIndex = i;\n                    currentlyCollecting = j;\n                    collecting = part;\n                }\n            }\n        }\n    }\n    return parts;\n}\nmodule.exports = joinUncorrupt;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9qb2luLXVuY29ycnVwdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLFdBQVdDLG1CQUFPQSxDQUFDLDBFQUFnQixHQUNyQ0MsYUFBYUYsU0FBU0UsVUFBVSxFQUNoQ0MsV0FBV0gsU0FBU0csUUFBUSxFQUM1QkMsYUFBYUosU0FBU0ksVUFBVSxFQUNoQ0MsV0FBV0wsU0FBU0ssUUFBUSxFQUM1QkMsZUFBZU4sU0FBU00sWUFBWTtBQUN0QyxJQUFJQyxZQUFZTixtQkFBT0EsQ0FBQywwRUFBZ0I7QUFDeEMsU0FBU08sNEJBQTRCQyxLQUFLO0lBQ3hDLElBQUlDLGVBQWU7SUFDbkIsSUFBSyxJQUFJQyxJQUFJLEdBQUdDLE1BQU1ILE1BQU1JLE1BQU0sRUFBRUYsSUFBSUMsS0FBS0QsSUFBSztRQUNoRCxJQUFJRyxJQUFJTCxLQUFLLENBQUNFLEVBQUU7UUFDaEIsSUFBSUwsYUFBYVEsTUFBTVosV0FBV1ksR0FBRyxtQkFBbUI7WUFDdEQ7UUFDRjtRQUNBLElBQUlYLFNBQVNPLGNBQWMsYUFBYTtZQUN0QyxJQUFJLENBQUNSLFdBQVdZLEdBQUcsV0FBVyxDQUFDWixXQUFXWSxHQUFHLGFBQWEsQ0FBQ1osV0FBV1ksR0FBRyxjQUFjO2dCQUNyRkEsSUFBSSxTQUFTQyxNQUFNLENBQUNEO1lBQ3RCO1FBQ0Y7UUFDQUosZUFBZUk7UUFDZkwsS0FBSyxDQUFDRSxFQUFFLEdBQUdHO0lBQ2I7SUFDQSxPQUFPTDtBQUNUO0FBRUEsc0NBQXNDO0FBQ3RDLFNBQVNPLGNBQWNQLEtBQUssRUFBRVEsT0FBTztJQUNuQyxJQUFJQyxXQUFXRCxRQUFRRSxjQUFjLENBQUNDLGdCQUFnQixJQUFJLEVBQUU7SUFDNUQ7Ozs7Ozs7OztHQVNDLEdBQ0QsSUFBSUMsYUFBYTtJQUNqQixJQUFJQyxzQkFBc0IsQ0FBQztJQUMzQixJQUFJZixVQUFVZ0IsSUFBSSxDQUFDQyxPQUFPLENBQUNQLFFBQVFRLFdBQVcsTUFBTSxDQUFDLEdBQUc7UUFDdERoQixRQUFRRCw0QkFBNEJDO0lBQ3RDO0lBQ0EsSUFBSWlCLGFBQWEsQ0FBQztJQUNsQixJQUFLLElBQUlDLElBQUksR0FBR0MsT0FBT1YsU0FBU0wsTUFBTSxFQUFFYyxJQUFJQyxNQUFNRCxJQUFLO1FBQ3JELElBQUlFLGNBQWNYLFFBQVEsQ0FBQ1MsRUFBRSxFQUMzQkcsTUFBTUQsWUFBWUMsR0FBRyxFQUNyQkMsZ0JBQWdCRixZQUFZRSxhQUFhLEVBQ3pDQyxRQUFRSCxZQUFZRyxLQUFLLEVBQ3pCQyxPQUFPSixZQUFZSSxJQUFJLEVBQ3ZCQyxhQUFhTCxZQUFZSyxVQUFVO1FBQ3JDLElBQUssSUFBSXZCLElBQUksR0FBR0MsTUFBTUgsTUFBTUksTUFBTSxFQUFFRixJQUFJQyxLQUFLRCxJQUFLO1lBQ2hELElBQUl3QixPQUFPMUIsS0FBSyxDQUFDRSxFQUFFO1lBQ25CLElBQUlXLHdCQUF3QkssR0FBRztnQkFDN0IsSUFBSXRCLFNBQVM4QixNQUFNTCxNQUFNO29CQUN2QlIsc0JBQXNCLENBQUM7b0JBQ3ZCLElBQUlZLFlBQVk7d0JBQ2QsSUFBSUUsUUFBUSxDQUFDO3dCQUNiLElBQUssSUFBSUMsSUFBSVgsWUFBWVcsSUFBSSxHQUFHQSxJQUFLOzRCQUNuQyxJQUFJakMsV0FBV0ssS0FBSyxDQUFDNEIsRUFBRSxFQUFFSCxhQUFhO2dDQUNwQ0UsUUFBUUM7Z0NBQ1I7NEJBQ0Y7d0JBQ0Y7d0JBQ0EsSUFBSyxJQUFJQyxLQUFLRixPQUFPRSxNQUFNN0IsTUFBTUksTUFBTSxFQUFFeUIsS0FBTTs0QkFDN0MsSUFBSWpDLFNBQVNJLEtBQUssQ0FBQzZCLEdBQUcsRUFBRUosYUFBYTtnQ0FDbkN6QixLQUFLLENBQUM2QixHQUFHLEdBQUc7Z0NBQ1o7NEJBQ0Y7NEJBQ0E3QixLQUFLLENBQUM2QixHQUFHLEdBQUc7d0JBQ2Q7b0JBQ0YsT0FBTzt3QkFDTCxJQUFLLElBQUlDLE1BQU1iLFlBQVlhLE9BQU81QixHQUFHNEIsTUFBTzs0QkFDMUM5QixLQUFLLENBQUM4QixJQUFJLEdBQUc7d0JBQ2Y7d0JBQ0EsSUFBSSxDQUFDTixNQUFNOzRCQUNUeEIsS0FBSyxDQUFDRSxFQUFFLEdBQUdVLGFBQWFXLFFBQVFHO3dCQUNsQztvQkFDRjtnQkFDRjtnQkFDQWQsY0FBY2M7Z0JBQ2QsSUFBSyxJQUFJSyxNQUFNLEdBQUdDLE9BQU9WLGNBQWNsQixNQUFNLEVBQUUyQixNQUFNQyxNQUFNRCxNQUFPO29CQUNoRSxJQUFJRSxLQUFLWCxhQUFhLENBQUNTLElBQUk7b0JBQzNCLElBQUlwQyxXQUFXK0IsTUFBTU8sS0FBSzt3QkFDeEJwQixzQkFBc0IsQ0FBQzt3QkFDdkI7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUNBLElBQUlBLHdCQUF3QixDQUFDLEtBQUtsQixXQUFXK0IsTUFBTUwsUUFDbkQ7OztPQUdDLEdBQ0RLLEtBQUtRLE1BQU0sQ0FBQyxHQUFHbkIsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHO2dCQUNsQyxrQ0FBa0M7Z0JBQ2xDLElBQUlXLElBQUksQ0FBQ0EsS0FBS3RCLE1BQU0sR0FBRyxFQUFFLEtBQUssS0FBSztvQkFDakNKLEtBQUssQ0FBQ0UsRUFBRSxHQUFHO2dCQUNiLE9BQU87b0JBQ0xlLGFBQWFmO29CQUNiVyxzQkFBc0JLO29CQUN0Qk4sYUFBYWM7Z0JBQ2Y7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxPQUFPMUI7QUFDVDtBQUNBbUMsT0FBT0MsT0FBTyxHQUFHN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaWtlLXJlbnRhbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvam9pbi11bmNvcnJ1cHQuanM/ZjY5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpLFxuICBzdGFydHNXaXRoID0gX3JlcXVpcmUuc3RhcnRzV2l0aCxcbiAgZW5kc1dpdGggPSBfcmVxdWlyZS5lbmRzV2l0aCxcbiAgaXNTdGFydGluZyA9IF9yZXF1aXJlLmlzU3RhcnRpbmcsXG4gIGlzRW5kaW5nID0gX3JlcXVpcmUuaXNFbmRpbmcsXG4gIGlzV2hpdGVTcGFjZSA9IF9yZXF1aXJlLmlzV2hpdGVTcGFjZTtcbnZhciBmaWxldHlwZXMgPSByZXF1aXJlKFwiLi9maWxldHlwZXMuanNcIik7XG5mdW5jdGlvbiBhZGRFbXB0eVBhcmFncmFwaEFmdGVyVGFibGUocGFydHMpIHtcbiAgdmFyIGxhc3ROb25FbXB0eSA9IFwiXCI7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwID0gcGFydHNbaV07XG4gICAgaWYgKGlzV2hpdGVTcGFjZShwKSB8fCBzdGFydHNXaXRoKHAsIFwiPHc6Ym9va21hcmtFbmRcIikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZW5kc1dpdGgobGFzdE5vbkVtcHR5LCBcIjwvdzp0Ymw+XCIpKSB7XG4gICAgICBpZiAoIXN0YXJ0c1dpdGgocCwgXCI8dzpwXCIpICYmICFzdGFydHNXaXRoKHAsIFwiPHc6dGJsXCIpICYmICFzdGFydHNXaXRoKHAsIFwiPHc6c2VjdFByXCIpKSB7XG4gICAgICAgIHAgPSBcIjx3OnAvPlwiLmNvbmNhdChwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGFzdE5vbkVtcHR5ID0gcDtcbiAgICBwYXJ0c1tpXSA9IHA7XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gam9pblVuY29ycnVwdChwYXJ0cywgb3B0aW9ucykge1xuICB2YXIgY29udGFpbnMgPSBvcHRpb25zLmZpbGVUeXBlQ29uZmlnLnRhZ1Nob3VsZENvbnRhaW4gfHwgW107XG4gIC8qXG4gICAqIEJlZm9yZSBkb2luZyB0aGlzIFwidW5jb3JydXB0aW9uXCIgbWV0aG9kIGhlcmUsIHRoaXMgd2FzIGRvbmUgd2l0aCB0aGVcbiAgICogYHBhcnQuZW1wdHlWYWx1ZWAgdHJpY2ssIGhvd2V2ZXIsIHRoZXJlIHdlcmUgc29tZSBjb3JydXB0aW9ucyB0aGF0IHdlcmVcbiAgICogbm90IGhhbmRsZWQsIGZvciBleGFtcGxlIHdpdGggYSB0ZW1wbGF0ZSBsaWtlIHRoaXMgOlxuICAgKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogfCB7LXc6cCBmYWxzeX1NeSBwYXJhey9mYWxzeX0gICB8ICAgICAgICAgICAgICB8XG4gICAqIHwgey13OnAgZmFsc3l9TXkgcGFyYXsvZmFsc3l9ICAgfCAgICAgICAgICAgICAgfFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG4gIHZhciBjb2xsZWN0aW5nID0gXCJcIjtcbiAgdmFyIGN1cnJlbnRseUNvbGxlY3RpbmcgPSAtMTtcbiAgaWYgKGZpbGV0eXBlcy5kb2N4LmluZGV4T2Yob3B0aW9ucy5jb250ZW50VHlwZSkgIT09IC0xKSB7XG4gICAgcGFydHMgPSBhZGRFbXB0eVBhcmFncmFwaEFmdGVyVGFibGUocGFydHMpO1xuICB9XG4gIHZhciBzdGFydEluZGV4ID0gLTE7XG4gIGZvciAodmFyIGogPSAwLCBsZW4yID0gY29udGFpbnMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgdmFyIF9jb250YWlucyRqID0gY29udGFpbnNbal0sXG4gICAgICB0YWcgPSBfY29udGFpbnMkai50YWcsXG4gICAgICBzaG91bGRDb250YWluID0gX2NvbnRhaW5zJGouc2hvdWxkQ29udGFpbixcbiAgICAgIHZhbHVlID0gX2NvbnRhaW5zJGoudmFsdWUsXG4gICAgICBkcm9wID0gX2NvbnRhaW5zJGouZHJvcCxcbiAgICAgIGRyb3BQYXJlbnQgPSBfY29udGFpbnMkai5kcm9wUGFyZW50O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGlmIChjdXJyZW50bHlDb2xsZWN0aW5nID09PSBqKSB7XG4gICAgICAgIGlmIChpc0VuZGluZyhwYXJ0LCB0YWcpKSB7XG4gICAgICAgICAgY3VycmVudGx5Q29sbGVjdGluZyA9IC0xO1xuICAgICAgICAgIGlmIChkcm9wUGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSAtMTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSBzdGFydEluZGV4OyBrID4gMDsgay0tKSB7XG4gICAgICAgICAgICAgIGlmIChpc1N0YXJ0aW5nKHBhcnRzW2tdLCBkcm9wUGFyZW50KSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gaztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2sgPSBzdGFydDsgX2sgPD0gcGFydHMubGVuZ3RoOyBfaysrKSB7XG4gICAgICAgICAgICAgIGlmIChpc0VuZGluZyhwYXJ0c1tfa10sIGRyb3BQYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgcGFydHNbX2tdID0gXCJcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJ0c1tfa10gPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfazIgPSBzdGFydEluZGV4OyBfazIgPD0gaTsgX2syKyspIHtcbiAgICAgICAgICAgICAgcGFydHNbX2syXSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRyb3ApIHtcbiAgICAgICAgICAgICAgcGFydHNbaV0gPSBjb2xsZWN0aW5nICsgdmFsdWUgKyBwYXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb2xsZWN0aW5nICs9IHBhcnQ7XG4gICAgICAgIGZvciAodmFyIF9rMyA9IDAsIGxlbjMgPSBzaG91bGRDb250YWluLmxlbmd0aDsgX2szIDwgbGVuMzsgX2szKyspIHtcbiAgICAgICAgICB2YXIgc2MgPSBzaG91bGRDb250YWluW19rM107XG4gICAgICAgICAgaWYgKGlzU3RhcnRpbmcocGFydCwgc2MpKSB7XG4gICAgICAgICAgICBjdXJyZW50bHlDb2xsZWN0aW5nID0gLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50bHlDb2xsZWN0aW5nID09PSAtMSAmJiBpc1N0YXJ0aW5nKHBhcnQsIHRhZykgJiZcbiAgICAgIC8qXG4gICAgICAgKiBUbyB2ZXJpZnkgdGhhdCB0aGUgcGFydCBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgdGFncyxcbiAgICAgICAqIHN1Y2ggYXMgPHc6dGM+PHc6cD5cbiAgICAgICAqL1xuICAgICAgcGFydC5zdWJzdHIoMSkuaW5kZXhPZihcIjxcIikgPT09IC0xKSB7XG4gICAgICAgIC8vIHNlbGYtY2xvc2luZyB0YWcgc3VjaCBhcyA8dzp0Lz5cbiAgICAgICAgaWYgKHBhcnRbcGFydC5sZW5ndGggLSAyXSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICBwYXJ0c1tpXSA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhcnRJbmRleCA9IGk7XG4gICAgICAgICAgY3VycmVudGx5Q29sbGVjdGluZyA9IGo7XG4gICAgICAgICAgY29sbGVjdGluZyA9IHBhcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufVxubW9kdWxlLmV4cG9ydHMgPSBqb2luVW5jb3JydXB0OyJdLCJuYW1lcyI6WyJfcmVxdWlyZSIsInJlcXVpcmUiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJpc1N0YXJ0aW5nIiwiaXNFbmRpbmciLCJpc1doaXRlU3BhY2UiLCJmaWxldHlwZXMiLCJhZGRFbXB0eVBhcmFncmFwaEFmdGVyVGFibGUiLCJwYXJ0cyIsImxhc3ROb25FbXB0eSIsImkiLCJsZW4iLCJsZW5ndGgiLCJwIiwiY29uY2F0Iiwiam9pblVuY29ycnVwdCIsIm9wdGlvbnMiLCJjb250YWlucyIsImZpbGVUeXBlQ29uZmlnIiwidGFnU2hvdWxkQ29udGFpbiIsImNvbGxlY3RpbmciLCJjdXJyZW50bHlDb2xsZWN0aW5nIiwiZG9jeCIsImluZGV4T2YiLCJjb250ZW50VHlwZSIsInN0YXJ0SW5kZXgiLCJqIiwibGVuMiIsIl9jb250YWlucyRqIiwidGFnIiwic2hvdWxkQ29udGFpbiIsInZhbHVlIiwiZHJvcCIsImRyb3BQYXJlbnQiLCJwYXJ0Iiwic3RhcnQiLCJrIiwiX2siLCJfazIiLCJfazMiLCJsZW4zIiwic2MiLCJzdWJzdHIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/join-uncorrupt.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/lexer.js":
/*!************************************************!*\
  !*** ./node_modules/docxtemplater/js/lexer.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _slicedToArray(r, e) {\n    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(r, a) {\n    if (r) {\n        if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n        var t = ({}).toString.call(r).slice(8, -1);\n        return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n    }\n}\nfunction _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];\n    return n;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(r) {\n    if (Array.isArray(r)) return r;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar _require = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\"), getUnclosedTagException = _require.getUnclosedTagException, getUnopenedTagException = _require.getUnopenedTagException, getDuplicateOpenTagException = _require.getDuplicateOpenTagException, getDuplicateCloseTagException = _require.getDuplicateCloseTagException, throwMalformedXml = _require.throwMalformedXml, throwXmlInvalid = _require.throwXmlInvalid, XTTemplateError = _require.XTTemplateError;\nvar _require2 = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"), isTextStart = _require2.isTextStart, isTextEnd = _require2.isTextEnd, wordToUtf8 = _require2.wordToUtf8, pushArray = _require2.pushArray;\nvar DELIMITER_NONE = 0, DELIMITER_EQUAL = 1, DELIMITER_START = 2, DELIMITER_END = 3;\nfunction inRange(range, match) {\n    return range[0] <= match.offset && match.offset < range[1];\n}\nfunction updateInTextTag(part, inTextTag) {\n    if (isTextStart(part)) {\n        if (inTextTag) {\n            throwMalformedXml();\n        }\n        return true;\n    }\n    if (isTextEnd(part)) {\n        if (!inTextTag) {\n            throwMalformedXml();\n        }\n        return false;\n    }\n    return inTextTag;\n}\nfunction getTag(tag) {\n    var position = \"\";\n    var start = 1;\n    var end = tag.indexOf(\" \");\n    if (tag[tag.length - 2] === \"/\") {\n        position = \"selfclosing\";\n        if (end === -1) {\n            end = tag.length - 2;\n        }\n    } else if (tag[1] === \"/\") {\n        start = 2;\n        position = \"end\";\n        if (end === -1) {\n            end = tag.length - 1;\n        }\n    } else {\n        position = \"start\";\n        if (end === -1) {\n            end = tag.length - 1;\n        }\n    }\n    return {\n        tag: tag.slice(start, end),\n        position: position\n    };\n}\nfunction tagMatcher(content, textMatchArray, othersMatchArray) {\n    var cursor = 0;\n    var contentLength = content.length;\n    var allMatches = {};\n    for(var _i2 = 0; _i2 < textMatchArray.length; _i2++){\n        var m = textMatchArray[_i2];\n        allMatches[m] = true;\n    }\n    for(var _i4 = 0; _i4 < othersMatchArray.length; _i4++){\n        var _m = othersMatchArray[_i4];\n        allMatches[_m] = false;\n    }\n    var totalMatches = [];\n    while(cursor < contentLength){\n        cursor = content.indexOf(\"<\", cursor);\n        if (cursor === -1) {\n            break;\n        }\n        var offset = cursor;\n        var nextOpening = content.indexOf(\"<\", cursor + 1);\n        cursor = content.indexOf(\">\", cursor);\n        if (cursor === -1 || nextOpening !== -1 && cursor > nextOpening) {\n            throwXmlInvalid(content, offset);\n        }\n        var tagText = content.slice(offset, cursor + 1);\n        var _getTag = getTag(tagText), tag = _getTag.tag, position = _getTag.position;\n        var text = allMatches[tag];\n        if (text == null) {\n            continue;\n        }\n        totalMatches.push({\n            type: \"tag\",\n            position: position,\n            text: text,\n            offset: offset,\n            value: tagText,\n            tag: tag\n        });\n    }\n    return totalMatches;\n}\nfunction getDelimiterErrors(delimiterMatches, fullText, syntaxOptions) {\n    var errors = [];\n    var inDelimiter = false;\n    var lastDelimiterMatch = {\n        offset: 0\n    };\n    var xtag;\n    var delimiterWithErrors = delimiterMatches.reduce(function(delimiterAcc, currDelimiterMatch) {\n        var position = currDelimiterMatch.position;\n        var delimiterOffset = currDelimiterMatch.offset;\n        var lastDelimiterOffset = lastDelimiterMatch.offset;\n        var lastDelimiterLength = lastDelimiterMatch.length;\n        xtag = fullText.substr(lastDelimiterOffset, delimiterOffset - lastDelimiterOffset);\n        if (inDelimiter && position === \"start\") {\n            if (lastDelimiterOffset + lastDelimiterLength === delimiterOffset) {\n                xtag = fullText.substr(lastDelimiterOffset, delimiterOffset - lastDelimiterOffset + lastDelimiterLength + 4);\n                if (!syntaxOptions.allowUnclosedTag) {\n                    errors.push(getDuplicateOpenTagException({\n                        xtag: xtag,\n                        offset: lastDelimiterOffset\n                    }));\n                    lastDelimiterMatch = currDelimiterMatch;\n                    delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n                        error: true\n                    }));\n                    return delimiterAcc;\n                }\n            }\n            if (!syntaxOptions.allowUnclosedTag) {\n                errors.push(getUnclosedTagException({\n                    xtag: wordToUtf8(xtag),\n                    offset: lastDelimiterOffset\n                }));\n                lastDelimiterMatch = currDelimiterMatch;\n                delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n                    error: true\n                }));\n                return delimiterAcc;\n            }\n            delimiterAcc.pop();\n        }\n        if (!inDelimiter && position === \"end\") {\n            if (syntaxOptions.allowUnopenedTag) {\n                return delimiterAcc;\n            }\n            if (lastDelimiterOffset + lastDelimiterLength === delimiterOffset) {\n                xtag = fullText.substr(lastDelimiterOffset - 4, delimiterOffset - lastDelimiterOffset + lastDelimiterLength + 4);\n                errors.push(getDuplicateCloseTagException({\n                    xtag: xtag,\n                    offset: lastDelimiterOffset\n                }));\n                lastDelimiterMatch = currDelimiterMatch;\n                delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n                    error: true\n                }));\n                return delimiterAcc;\n            }\n            errors.push(getUnopenedTagException({\n                xtag: xtag,\n                offset: delimiterOffset\n            }));\n            lastDelimiterMatch = currDelimiterMatch;\n            delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n                error: true\n            }));\n            return delimiterAcc;\n        }\n        inDelimiter = position === \"start\";\n        lastDelimiterMatch = currDelimiterMatch;\n        delimiterAcc.push(currDelimiterMatch);\n        return delimiterAcc;\n    }, []);\n    if (inDelimiter) {\n        var lastDelimiterOffset = lastDelimiterMatch.offset;\n        xtag = fullText.substr(lastDelimiterOffset, fullText.length - lastDelimiterOffset);\n        if (!syntaxOptions.allowUnclosedTag) {\n            errors.push(getUnclosedTagException({\n                xtag: wordToUtf8(xtag),\n                offset: lastDelimiterOffset\n            }));\n        } else {\n            delimiterWithErrors.pop();\n        }\n    }\n    return {\n        delimiterWithErrors: delimiterWithErrors,\n        errors: errors\n    };\n}\nfunction compareOffsets(startOffset, endOffset) {\n    if (startOffset === -1 && endOffset === -1) {\n        return DELIMITER_NONE;\n    }\n    if (startOffset === endOffset) {\n        return DELIMITER_EQUAL;\n    }\n    if (startOffset === -1 || endOffset === -1) {\n        return endOffset < startOffset ? DELIMITER_START : DELIMITER_END;\n    }\n    return startOffset < endOffset ? DELIMITER_START : DELIMITER_END;\n}\nfunction splitDelimiters(inside) {\n    var newDelimiters = inside.split(\" \");\n    if (newDelimiters.length !== 2) {\n        var err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n        err.properties = {\n            id: \"change_delimiters_invalid\",\n            explanation: \"Cannot parser delimiters\"\n        };\n        throw err;\n    }\n    var _newDelimiters = _slicedToArray(newDelimiters, 2), start = _newDelimiters[0], end = _newDelimiters[1];\n    if (start.length === 0 || end.length === 0) {\n        var _err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n        _err.properties = {\n            id: \"change_delimiters_invalid\",\n            explanation: \"Cannot parser delimiters\"\n        };\n        throw _err;\n    }\n    return [\n        start,\n        end\n    ];\n}\nfunction getAllDelimiterIndexes(fullText, delimiters, syntaxOptions) {\n    var indexes = [];\n    var start = delimiters.start, end = delimiters.end;\n    var offset = -1;\n    var insideTag = false;\n    if (start == null && end == null) {\n        // Special case of delimiter set to null/null, no templating is done\n        return [];\n    }\n    while(true){\n        var startOffset = fullText.indexOf(start, offset + 1);\n        var endOffset = fullText.indexOf(end, offset + 1);\n        var position = null;\n        var len = void 0;\n        var compareResult = compareOffsets(startOffset, endOffset);\n        if (compareResult === DELIMITER_EQUAL) {\n            compareResult = insideTag ? DELIMITER_END : DELIMITER_START;\n        }\n        switch(compareResult){\n            case DELIMITER_NONE:\n                return indexes;\n            case DELIMITER_END:\n                insideTag = false;\n                offset = endOffset;\n                position = \"end\";\n                len = end.length;\n                break;\n            case DELIMITER_START:\n                insideTag = true;\n                offset = startOffset;\n                position = \"start\";\n                len = start.length;\n                break;\n        }\n        /*\n     * If tag starts with =, such as {=[ ]=}\n     * then the delimiters will change right after that tag.\n     *\n     * For example, with the following template :\n     *\n     * Hello {foo}, {=[ ]=}what's up with [name] ?\n     *\n     * The \"foo\" tag is a normal tag, the \"=[ ]=\" is a tag to change the\n     * delimiters to \"[\" and \"]\", and the last \"name\" is a tag with the new\n     * delimiters\n     */ if (syntaxOptions.changeDelimiterPrefix && compareResult === DELIMITER_START && fullText[offset + start.length] === syntaxOptions.changeDelimiterPrefix) {\n            indexes.push({\n                offset: startOffset,\n                position: \"start\",\n                length: start.length,\n                changedelimiter: true\n            });\n            var nextEqual = fullText.indexOf(syntaxOptions.changeDelimiterPrefix, offset + start.length + 1);\n            var nextEndOffset = fullText.indexOf(end, nextEqual + 1);\n            indexes.push({\n                offset: nextEndOffset,\n                position: \"end\",\n                length: end.length,\n                changedelimiter: true\n            });\n            var _insideTag = fullText.substr(offset + start.length + 1, nextEqual - offset - start.length - 1);\n            var _splitDelimiters = splitDelimiters(_insideTag);\n            var _splitDelimiters2 = _slicedToArray(_splitDelimiters, 2);\n            start = _splitDelimiters2[0];\n            end = _splitDelimiters2[1];\n            offset = nextEndOffset;\n            continue;\n        }\n        indexes.push({\n            offset: offset,\n            position: position,\n            length: len\n        });\n    }\n}\nfunction parseDelimiters(innerContentParts, delimiters, syntaxOptions) {\n    var full = innerContentParts.map(function(p) {\n        return p.value;\n    }).join(\"\");\n    var delimiterMatches = getAllDelimiterIndexes(full, delimiters, syntaxOptions);\n    var offset = 0;\n    var ranges = innerContentParts.map(function(part) {\n        offset += part.value.length;\n        return {\n            offset: offset - part.value.length,\n            lIndex: part.lIndex\n        };\n    });\n    var _getDelimiterErrors = getDelimiterErrors(delimiterMatches, full, syntaxOptions), delimiterWithErrors = _getDelimiterErrors.delimiterWithErrors, errors = _getDelimiterErrors.errors;\n    var cutNext = 0;\n    var delimiterIndex = 0;\n    var parsed = ranges.map(function(p, i) {\n        var offset = p.offset;\n        var range = [\n            offset,\n            offset + innerContentParts[i].value.length\n        ];\n        var partContent = innerContentParts[i].value;\n        var delimitersInOffset = [];\n        while(delimiterIndex < delimiterWithErrors.length && inRange(range, delimiterWithErrors[delimiterIndex])){\n            delimitersInOffset.push(delimiterWithErrors[delimiterIndex]);\n            delimiterIndex++;\n        }\n        var parts = [];\n        var cursor = 0;\n        if (cutNext > 0) {\n            cursor = cutNext;\n            cutNext = 0;\n        }\n        for(var _i6 = 0; _i6 < delimitersInOffset.length; _i6++){\n            var delimiterInOffset = delimitersInOffset[_i6];\n            var _value = partContent.substr(cursor, delimiterInOffset.offset - offset - cursor);\n            if (delimiterInOffset.changedelimiter) {\n                if (delimiterInOffset.position === \"start\") {\n                    if (_value.length > 0) {\n                        parts.push({\n                            type: \"content\",\n                            value: _value\n                        });\n                    }\n                } else {\n                    cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n                }\n                continue;\n            }\n            if (_value.length > 0) {\n                parts.push({\n                    type: \"content\",\n                    value: _value\n                });\n                cursor += _value.length;\n            }\n            var delimiterPart = {\n                type: \"delimiter\",\n                position: delimiterInOffset.position,\n                offset: cursor + offset\n            };\n            parts.push(delimiterPart);\n            cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n        }\n        cutNext = cursor - partContent.length;\n        var value = partContent.substr(cursor);\n        if (value.length > 0) {\n            parts.push({\n                type: \"content\",\n                value: value\n            });\n        }\n        return parts;\n    }, this);\n    return {\n        parsed: parsed,\n        errors: errors\n    };\n}\nfunction isInsideContent(part) {\n    // Stryker disable all : because the part.position === \"insidetag\" would be enough but we want to make the API future proof\n    return part.type === \"content\" && part.position === \"insidetag\";\n// Stryker restore all\n}\nfunction getContentParts(xmlparsed) {\n    return xmlparsed.filter(isInsideContent);\n}\nfunction decodeContentParts(xmlparsed, fileType) {\n    var inTextTag = false;\n    for(var _i8 = 0; _i8 < xmlparsed.length; _i8++){\n        var part = xmlparsed[_i8];\n        inTextTag = updateInTextTag(part, inTextTag);\n        if (part.type === \"content\") {\n            part.position = inTextTag ? \"insidetag\" : \"outsidetag\";\n        }\n        if (fileType !== \"text\" && isInsideContent(part)) {\n            part.value = part.value.replace(/>/g, \"&gt;\");\n        }\n    }\n}\nmodule.exports = {\n    parseDelimiters: parseDelimiters,\n    parse: function parse(xmllexed, delimiters, syntax, fileType) {\n        decodeContentParts(xmllexed, fileType);\n        var _parseDelimiters = parseDelimiters(getContentParts(xmllexed), delimiters, syntax), delimiterParsed = _parseDelimiters.parsed, errors = _parseDelimiters.errors;\n        var lexed = [];\n        var index = 0;\n        var lIndex = 0;\n        for(var _i10 = 0; _i10 < xmllexed.length; _i10++){\n            var part = xmllexed[_i10];\n            if (isInsideContent(part)) {\n                for(var _i12 = 0, _delimiterParsed$inde2 = delimiterParsed[index]; _i12 < _delimiterParsed$inde2.length; _i12++){\n                    var p = _delimiterParsed$inde2[_i12];\n                    if (p.type === \"content\") {\n                        p.position = \"insidetag\";\n                    }\n                    p.lIndex = lIndex++;\n                }\n                pushArray(lexed, delimiterParsed[index]);\n                index++;\n            } else {\n                part.lIndex = lIndex++;\n                lexed.push(part);\n            }\n        }\n        return {\n            errors: errors,\n            lexed: lexed\n        };\n    },\n    xmlparse: function xmlparse(content, xmltags) {\n        var matches = tagMatcher(content, xmltags.text, xmltags.other);\n        var cursor = 0;\n        var parsed = matches.reduce(function(parsed, match) {\n            if (content.length > cursor && match.offset - cursor > 0) {\n                parsed.push({\n                    type: \"content\",\n                    value: content.substr(cursor, match.offset - cursor)\n                });\n            }\n            cursor = match.offset + match.value.length;\n            delete match.offset;\n            parsed.push(match);\n            return parsed;\n        }, []);\n        if (content.length > cursor) {\n            parsed.push({\n                type: \"content\",\n                value: content.substr(cursor)\n            });\n        }\n        return parsed;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9sZXhlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSyxlQUFlQyxDQUFDLEVBQUVDLENBQUM7SUFBSSxPQUFPQyxnQkFBZ0JGLE1BQU1HLHNCQUFzQkgsR0FBR0MsTUFBTUcsNEJBQTRCSixHQUFHQyxNQUFNSTtBQUFvQjtBQUNySixTQUFTQTtJQUFxQixNQUFNLElBQUlDLFVBQVU7QUFBOEk7QUFDaE0sU0FBU0YsNEJBQTRCSixDQUFDLEVBQUVPLENBQUM7SUFBSSxJQUFJUCxHQUFHO1FBQUUsSUFBSSxZQUFZLE9BQU9BLEdBQUcsT0FBT1Esa0JBQWtCUixHQUFHTztRQUFJLElBQUlFLElBQUksRUFBQyxHQUFFQyxRQUFRLENBQUNDLElBQUksQ0FBQ1gsR0FBR1ksS0FBSyxDQUFDLEdBQUcsQ0FBQztRQUFJLE9BQU8sYUFBYUgsS0FBS1QsRUFBRUgsV0FBVyxJQUFLWSxDQUFBQSxJQUFJVCxFQUFFSCxXQUFXLENBQUNnQixJQUFJLEdBQUcsVUFBVUosS0FBSyxVQUFVQSxJQUFJSyxNQUFNQyxJQUFJLENBQUNmLEtBQUssZ0JBQWdCUyxLQUFLLDJDQUEyQ08sSUFBSSxDQUFDUCxLQUFLRCxrQkFBa0JSLEdBQUdPLEtBQUssS0FBSztJQUFHO0FBQUU7QUFDelgsU0FBU0Msa0JBQWtCUixDQUFDLEVBQUVPLENBQUM7SUFBSyxTQUFRQSxLQUFLQSxJ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RCxNQUFNQyxNQUFNO1lBQ25Cb0YsT0FBT2pJLElBQUksQ0FBQzRDO1lBQ1osT0FBT3FGO1FBQ1QsR0FBRyxFQUFFO1FBQ0wsSUFBSXpFLFFBQVFqRSxNQUFNLEdBQUdvRSxRQUFRO1lBQzNCc0UsT0FBT2pJLElBQUksQ0FBQztnQkFDVnVFLE1BQU07Z0JBQ050RSxPQUFPdUQsUUFBUStCLE1BQU0sQ0FBQzVCO1lBQ3hCO1FBQ0Y7UUFDQSxPQUFPc0U7SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlrZS1yZW50YWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2xleGVyLmpzP2UyNGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpLFxuICBnZXRVbmNsb3NlZFRhZ0V4Y2VwdGlvbiA9IF9yZXF1aXJlLmdldFVuY2xvc2VkVGFnRXhjZXB0aW9uLFxuICBnZXRVbm9wZW5lZFRhZ0V4Y2VwdGlvbiA9IF9yZXF1aXJlLmdldFVub3BlbmVkVGFnRXhjZXB0aW9uLFxuICBnZXREdXBsaWNhdGVPcGVuVGFnRXhjZXB0aW9uID0gX3JlcXVpcmUuZ2V0RHVwbGljYXRlT3BlblRhZ0V4Y2VwdGlvbixcbiAgZ2V0RHVwbGljYXRlQ2xvc2VUYWdFeGNlcHRpb24gPSBfcmVxdWlyZS5nZXREdXBsaWNhdGVDbG9zZVRhZ0V4Y2VwdGlvbixcbiAgdGhyb3dNYWxmb3JtZWRYbWwgPSBfcmVxdWlyZS50aHJvd01hbGZvcm1lZFhtbCxcbiAgdGhyb3dYbWxJbnZhbGlkID0gX3JlcXVpcmUudGhyb3dYbWxJbnZhbGlkLFxuICBYVFRlbXBsYXRlRXJyb3IgPSBfcmVxdWlyZS5YVFRlbXBsYXRlRXJyb3I7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpLFxuICBpc1RleHRTdGFydCA9IF9yZXF1aXJlMi5pc1RleHRTdGFydCxcbiAgaXNUZXh0RW5kID0gX3JlcXVpcmUyLmlzVGV4dEVuZCxcbiAgd29yZFRvVXRmOCA9IF9yZXF1aXJlMi53b3JkVG9VdGY4LFxuICBwdXNoQXJyYXkgPSBfcmVxdWlyZTIucHVzaEFycmF5O1xudmFyIERFTElNSVRFUl9OT05FID0gMCxcbiAgREVMSU1JVEVSX0VRVUFMID0gMSxcbiAgREVMSU1JVEVSX1NUQVJUID0gMixcbiAgREVMSU1JVEVSX0VORCA9IDM7XG5mdW5jdGlvbiBpblJhbmdlKHJhbmdlLCBtYXRjaCkge1xuICByZXR1cm4gcmFuZ2VbMF0gPD0gbWF0Y2gub2Zmc2V0ICYmIG1hdGNoLm9mZnNldCA8IHJhbmdlWzFdO1xufVxuZnVuY3Rpb24gdXBkYXRlSW5UZXh0VGFnKHBhcnQsIGluVGV4dFRhZykge1xuICBpZiAoaXNUZXh0U3RhcnQocGFydCkpIHtcbiAgICBpZiAoaW5UZXh0VGFnKSB7XG4gICAgICB0aHJvd01hbGZvcm1lZFhtbCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNUZXh0RW5kKHBhcnQpKSB7XG4gICAgaWYgKCFpblRleHRUYWcpIHtcbiAgICAgIHRocm93TWFsZm9ybWVkWG1sKCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaW5UZXh0VGFnO1xufVxuZnVuY3Rpb24gZ2V0VGFnKHRhZykge1xuICB2YXIgcG9zaXRpb24gPSBcIlwiO1xuICB2YXIgc3RhcnQgPSAxO1xuICB2YXIgZW5kID0gdGFnLmluZGV4T2YoXCIgXCIpO1xuICBpZiAodGFnW3RhZy5sZW5ndGggLSAyXSA9PT0gXCIvXCIpIHtcbiAgICBwb3NpdGlvbiA9IFwic2VsZmNsb3NpbmdcIjtcbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgZW5kID0gdGFnLmxlbmd0aCAtIDI7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhZ1sxXSA9PT0gXCIvXCIpIHtcbiAgICBzdGFydCA9IDI7XG4gICAgcG9zaXRpb24gPSBcImVuZFwiO1xuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICBlbmQgPSB0YWcubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcG9zaXRpb24gPSBcInN0YXJ0XCI7XG4gICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIGVuZCA9IHRhZy5sZW5ndGggLSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHRhZzogdGFnLnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICB9O1xufVxuZnVuY3Rpb24gdGFnTWF0Y2hlcihjb250ZW50LCB0ZXh0TWF0Y2hBcnJheSwgb3RoZXJzTWF0Y2hBcnJheSkge1xuICB2YXIgY3Vyc29yID0gMDtcbiAgdmFyIGNvbnRlbnRMZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgdmFyIGFsbE1hdGNoZXMgPSB7fTtcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdGV4dE1hdGNoQXJyYXkubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBtID0gdGV4dE1hdGNoQXJyYXlbX2kyXTtcbiAgICBhbGxNYXRjaGVzW21dID0gdHJ1ZTtcbiAgfVxuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBvdGhlcnNNYXRjaEFycmF5Lmxlbmd0aDsgX2k0KyspIHtcbiAgICB2YXIgX20gPSBvdGhlcnNNYXRjaEFycmF5W19pNF07XG4gICAgYWxsTWF0Y2hlc1tfbV0gPSBmYWxzZTtcbiAgfVxuICB2YXIgdG90YWxNYXRjaGVzID0gW107XG4gIHdoaWxlIChjdXJzb3IgPCBjb250ZW50TGVuZ3RoKSB7XG4gICAgY3Vyc29yID0gY29udGVudC5pbmRleE9mKFwiPFwiLCBjdXJzb3IpO1xuICAgIGlmIChjdXJzb3IgPT09IC0xKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIG9mZnNldCA9IGN1cnNvcjtcbiAgICB2YXIgbmV4dE9wZW5pbmcgPSBjb250ZW50LmluZGV4T2YoXCI8XCIsIGN1cnNvciArIDEpO1xuICAgIGN1cnNvciA9IGNvbnRlbnQuaW5kZXhPZihcIj5cIiwgY3Vyc29yKTtcbiAgICBpZiAoY3Vyc29yID09PSAtMSB8fCBuZXh0T3BlbmluZyAhPT0gLTEgJiYgY3Vyc29yID4gbmV4dE9wZW5pbmcpIHtcbiAgICAgIHRocm93WG1sSW52YWxpZChjb250ZW50LCBvZmZzZXQpO1xuICAgIH1cbiAgICB2YXIgdGFnVGV4dCA9IGNvbnRlbnQuc2xpY2Uob2Zmc2V0LCBjdXJzb3IgKyAxKTtcbiAgICB2YXIgX2dldFRhZyA9IGdldFRhZyh0YWdUZXh0KSxcbiAgICAgIHRhZyA9IF9nZXRUYWcudGFnLFxuICAgICAgcG9zaXRpb24gPSBfZ2V0VGFnLnBvc2l0aW9uO1xuICAgIHZhciB0ZXh0ID0gYWxsTWF0Y2hlc1t0YWddO1xuICAgIGlmICh0ZXh0ID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0b3RhbE1hdGNoZXMucHVzaCh7XG4gICAgICB0eXBlOiBcInRhZ1wiLFxuICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgdmFsdWU6IHRhZ1RleHQsXG4gICAgICB0YWc6IHRhZ1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0b3RhbE1hdGNoZXM7XG59XG5mdW5jdGlvbiBnZXREZWxpbWl0ZXJFcnJvcnMoZGVsaW1pdGVyTWF0Y2hlcywgZnVsbFRleHQsIHN5bnRheE9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgaW5EZWxpbWl0ZXIgPSBmYWxzZTtcbiAgdmFyIGxhc3REZWxpbWl0ZXJNYXRjaCA9IHtcbiAgICBvZmZzZXQ6IDBcbiAgfTtcbiAgdmFyIHh0YWc7XG4gIHZhciBkZWxpbWl0ZXJXaXRoRXJyb3JzID0gZGVsaW1pdGVyTWF0Y2hlcy5yZWR1Y2UoZnVuY3Rpb24gKGRlbGltaXRlckFjYywgY3VyckRlbGltaXRlck1hdGNoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gY3VyckRlbGltaXRlck1hdGNoLnBvc2l0aW9uO1xuICAgIHZhciBkZWxpbWl0ZXJPZmZzZXQgPSBjdXJyRGVsaW1pdGVyTWF0Y2gub2Zmc2V0O1xuICAgIHZhciBsYXN0RGVsaW1pdGVyT2Zmc2V0ID0gbGFzdERlbGltaXRlck1hdGNoLm9mZnNldDtcbiAgICB2YXIgbGFzdERlbGltaXRlckxlbmd0aCA9IGxhc3REZWxpbWl0ZXJNYXRjaC5sZW5ndGg7XG4gICAgeHRhZyA9IGZ1bGxUZXh0LnN1YnN0cihsYXN0RGVsaW1pdGVyT2Zmc2V0LCBkZWxpbWl0ZXJPZmZzZXQgLSBsYXN0RGVsaW1pdGVyT2Zmc2V0KTtcbiAgICBpZiAoaW5EZWxpbWl0ZXIgJiYgcG9zaXRpb24gPT09IFwic3RhcnRcIikge1xuICAgICAgaWYgKGxhc3REZWxpbWl0ZXJPZmZzZXQgKyBsYXN0RGVsaW1pdGVyTGVuZ3RoID09PSBkZWxpbWl0ZXJPZmZzZXQpIHtcbiAgICAgICAgeHRhZyA9IGZ1bGxUZXh0LnN1YnN0cihsYXN0RGVsaW1pdGVyT2Zmc2V0LCBkZWxpbWl0ZXJPZmZzZXQgLSBsYXN0RGVsaW1pdGVyT2Zmc2V0ICsgbGFzdERlbGltaXRlckxlbmd0aCArIDQpO1xuICAgICAgICBpZiAoIXN5bnRheE9wdGlvbnMuYWxsb3dVbmNsb3NlZFRhZykge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGdldER1cGxpY2F0ZU9wZW5UYWdFeGNlcHRpb24oe1xuICAgICAgICAgICAgeHRhZzogeHRhZyxcbiAgICAgICAgICAgIG9mZnNldDogbGFzdERlbGltaXRlck9mZnNldFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBsYXN0RGVsaW1pdGVyTWF0Y2ggPSBjdXJyRGVsaW1pdGVyTWF0Y2g7XG4gICAgICAgICAgZGVsaW1pdGVyQWNjLnB1c2goX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjdXJyRGVsaW1pdGVyTWF0Y2gpLCB7fSwge1xuICAgICAgICAgICAgZXJyb3I6IHRydWVcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuIGRlbGltaXRlckFjYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFzeW50YXhPcHRpb25zLmFsbG93VW5jbG9zZWRUYWcpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZ2V0VW5jbG9zZWRUYWdFeGNlcHRpb24oe1xuICAgICAgICAgIHh0YWc6IHdvcmRUb1V0ZjgoeHRhZyksXG4gICAgICAgICAgb2Zmc2V0OiBsYXN0RGVsaW1pdGVyT2Zmc2V0XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGFzdERlbGltaXRlck1hdGNoID0gY3VyckRlbGltaXRlck1hdGNoO1xuICAgICAgICBkZWxpbWl0ZXJBY2MucHVzaChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGN1cnJEZWxpbWl0ZXJNYXRjaCksIHt9LCB7XG4gICAgICAgICAgZXJyb3I6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZGVsaW1pdGVyQWNjO1xuICAgICAgfVxuICAgICAgZGVsaW1pdGVyQWNjLnBvcCgpO1xuICAgIH1cbiAgICBpZiAoIWluRGVsaW1pdGVyICYmIHBvc2l0aW9uID09PSBcImVuZFwiKSB7XG4gICAgICBpZiAoc3ludGF4T3B0aW9ucy5hbGxvd1Vub3BlbmVkVGFnKSB7XG4gICAgICAgIHJldHVybiBkZWxpbWl0ZXJBY2M7XG4gICAgICB9XG4gICAgICBpZiAobGFzdERlbGltaXRlck9mZnNldCArIGxhc3REZWxpbWl0ZXJMZW5ndGggPT09IGRlbGltaXRlck9mZnNldCkge1xuICAgICAgICB4dGFnID0gZnVsbFRleHQuc3Vic3RyKGxhc3REZWxpbWl0ZXJPZmZzZXQgLSA0LCBkZWxpbWl0ZXJPZmZzZXQgLSBsYXN0RGVsaW1pdGVyT2Zmc2V0ICsgbGFzdERlbGltaXRlckxlbmd0aCArIDQpO1xuICAgICAgICBlcnJvcnMucHVzaChnZXREdXBsaWNhdGVDbG9zZVRhZ0V4Y2VwdGlvbih7XG4gICAgICAgICAgeHRhZzogeHRhZyxcbiAgICAgICAgICBvZmZzZXQ6IGxhc3REZWxpbWl0ZXJPZmZzZXRcbiAgICAgICAgfSkpO1xuICAgICAgICBsYXN0RGVsaW1pdGVyTWF0Y2ggPSBjdXJyRGVsaW1pdGVyTWF0Y2g7XG4gICAgICAgIGRlbGltaXRlckFjYy5wdXNoKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY3VyckRlbGltaXRlck1hdGNoKSwge30sIHtcbiAgICAgICAgICBlcnJvcjogdHJ1ZVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBkZWxpbWl0ZXJBY2M7XG4gICAgICB9XG4gICAgICBlcnJvcnMucHVzaChnZXRVbm9wZW5lZFRhZ0V4Y2VwdGlvbih7XG4gICAgICAgIHh0YWc6IHh0YWcsXG4gICAgICAgIG9mZnNldDogZGVsaW1pdGVyT2Zmc2V0XG4gICAgICB9KSk7XG4gICAgICBsYXN0RGVsaW1pdGVyTWF0Y2ggPSBjdXJyRGVsaW1pdGVyTWF0Y2g7XG4gICAgICBkZWxpbWl0ZXJBY2MucHVzaChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGN1cnJEZWxpbWl0ZXJNYXRjaCksIHt9LCB7XG4gICAgICAgIGVycm9yOiB0cnVlXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gZGVsaW1pdGVyQWNjO1xuICAgIH1cbiAgICBpbkRlbGltaXRlciA9IHBvc2l0aW9uID09PSBcInN0YXJ0XCI7XG4gICAgbGFzdERlbGltaXRlck1hdGNoID0gY3VyckRlbGltaXRlck1hdGNoO1xuICAgIGRlbGltaXRlckFjYy5wdXNoKGN1cnJEZWxpbWl0ZXJNYXRjaCk7XG4gICAgcmV0dXJuIGRlbGltaXRlckFjYztcbiAgfSwgW10pO1xuICBpZiAoaW5EZWxpbWl0ZXIpIHtcbiAgICB2YXIgbGFzdERlbGltaXRlck9mZnNldCA9IGxhc3REZWxpbWl0ZXJNYXRjaC5vZmZzZXQ7XG4gICAgeHRhZyA9IGZ1bGxUZXh0LnN1YnN0cihsYXN0RGVsaW1pdGVyT2Zmc2V0LCBmdWxsVGV4dC5sZW5ndGggLSBsYXN0RGVsaW1pdGVyT2Zmc2V0KTtcbiAgICBpZiAoIXN5bnRheE9wdGlvbnMuYWxsb3dVbmNsb3NlZFRhZykge1xuICAgICAgZXJyb3JzLnB1c2goZ2V0VW5jbG9zZWRUYWdFeGNlcHRpb24oe1xuICAgICAgICB4dGFnOiB3b3JkVG9VdGY4KHh0YWcpLFxuICAgICAgICBvZmZzZXQ6IGxhc3REZWxpbWl0ZXJPZmZzZXRcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsaW1pdGVyV2l0aEVycm9ycy5wb3AoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkZWxpbWl0ZXJXaXRoRXJyb3JzOiBkZWxpbWl0ZXJXaXRoRXJyb3JzLFxuICAgIGVycm9yczogZXJyb3JzXG4gIH07XG59XG5mdW5jdGlvbiBjb21wYXJlT2Zmc2V0cyhzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gIGlmIChzdGFydE9mZnNldCA9PT0gLTEgJiYgZW5kT2Zmc2V0ID09PSAtMSkge1xuICAgIHJldHVybiBERUxJTUlURVJfTk9ORTtcbiAgfVxuICBpZiAoc3RhcnRPZmZzZXQgPT09IGVuZE9mZnNldCkge1xuICAgIHJldHVybiBERUxJTUlURVJfRVFVQUw7XG4gIH1cbiAgaWYgKHN0YXJ0T2Zmc2V0ID09PSAtMSB8fCBlbmRPZmZzZXQgPT09IC0xKSB7XG4gICAgcmV0dXJuIGVuZE9mZnNldCA8IHN0YXJ0T2Zmc2V0ID8gREVMSU1JVEVSX1NUQVJUIDogREVMSU1JVEVSX0VORDtcbiAgfVxuICByZXR1cm4gc3RhcnRPZmZzZXQgPCBlbmRPZmZzZXQgPyBERUxJTUlURVJfU1RBUlQgOiBERUxJTUlURVJfRU5EO1xufVxuZnVuY3Rpb24gc3BsaXREZWxpbWl0ZXJzKGluc2lkZSkge1xuICB2YXIgbmV3RGVsaW1pdGVycyA9IGluc2lkZS5zcGxpdChcIiBcIik7XG4gIGlmIChuZXdEZWxpbWl0ZXJzLmxlbmd0aCAhPT0gMikge1xuICAgIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiTmV3IERlbGltaXRlcnMgY2Fubm90IGJlIHBhcnNlZFwiKTtcbiAgICBlcnIucHJvcGVydGllcyA9IHtcbiAgICAgIGlkOiBcImNoYW5nZV9kZWxpbWl0ZXJzX2ludmFsaWRcIixcbiAgICAgIGV4cGxhbmF0aW9uOiBcIkNhbm5vdCBwYXJzZXIgZGVsaW1pdGVyc1wiXG4gICAgfTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgdmFyIF9uZXdEZWxpbWl0ZXJzID0gX3NsaWNlZFRvQXJyYXkobmV3RGVsaW1pdGVycywgMiksXG4gICAgc3RhcnQgPSBfbmV3RGVsaW1pdGVyc1swXSxcbiAgICBlbmQgPSBfbmV3RGVsaW1pdGVyc1sxXTtcbiAgaWYgKHN0YXJ0Lmxlbmd0aCA9PT0gMCB8fCBlbmQubGVuZ3RoID09PSAwKSB7XG4gICAgdmFyIF9lcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiTmV3IERlbGltaXRlcnMgY2Fubm90IGJlIHBhcnNlZFwiKTtcbiAgICBfZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgICBpZDogXCJjaGFuZ2VfZGVsaW1pdGVyc19pbnZhbGlkXCIsXG4gICAgICBleHBsYW5hdGlvbjogXCJDYW5ub3QgcGFyc2VyIGRlbGltaXRlcnNcIlxuICAgIH07XG4gICAgdGhyb3cgX2VycjtcbiAgfVxuICByZXR1cm4gW3N0YXJ0LCBlbmRdO1xufVxuZnVuY3Rpb24gZ2V0QWxsRGVsaW1pdGVySW5kZXhlcyhmdWxsVGV4dCwgZGVsaW1pdGVycywgc3ludGF4T3B0aW9ucykge1xuICB2YXIgaW5kZXhlcyA9IFtdO1xuICB2YXIgc3RhcnQgPSBkZWxpbWl0ZXJzLnN0YXJ0LFxuICAgIGVuZCA9IGRlbGltaXRlcnMuZW5kO1xuICB2YXIgb2Zmc2V0ID0gLTE7XG4gIHZhciBpbnNpZGVUYWcgPSBmYWxzZTtcbiAgaWYgKHN0YXJ0ID09IG51bGwgJiYgZW5kID09IG51bGwpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2Ugb2YgZGVsaW1pdGVyIHNldCB0byBudWxsL251bGwsIG5vIHRlbXBsYXRpbmcgaXMgZG9uZVxuICAgIHJldHVybiBbXTtcbiAgfVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBzdGFydE9mZnNldCA9IGZ1bGxUZXh0LmluZGV4T2Yoc3RhcnQsIG9mZnNldCArIDEpO1xuICAgIHZhciBlbmRPZmZzZXQgPSBmdWxsVGV4dC5pbmRleE9mKGVuZCwgb2Zmc2V0ICsgMSk7XG4gICAgdmFyIHBvc2l0aW9uID0gbnVsbDtcbiAgICB2YXIgbGVuID0gdm9pZCAwO1xuICAgIHZhciBjb21wYXJlUmVzdWx0ID0gY29tcGFyZU9mZnNldHMoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgaWYgKGNvbXBhcmVSZXN1bHQgPT09IERFTElNSVRFUl9FUVVBTCkge1xuICAgICAgY29tcGFyZVJlc3VsdCA9IGluc2lkZVRhZyA/IERFTElNSVRFUl9FTkQgOiBERUxJTUlURVJfU1RBUlQ7XG4gICAgfVxuICAgIHN3aXRjaCAoY29tcGFyZVJlc3VsdCkge1xuICAgICAgY2FzZSBERUxJTUlURVJfTk9ORTpcbiAgICAgICAgcmV0dXJuIGluZGV4ZXM7XG4gICAgICBjYXNlIERFTElNSVRFUl9FTkQ6XG4gICAgICAgIGluc2lkZVRhZyA9IGZhbHNlO1xuICAgICAgICBvZmZzZXQgPSBlbmRPZmZzZXQ7XG4gICAgICAgIHBvc2l0aW9uID0gXCJlbmRcIjtcbiAgICAgICAgbGVuID0gZW5kLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERFTElNSVRFUl9TVEFSVDpcbiAgICAgICAgaW5zaWRlVGFnID0gdHJ1ZTtcbiAgICAgICAgb2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gICAgICAgIHBvc2l0aW9uID0gXCJzdGFydFwiO1xuICAgICAgICBsZW4gPSBzdGFydC5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvKlxuICAgICAqIElmIHRhZyBzdGFydHMgd2l0aCA9LCBzdWNoIGFzIHs9WyBdPX1cbiAgICAgKiB0aGVuIHRoZSBkZWxpbWl0ZXJzIHdpbGwgY2hhbmdlIHJpZ2h0IGFmdGVyIHRoYXQgdGFnLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIHdpdGggdGhlIGZvbGxvd2luZyB0ZW1wbGF0ZSA6XG4gICAgICpcbiAgICAgKiBIZWxsbyB7Zm9vfSwgez1bIF09fXdoYXQncyB1cCB3aXRoIFtuYW1lXSA/XG4gICAgICpcbiAgICAgKiBUaGUgXCJmb29cIiB0YWcgaXMgYSBub3JtYWwgdGFnLCB0aGUgXCI9WyBdPVwiIGlzIGEgdGFnIHRvIGNoYW5nZSB0aGVcbiAgICAgKiBkZWxpbWl0ZXJzIHRvIFwiW1wiIGFuZCBcIl1cIiwgYW5kIHRoZSBsYXN0IFwibmFtZVwiIGlzIGEgdGFnIHdpdGggdGhlIG5ld1xuICAgICAqIGRlbGltaXRlcnNcbiAgICAgKi9cbiAgICBpZiAoc3ludGF4T3B0aW9ucy5jaGFuZ2VEZWxpbWl0ZXJQcmVmaXggJiYgY29tcGFyZVJlc3VsdCA9PT0gREVMSU1JVEVSX1NUQVJUICYmIGZ1bGxUZXh0W29mZnNldCArIHN0YXJ0Lmxlbmd0aF0gPT09IHN5bnRheE9wdGlvbnMuY2hhbmdlRGVsaW1pdGVyUHJlZml4KSB7XG4gICAgICBpbmRleGVzLnB1c2goe1xuICAgICAgICBvZmZzZXQ6IHN0YXJ0T2Zmc2V0LFxuICAgICAgICBwb3NpdGlvbjogXCJzdGFydFwiLFxuICAgICAgICBsZW5ndGg6IHN0YXJ0Lmxlbmd0aCxcbiAgICAgICAgY2hhbmdlZGVsaW1pdGVyOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHZhciBuZXh0RXF1YWwgPSBmdWxsVGV4dC5pbmRleE9mKHN5bnRheE9wdGlvbnMuY2hhbmdlRGVsaW1pdGVyUHJlZml4LCBvZmZzZXQgKyBzdGFydC5sZW5ndGggKyAxKTtcbiAgICAgIHZhciBuZXh0RW5kT2Zmc2V0ID0gZnVsbFRleHQuaW5kZXhPZihlbmQsIG5leHRFcXVhbCArIDEpO1xuICAgICAgaW5kZXhlcy5wdXNoKHtcbiAgICAgICAgb2Zmc2V0OiBuZXh0RW5kT2Zmc2V0LFxuICAgICAgICBwb3NpdGlvbjogXCJlbmRcIixcbiAgICAgICAgbGVuZ3RoOiBlbmQubGVuZ3RoLFxuICAgICAgICBjaGFuZ2VkZWxpbWl0ZXI6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdmFyIF9pbnNpZGVUYWcgPSBmdWxsVGV4dC5zdWJzdHIob2Zmc2V0ICsgc3RhcnQubGVuZ3RoICsgMSwgbmV4dEVxdWFsIC0gb2Zmc2V0IC0gc3RhcnQubGVuZ3RoIC0gMSk7XG4gICAgICB2YXIgX3NwbGl0RGVsaW1pdGVycyA9IHNwbGl0RGVsaW1pdGVycyhfaW5zaWRlVGFnKTtcbiAgICAgIHZhciBfc3BsaXREZWxpbWl0ZXJzMiA9IF9zbGljZWRUb0FycmF5KF9zcGxpdERlbGltaXRlcnMsIDIpO1xuICAgICAgc3RhcnQgPSBfc3BsaXREZWxpbWl0ZXJzMlswXTtcbiAgICAgIGVuZCA9IF9zcGxpdERlbGltaXRlcnMyWzFdO1xuICAgICAgb2Zmc2V0ID0gbmV4dEVuZE9mZnNldDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpbmRleGVzLnB1c2goe1xuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICBsZW5ndGg6IGxlblxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZURlbGltaXRlcnMoaW5uZXJDb250ZW50UGFydHMsIGRlbGltaXRlcnMsIHN5bnRheE9wdGlvbnMpIHtcbiAgdmFyIGZ1bGwgPSBpbm5lckNvbnRlbnRQYXJ0cy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcC52YWx1ZTtcbiAgfSkuam9pbihcIlwiKTtcbiAgdmFyIGRlbGltaXRlck1hdGNoZXMgPSBnZXRBbGxEZWxpbWl0ZXJJbmRleGVzKGZ1bGwsIGRlbGltaXRlcnMsIHN5bnRheE9wdGlvbnMpO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIHJhbmdlcyA9IGlubmVyQ29udGVudFBhcnRzLm1hcChmdW5jdGlvbiAocGFydCkge1xuICAgIG9mZnNldCArPSBwYXJ0LnZhbHVlLmxlbmd0aDtcbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0OiBvZmZzZXQgLSBwYXJ0LnZhbHVlLmxlbmd0aCxcbiAgICAgIGxJbmRleDogcGFydC5sSW5kZXhcbiAgICB9O1xuICB9KTtcbiAgdmFyIF9nZXREZWxpbWl0ZXJFcnJvcnMgPSBnZXREZWxpbWl0ZXJFcnJvcnMoZGVsaW1pdGVyTWF0Y2hlcywgZnVsbCwgc3ludGF4T3B0aW9ucyksXG4gICAgZGVsaW1pdGVyV2l0aEVycm9ycyA9IF9nZXREZWxpbWl0ZXJFcnJvcnMuZGVsaW1pdGVyV2l0aEVycm9ycyxcbiAgICBlcnJvcnMgPSBfZ2V0RGVsaW1pdGVyRXJyb3JzLmVycm9ycztcbiAgdmFyIGN1dE5leHQgPSAwO1xuICB2YXIgZGVsaW1pdGVySW5kZXggPSAwO1xuICB2YXIgcGFyc2VkID0gcmFuZ2VzLm1hcChmdW5jdGlvbiAocCwgaSkge1xuICAgIHZhciBvZmZzZXQgPSBwLm9mZnNldDtcbiAgICB2YXIgcmFuZ2UgPSBbb2Zmc2V0LCBvZmZzZXQgKyBpbm5lckNvbnRlbnRQYXJ0c1tpXS52YWx1ZS5sZW5ndGhdO1xuICAgIHZhciBwYXJ0Q29udGVudCA9IGlubmVyQ29udGVudFBhcnRzW2ldLnZhbHVlO1xuICAgIHZhciBkZWxpbWl0ZXJzSW5PZmZzZXQgPSBbXTtcbiAgICB3aGlsZSAoZGVsaW1pdGVySW5kZXggPCBkZWxpbWl0ZXJXaXRoRXJyb3JzLmxlbmd0aCAmJiBpblJhbmdlKHJhbmdlLCBkZWxpbWl0ZXJXaXRoRXJyb3JzW2RlbGltaXRlckluZGV4XSkpIHtcbiAgICAgIGRlbGltaXRlcnNJbk9mZnNldC5wdXNoKGRlbGltaXRlcldpdGhFcnJvcnNbZGVsaW1pdGVySW5kZXhdKTtcbiAgICAgIGRlbGltaXRlckluZGV4Kys7XG4gICAgfVxuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHZhciBjdXJzb3IgPSAwO1xuICAgIGlmIChjdXROZXh0ID4gMCkge1xuICAgICAgY3Vyc29yID0gY3V0TmV4dDtcbiAgICAgIGN1dE5leHQgPSAwO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBkZWxpbWl0ZXJzSW5PZmZzZXQubGVuZ3RoOyBfaTYrKykge1xuICAgICAgdmFyIGRlbGltaXRlckluT2Zmc2V0ID0gZGVsaW1pdGVyc0luT2Zmc2V0W19pNl07XG4gICAgICB2YXIgX3ZhbHVlID0gcGFydENvbnRlbnQuc3Vic3RyKGN1cnNvciwgZGVsaW1pdGVySW5PZmZzZXQub2Zmc2V0IC0gb2Zmc2V0IC0gY3Vyc29yKTtcbiAgICAgIGlmIChkZWxpbWl0ZXJJbk9mZnNldC5jaGFuZ2VkZWxpbWl0ZXIpIHtcbiAgICAgICAgaWYgKGRlbGltaXRlckluT2Zmc2V0LnBvc2l0aW9uID09PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgICBpZiAoX3ZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcImNvbnRlbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IF92YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnNvciA9IGRlbGltaXRlckluT2Zmc2V0Lm9mZnNldCAtIG9mZnNldCArIGRlbGltaXRlckluT2Zmc2V0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChfdmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcImNvbnRlbnRcIixcbiAgICAgICAgICB2YWx1ZTogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBjdXJzb3IgKz0gX3ZhbHVlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciBkZWxpbWl0ZXJQYXJ0ID0ge1xuICAgICAgICB0eXBlOiBcImRlbGltaXRlclwiLFxuICAgICAgICBwb3NpdGlvbjogZGVsaW1pdGVySW5PZmZzZXQucG9zaXRpb24sXG4gICAgICAgIG9mZnNldDogY3Vyc29yICsgb2Zmc2V0XG4gICAgICB9O1xuICAgICAgcGFydHMucHVzaChkZWxpbWl0ZXJQYXJ0KTtcbiAgICAgIGN1cnNvciA9IGRlbGltaXRlckluT2Zmc2V0Lm9mZnNldCAtIG9mZnNldCArIGRlbGltaXRlckluT2Zmc2V0Lmxlbmd0aDtcbiAgICB9XG4gICAgY3V0TmV4dCA9IGN1cnNvciAtIHBhcnRDb250ZW50Lmxlbmd0aDtcbiAgICB2YXIgdmFsdWUgPSBwYXJ0Q29udGVudC5zdWJzdHIoY3Vyc29yKTtcbiAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiY29udGVudFwiLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHM7XG4gIH0sIHRoaXMpO1xuICByZXR1cm4ge1xuICAgIHBhcnNlZDogcGFyc2VkLFxuICAgIGVycm9yczogZXJyb3JzXG4gIH07XG59XG5mdW5jdGlvbiBpc0luc2lkZUNvbnRlbnQocGFydCkge1xuICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSB0aGUgcGFydC5wb3NpdGlvbiA9PT0gXCJpbnNpZGV0YWdcIiB3b3VsZCBiZSBlbm91Z2ggYnV0IHdlIHdhbnQgdG8gbWFrZSB0aGUgQVBJIGZ1dHVyZSBwcm9vZlxuICByZXR1cm4gcGFydC50eXBlID09PSBcImNvbnRlbnRcIiAmJiBwYXJ0LnBvc2l0aW9uID09PSBcImluc2lkZXRhZ1wiO1xuICAvLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG59XG5mdW5jdGlvbiBnZXRDb250ZW50UGFydHMoeG1scGFyc2VkKSB7XG4gIHJldHVybiB4bWxwYXJzZWQuZmlsdGVyKGlzSW5zaWRlQ29udGVudCk7XG59XG5mdW5jdGlvbiBkZWNvZGVDb250ZW50UGFydHMoeG1scGFyc2VkLCBmaWxlVHlwZSkge1xuICB2YXIgaW5UZXh0VGFnID0gZmFsc2U7XG4gIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IHhtbHBhcnNlZC5sZW5ndGg7IF9pOCsrKSB7XG4gICAgdmFyIHBhcnQgPSB4bWxwYXJzZWRbX2k4XTtcbiAgICBpblRleHRUYWcgPSB1cGRhdGVJblRleHRUYWcocGFydCwgaW5UZXh0VGFnKTtcbiAgICBpZiAocGFydC50eXBlID09PSBcImNvbnRlbnRcIikge1xuICAgICAgcGFydC5wb3NpdGlvbiA9IGluVGV4dFRhZyA/IFwiaW5zaWRldGFnXCIgOiBcIm91dHNpZGV0YWdcIjtcbiAgICB9XG4gICAgaWYgKGZpbGVUeXBlICE9PSBcInRleHRcIiAmJiBpc0luc2lkZUNvbnRlbnQocGFydCkpIHtcbiAgICAgIHBhcnQudmFsdWUgPSBwYXJ0LnZhbHVlLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpO1xuICAgIH1cbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlRGVsaW1pdGVyczogcGFyc2VEZWxpbWl0ZXJzLFxuICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoeG1sbGV4ZWQsIGRlbGltaXRlcnMsIHN5bnRheCwgZmlsZVR5cGUpIHtcbiAgICBkZWNvZGVDb250ZW50UGFydHMoeG1sbGV4ZWQsIGZpbGVUeXBlKTtcbiAgICB2YXIgX3BhcnNlRGVsaW1pdGVycyA9IHBhcnNlRGVsaW1pdGVycyhnZXRDb250ZW50UGFydHMoeG1sbGV4ZWQpLCBkZWxpbWl0ZXJzLCBzeW50YXgpLFxuICAgICAgZGVsaW1pdGVyUGFyc2VkID0gX3BhcnNlRGVsaW1pdGVycy5wYXJzZWQsXG4gICAgICBlcnJvcnMgPSBfcGFyc2VEZWxpbWl0ZXJzLmVycm9ycztcbiAgICB2YXIgbGV4ZWQgPSBbXTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsSW5kZXggPSAwO1xuICAgIGZvciAodmFyIF9pMTAgPSAwOyBfaTEwIDwgeG1sbGV4ZWQubGVuZ3RoOyBfaTEwKyspIHtcbiAgICAgIHZhciBwYXJ0ID0geG1sbGV4ZWRbX2kxMF07XG4gICAgICBpZiAoaXNJbnNpZGVDb250ZW50KHBhcnQpKSB7XG4gICAgICAgIGZvciAodmFyIF9pMTIgPSAwLCBfZGVsaW1pdGVyUGFyc2VkJGluZGUyID0gZGVsaW1pdGVyUGFyc2VkW2luZGV4XTsgX2kxMiA8IF9kZWxpbWl0ZXJQYXJzZWQkaW5kZTIubGVuZ3RoOyBfaTEyKyspIHtcbiAgICAgICAgICB2YXIgcCA9IF9kZWxpbWl0ZXJQYXJzZWQkaW5kZTJbX2kxMl07XG4gICAgICAgICAgaWYgKHAudHlwZSA9PT0gXCJjb250ZW50XCIpIHtcbiAgICAgICAgICAgIHAucG9zaXRpb24gPSBcImluc2lkZXRhZ1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwLmxJbmRleCA9IGxJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHB1c2hBcnJheShsZXhlZCwgZGVsaW1pdGVyUGFyc2VkW2luZGV4XSk7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0LmxJbmRleCA9IGxJbmRleCsrO1xuICAgICAgICBsZXhlZC5wdXNoKHBhcnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICBsZXhlZDogbGV4ZWRcbiAgICB9O1xuICB9LFxuICB4bWxwYXJzZTogZnVuY3Rpb24geG1scGFyc2UoY29udGVudCwgeG1sdGFncykge1xuICAgIHZhciBtYXRjaGVzID0gdGFnTWF0Y2hlcihjb250ZW50LCB4bWx0YWdzLnRleHQsIHhtbHRhZ3Mub3RoZXIpO1xuICAgIHZhciBjdXJzb3IgPSAwO1xuICAgIHZhciBwYXJzZWQgPSBtYXRjaGVzLnJlZHVjZShmdW5jdGlvbiAocGFyc2VkLCBtYXRjaCkge1xuICAgICAgaWYgKGNvbnRlbnQubGVuZ3RoID4gY3Vyc29yICYmIG1hdGNoLm9mZnNldCAtIGN1cnNvciA+IDApIHtcbiAgICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwiY29udGVudFwiLFxuICAgICAgICAgIHZhbHVlOiBjb250ZW50LnN1YnN0cihjdXJzb3IsIG1hdGNoLm9mZnNldCAtIGN1cnNvcilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjdXJzb3IgPSBtYXRjaC5vZmZzZXQgKyBtYXRjaC52YWx1ZS5sZW5ndGg7XG4gICAgICBkZWxldGUgbWF0Y2gub2Zmc2V0O1xuICAgICAgcGFyc2VkLnB1c2gobWF0Y2gpO1xuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9LCBbXSk7XG4gICAgaWYgKGNvbnRlbnQubGVuZ3RoID4gY3Vyc29yKSB7XG4gICAgICBwYXJzZWQucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiY29udGVudFwiLFxuICAgICAgICB2YWx1ZTogY29udGVudC5zdWJzdHIoY3Vyc29yKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbn07Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9zbGljZWRUb0FycmF5IiwiciIsImUiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiVHlwZUVycm9yIiwiYSIsIl9hcnJheUxpa2VUb0FycmF5IiwidCIsInRvU3RyaW5nIiwiY2FsbCIsInNsaWNlIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJsZW5ndGgiLCJuIiwibCIsImkiLCJ1IiwiZiIsIm5leHQiLCJPYmplY3QiLCJkb25lIiwicHVzaCIsInZhbHVlIiwiaXNBcnJheSIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5IiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiX3JlcXVpcmUiLCJyZXF1aXJlIiwiZ2V0VW5jbG9zZWRUYWdFeGNlcHRpb24iLCJnZXRVbm9wZW5lZFRhZ0V4Y2VwdGlvbiIsImdldER1cGxpY2F0ZU9wZW5UYWdFeGNlcHRpb24iLCJnZXREdXBsaWNhdGVDbG9zZVRhZ0V4Y2VwdGlvbiIsInRocm93TWFsZm9ybWVkWG1sIiwidGhyb3dYbWxJbnZhbGlkIiwiWFRUZW1wbGF0ZUVycm9yIiwiX3JlcXVpcmUyIiwiaXNUZXh0U3RhcnQiLCJpc1RleHRFbmQiLCJ3b3JkVG9VdGY4IiwicHVzaEFycmF5IiwiREVMSU1JVEVSX05PTkUiLCJERUxJTUlURVJfRVFVQUwiLCJERUxJTUlURVJfU1RBUlQiLCJERUxJTUlURVJfRU5EIiwiaW5SYW5nZSIsInJhbmdlIiwibWF0Y2giLCJvZmZzZXQiLCJ1cGRhdGVJblRleHRUYWciLCJwYXJ0IiwiaW5UZXh0VGFnIiwiZ2V0VGFnIiwidGFnIiwicG9zaXRpb24iLCJzdGFydCIsImVuZCIsImluZGV4T2YiLCJ0YWdNYXRjaGVyIiwiY29udGVudCIsInRleHRNYXRjaEFycmF5Iiwib3RoZXJzTWF0Y2hBcnJheSIsImN1cnNvciIsImNvbnRlbnRMZW5ndGgiLCJhbGxNYXRjaGVzIiwiX2kyIiwibSIsIl9pNCIsIl9tIiwidG90YWxNYXRjaGVzIiwibmV4dE9wZW5pbmciLCJ0YWdUZXh0IiwiX2dldFRhZyIsInRleHQiLCJ0eXBlIiwiZ2V0RGVsaW1pdGVyRXJyb3JzIiwiZGVsaW1pdGVyTWF0Y2hlcyIsImZ1bGxUZXh0Iiwic3ludGF4T3B0aW9ucyIsImVycm9ycyIsImluRGVsaW1pdGVyIiwibGFzdERlbGltaXRlck1hdGNoIiwieHRhZyIsImRlbGltaXRlcldpdGhFcnJvcnMiLCJyZWR1Y2UiLCJkZWxpbWl0ZXJBY2MiLCJjdXJyRGVsaW1pdGVyTWF0Y2giLCJkZWxpbWl0ZXJPZmZzZXQiLCJsYXN0RGVsaW1pdGVyT2Zmc2V0IiwibGFzdERlbGltaXRlckxlbmd0aCIsInN1YnN0ciIsImFsbG93VW5jbG9zZWRUYWciLCJlcnJvciIsInBvcCIsImFsbG93VW5vcGVuZWRUYWciLCJjb21wYXJlT2Zmc2V0cyIsInN0YXJ0T2Zmc2V0IiwiZW5kT2Zmc2V0Iiwic3BsaXREZWxpbWl0ZXJzIiwiaW5zaWRlIiwibmV3RGVsaW1pdGVycyIsInNwbGl0IiwiZXJyIiwicHJvcGVydGllcyIsImlkIiwiZXhwbGFuYXRpb24iLCJfbmV3RGVsaW1pdGVycyIsIl9lcnIiLCJnZXRBbGxEZWxpbWl0ZXJJbmRleGVzIiwiZGVsaW1pdGVycyIsImluZGV4ZXMiLCJpbnNpZGVUYWciLCJsZW4iLCJjb21wYXJlUmVzdWx0IiwiY2hhbmdlRGVsaW1pdGVyUHJlZml4IiwiY2hhbmdlZGVsaW1pdGVyIiwibmV4dEVxdWFsIiwibmV4dEVuZE9mZnNldCIsIl9pbnNpZGVUYWciLCJfc3BsaXREZWxpbWl0ZXJzIiwiX3NwbGl0RGVsaW1pdGVyczIiLCJwYXJzZURlbGltaXRlcnMiLCJpbm5lckNvbnRlbnRQYXJ0cyIsImZ1bGwiLCJtYXAiLCJwIiwiam9pbiIsInJhbmdlcyIsImxJbmRleCIsIl9nZXREZWxpbWl0ZXJFcnJvcnMiLCJjdXROZXh0IiwiZGVsaW1pdGVySW5kZXgiLCJwYXJzZWQiLCJwYXJ0Q29udGVudCIsImRlbGltaXRlcnNJbk9mZnNldCIsInBhcnRzIiwiX2k2IiwiZGVsaW1pdGVySW5PZmZzZXQiLCJfdmFsdWUiLCJkZWxpbWl0ZXJQYXJ0IiwiaXNJbnNpZGVDb250ZW50IiwiZ2V0Q29udGVudFBhcnRzIiwieG1scGFyc2VkIiwiZGVjb2RlQ29udGVudFBhcnRzIiwiZmlsZVR5cGUiLCJfaTgiLCJyZXBsYWNlIiwibW9kdWxlIiwiZXhwb3J0cyIsInBhcnNlIiwieG1sbGV4ZWQiLCJzeW50YXgiLCJfcGFyc2VEZWxpbWl0ZXJzIiwiZGVsaW1pdGVyUGFyc2VkIiwibGV4ZWQiLCJpbmRleCIsIl9pMTAiLCJfaTEyIiwiX2RlbGltaXRlclBhcnNlZCRpbmRlMiIsInhtbHBhcnNlIiwieG1sdGFncyIsIm1hdGNoZXMiLCJvdGhlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/lexer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/merge-sort.js":
/*!*****************************************************!*\
  !*** ./node_modules/docxtemplater/js/merge-sort.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\nfunction getMinFromArrays(arrays, state) {\n    var minIndex = -1;\n    for(var i = 0, l = arrays.length; i < l; i++){\n        if (state[i] >= arrays[i].length) {\n            continue;\n        }\n        if (minIndex === -1 || arrays[i][state[i]].offset < arrays[minIndex][state[minIndex]].offset) {\n            minIndex = i;\n        }\n    }\n    return minIndex;\n}\nmodule.exports = function(arrays) {\n    var totalLength = arrays.reduce(function(sum, array) {\n        return sum + array.length;\n    }, 0);\n    arrays = arrays.filter(function(array) {\n        return array.length > 0;\n    });\n    var resultArray = new Array(totalLength);\n    var state = arrays.map(function() {\n        return 0;\n    });\n    for(var i = 0; i < totalLength; i++){\n        var arrayIndex = getMinFromArrays(arrays, state);\n        resultArray[i] = arrays[arrayIndex][state[arrayIndex]];\n        state[arrayIndex]++;\n    }\n    return resultArray;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tZXJnZS1zb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsaUJBQWlCQyxNQUFNLEVBQUVDLEtBQUs7SUFDckMsSUFBSUMsV0FBVyxDQUFDO0lBQ2hCLElBQUssSUFBSUMsSUFBSSxHQUFHQyxJQUFJSixPQUFPSyxNQUFNLEVBQUVGLElBQUlDLEdBQUdELElBQUs7UUFDN0MsSUFBSUYsS0FBSyxDQUFDRSxFQUFFLElBQUlILE1BQU0sQ0FBQ0csRUFBRSxDQUFDRSxNQUFNLEVBQUU7WUFDaEM7UUFDRjtRQUNBLElBQUlILGFBQWEsQ0FBQyxLQUFLRixNQUFNLENBQUNHLEVBQUUsQ0FBQ0YsS0FBSyxDQUFDRSxFQUFFLENBQUMsQ0FBQ0csTUFBTSxHQUFHTixNQUFNLENBQUNFLFNBQVMsQ0FBQ0QsS0FBSyxDQUFDQyxTQUFTLENBQUMsQ0FBQ0ksTUFBTSxFQUFFO1lBQzVGSixXQUFXQztRQUNiO0lBQ0Y7SUFDQSxPQUFPRDtBQUNUO0FBQ0FLLE9BQU9DLE9BQU8sR0FBRyxTQUFVUixNQUFNO0lBQy9CLElBQUlTLGNBQWNULE9BQU9VLE1BQU0sQ0FBQyxTQUFVQyxHQUFHLEVBQUVDLEtBQUs7UUFDbEQsT0FBT0QsTUFBTUMsTUFBTVAsTUFBTTtJQUMzQixHQUFHO0lBQ0hMLFNBQVNBLE9BQU9hLE1BQU0sQ0FBQyxTQUFVRCxLQUFLO1FBQ3BDLE9BQU9BLE1BQU1QLE1BQU0sR0FBRztJQUN4QjtJQUNBLElBQUlTLGNBQWMsSUFBSUMsTUFBTU47SUFDNUIsSUFBSVIsUUFBUUQsT0FBT2dCLEdBQUcsQ0FBQztRQUNyQixPQUFPO0lBQ1Q7SUFDQSxJQUFLLElBQUliLElBQUksR0FBR0EsSUFBSU0sYUFBYU4sSUFBSztRQUNwQyxJQUFJYyxhQUFhbEIsaUJBQWlCQyxRQUFRQztRQUMxQ2EsV0FBVyxDQUFDWCxFQUFFLEdBQUdILE1BQU0sQ0FBQ2lCLFdBQVcsQ0FBQ2hCLEtBQUssQ0FBQ2dCLFdBQVcsQ0FBQztRQUN0RGhCLEtBQUssQ0FBQ2dCLFdBQVc7SUFDbkI7SUFDQSxPQUFPSDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlrZS1yZW50YWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL21lcmdlLXNvcnQuanM/NzE2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gZ2V0TWluRnJvbUFycmF5cyhhcnJheXMsIHN0YXRlKSB7XG4gIHZhciBtaW5JbmRleCA9IC0xO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFycmF5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoc3RhdGVbaV0gPj0gYXJyYXlzW2ldLmxlbmd0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChtaW5JbmRleCA9PT0gLTEgfHwgYXJyYXlzW2ldW3N0YXRlW2ldXS5vZmZzZXQgPCBhcnJheXNbbWluSW5kZXhdW3N0YXRlW21pbkluZGV4XV0ub2Zmc2V0KSB7XG4gICAgICBtaW5JbmRleCA9IGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW5JbmRleDtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFycmF5cykge1xuICB2YXIgdG90YWxMZW5ndGggPSBhcnJheXMucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGFycmF5KSB7XG4gICAgcmV0dXJuIHN1bSArIGFycmF5Lmxlbmd0aDtcbiAgfSwgMCk7XG4gIGFycmF5cyA9IGFycmF5cy5maWx0ZXIoZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgcmV0dXJuIGFycmF5Lmxlbmd0aCA+IDA7XG4gIH0pO1xuICB2YXIgcmVzdWx0QXJyYXkgPSBuZXcgQXJyYXkodG90YWxMZW5ndGgpO1xuICB2YXIgc3RhdGUgPSBhcnJheXMubWFwKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMDtcbiAgfSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxMZW5ndGg7IGkrKykge1xuICAgIHZhciBhcnJheUluZGV4ID0gZ2V0TWluRnJvbUFycmF5cyhhcnJheXMsIHN0YXRlKTtcbiAgICByZXN1bHRBcnJheVtpXSA9IGFycmF5c1thcnJheUluZGV4XVtzdGF0ZVthcnJheUluZGV4XV07XG4gICAgc3RhdGVbYXJyYXlJbmRleF0rKztcbiAgfVxuICByZXR1cm4gcmVzdWx0QXJyYXk7XG59OyJdLCJuYW1lcyI6WyJnZXRNaW5Gcm9tQXJyYXlzIiwiYXJyYXlzIiwic3RhdGUiLCJtaW5JbmRleCIsImkiLCJsIiwibGVuZ3RoIiwib2Zmc2V0IiwibW9kdWxlIiwiZXhwb3J0cyIsInRvdGFsTGVuZ3RoIiwicmVkdWNlIiwic3VtIiwiYXJyYXkiLCJmaWx0ZXIiLCJyZXN1bHRBcnJheSIsIkFycmF5IiwibWFwIiwiYXJyYXlJbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/merge-sort.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/module-wrapper.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/module-wrapper.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar _require = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\"), XTInternalError = _require.XTInternalError;\nfunction emptyFun() {}\nfunction identity(i) {\n    return i;\n}\nmodule.exports = function(module1) {\n    var defaults = {\n        set: emptyFun,\n        matchers: function matchers() {\n            return [];\n        },\n        parse: emptyFun,\n        render: emptyFun,\n        getTraits: emptyFun,\n        getFileType: emptyFun,\n        nullGetter: emptyFun,\n        optionsTransformer: identity,\n        postrender: identity,\n        errorsTransformer: identity,\n        getRenderedMap: identity,\n        preparse: identity,\n        postparse: identity,\n        on: emptyFun,\n        resolve: emptyFun,\n        preResolve: emptyFun\n    };\n    if (Object.keys(defaults).every(function(key) {\n        return !module1[key];\n    })) {\n        var err = new XTInternalError(\"This module cannot be wrapped, because it doesn't define any of the necessary functions\");\n        err.properties = {\n            id: \"module_cannot_be_wrapped\",\n            explanation: \"This module cannot be wrapped, because it doesn't define any of the necessary functions\"\n        };\n        throw err;\n    }\n    for(var key in defaults){\n        module1[key] || (module1[key] = defaults[key]);\n    }\n    return module1;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGUtd3JhcHBlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLFdBQVdDLG1CQUFPQSxDQUFDLG9FQUFhLEdBQ2xDQyxrQkFBa0JGLFNBQVNFLGVBQWU7QUFDNUMsU0FBU0MsWUFBWTtBQUNyQixTQUFTQyxTQUFTQyxDQUFDO0lBQ2pCLE9BQU9BO0FBQ1Q7QUFDQUMsT0FBT0MsT0FBTyxHQUFHLFNBQVVELE9BQU07SUFDL0IsSUFBSUUsV0FBVztRQUNiQyxLQUFLTjtRQUNMTyxVQUFVLFNBQVNBO1lBQ2pCLE9BQU8sRUFBRTtRQUNYO1FBQ0FDLE9BQU9SO1FBQ1BTLFFBQVFUO1FBQ1JVLFdBQVdWO1FBQ1hXLGFBQWFYO1FBQ2JZLFlBQVlaO1FBQ1phLG9CQUFvQlo7UUFDcEJhLFlBQVliO1FBQ1pjLG1CQUFtQmQ7UUFDbkJlLGdCQUFnQmY7UUFDaEJnQixVQUFVaEI7UUFDVmlCLFdBQVdqQjtRQUNYa0IsSUFBSW5CO1FBQ0pvQixTQUFTcEI7UUFDVHFCLFlBQVlyQjtJQUNkO0lBQ0EsSUFBSXNCLE9BQU9DLElBQUksQ0FBQ2xCLFVBQVVtQixLQUFLLENBQUMsU0FBVUMsR0FBRztRQUMzQyxPQUFPLENBQUN0QixPQUFNLENBQUNzQixJQUFJO0lBQ3JCLElBQUk7UUFDRixJQUFJQyxNQUFNLElBQUkzQixnQkFBZ0I7UUFDOUIyQixJQUFJQyxVQUFVLEdBQUc7WUFDZkMsSUFBSTtZQUNKQyxhQUFhO1FBQ2Y7UUFDQSxNQUFNSDtJQUNSO0lBQ0EsSUFBSyxJQUFJRCxPQUFPcEIsU0FBVTtRQUN4QkYsT0FBTSxDQUFDc0IsSUFBSSxJQUFLdEIsQ0FBQUEsT0FBTSxDQUFDc0IsSUFBSSxHQUFHcEIsUUFBUSxDQUFDb0IsSUFBSTtJQUM3QztJQUNBLE9BQU90QjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlrZS1yZW50YWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL21vZHVsZS13cmFwcGVyLmpzPzAzOTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKSxcbiAgWFRJbnRlcm5hbEVycm9yID0gX3JlcXVpcmUuWFRJbnRlcm5hbEVycm9yO1xuZnVuY3Rpb24gZW1wdHlGdW4oKSB7fVxuZnVuY3Rpb24gaWRlbnRpdHkoaSkge1xuICByZXR1cm4gaTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1vZHVsZSkge1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgc2V0OiBlbXB0eUZ1bixcbiAgICBtYXRjaGVyczogZnVuY3Rpb24gbWF0Y2hlcnMoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICBwYXJzZTogZW1wdHlGdW4sXG4gICAgcmVuZGVyOiBlbXB0eUZ1bixcbiAgICBnZXRUcmFpdHM6IGVtcHR5RnVuLFxuICAgIGdldEZpbGVUeXBlOiBlbXB0eUZ1bixcbiAgICBudWxsR2V0dGVyOiBlbXB0eUZ1bixcbiAgICBvcHRpb25zVHJhbnNmb3JtZXI6IGlkZW50aXR5LFxuICAgIHBvc3RyZW5kZXI6IGlkZW50aXR5LFxuICAgIGVycm9yc1RyYW5zZm9ybWVyOiBpZGVudGl0eSxcbiAgICBnZXRSZW5kZXJlZE1hcDogaWRlbnRpdHksXG4gICAgcHJlcGFyc2U6IGlkZW50aXR5LFxuICAgIHBvc3RwYXJzZTogaWRlbnRpdHksXG4gICAgb246IGVtcHR5RnVuLFxuICAgIHJlc29sdmU6IGVtcHR5RnVuLFxuICAgIHByZVJlc29sdmU6IGVtcHR5RnVuXG4gIH07XG4gIGlmIChPYmplY3Qua2V5cyhkZWZhdWx0cykuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhbW9kdWxlW2tleV07XG4gIH0pKSB7XG4gICAgdmFyIGVyciA9IG5ldyBYVEludGVybmFsRXJyb3IoXCJUaGlzIG1vZHVsZSBjYW5ub3QgYmUgd3JhcHBlZCwgYmVjYXVzZSBpdCBkb2Vzbid0IGRlZmluZSBhbnkgb2YgdGhlIG5lY2Vzc2FyeSBmdW5jdGlvbnNcIik7XG4gICAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgICBpZDogXCJtb2R1bGVfY2Fubm90X2JlX3dyYXBwZWRcIixcbiAgICAgIGV4cGxhbmF0aW9uOiBcIlRoaXMgbW9kdWxlIGNhbm5vdCBiZSB3cmFwcGVkLCBiZWNhdXNlIGl0IGRvZXNuJ3QgZGVmaW5lIGFueSBvZiB0aGUgbmVjZXNzYXJ5IGZ1bmN0aW9uc1wiXG4gICAgfTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgbW9kdWxlW2tleV0gfHwgKG1vZHVsZVtrZXldID0gZGVmYXVsdHNba2V5XSk7XG4gIH1cbiAgcmV0dXJuIG1vZHVsZTtcbn07Il0sIm5hbWVzIjpbIl9yZXF1aXJlIiwicmVxdWlyZSIsIlhUSW50ZXJuYWxFcnJvciIsImVtcHR5RnVuIiwiaWRlbnRpdHkiLCJpIiwibW9kdWxlIiwiZXhwb3J0cyIsImRlZmF1bHRzIiwic2V0IiwibWF0Y2hlcnMiLCJwYXJzZSIsInJlbmRlciIsImdldFRyYWl0cyIsImdldEZpbGVUeXBlIiwibnVsbEdldHRlciIsIm9wdGlvbnNUcmFuc2Zvcm1lciIsInBvc3RyZW5kZXIiLCJlcnJvcnNUcmFuc2Zvcm1lciIsImdldFJlbmRlcmVkTWFwIiwicHJlcGFyc2UiLCJwb3N0cGFyc2UiLCJvbiIsInJlc29sdmUiLCJwcmVSZXNvbHZlIiwiT2JqZWN0Iiwia2V5cyIsImV2ZXJ5Iiwia2V5IiwiZXJyIiwicHJvcGVydGllcyIsImlkIiwiZXhwbGFuYXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/module-wrapper.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/modules/common.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/common.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n    for(var t = 0; t < r.length; t++){\n        var o = r[t];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n}\nfunction _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n        writable: !1\n    }), e;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"), pushArray = _require.pushArray;\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(rsc)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar filetypes = __webpack_require__(/*! ../filetypes.js */ \"(rsc)/./node_modules/docxtemplater/js/filetypes.js\");\nvar _require2 = __webpack_require__(/*! ../content-types.js */ \"(rsc)/./node_modules/docxtemplater/js/content-types.js\"), settingsContentType = _require2.settingsContentType, coreContentType = _require2.coreContentType, appContentType = _require2.appContentType, customContentType = _require2.customContentType, diagramDataContentType = _require2.diagramDataContentType, diagramDrawingContentType = _require2.diagramDrawingContentType;\nvar commonContentTypes = [\n    settingsContentType,\n    coreContentType,\n    appContentType,\n    customContentType,\n    diagramDataContentType,\n    diagramDrawingContentType\n];\nvar Common = /*#__PURE__*/ function() {\n    function Common() {\n        _classCallCheck(this, Common);\n        this.name = \"Common\";\n    }\n    return _createClass(Common, [\n        {\n            key: \"getFileType\",\n            value: function getFileType(_ref) {\n                var doc = _ref.doc;\n                var invertedContentTypes = doc.invertedContentTypes;\n                if (!invertedContentTypes) {\n                    return;\n                }\n                for(var _i2 = 0; _i2 < commonContentTypes.length; _i2++){\n                    var ct = commonContentTypes[_i2];\n                    if (invertedContentTypes[ct]) {\n                        pushArray(doc.targets, invertedContentTypes[ct]);\n                    }\n                }\n                var keys = [\n                    \"docx\",\n                    \"pptx\",\n                    \"xlsx\"\n                ];\n                var ftCandidate;\n                for(var _i4 = 0; _i4 < keys.length; _i4++){\n                    var key = keys[_i4];\n                    var contentTypes = filetypes[key];\n                    for(var _i6 = 0; _i6 < contentTypes.length; _i6++){\n                        var _ct = contentTypes[_i6];\n                        if (invertedContentTypes[_ct]) {\n                            for(var _i8 = 0, _invertedContentTypes2 = invertedContentTypes[_ct]; _i8 < _invertedContentTypes2.length; _i8++){\n                                var target = _invertedContentTypes2[_i8];\n                                if (doc.relsTypes[target] && [\n                                    \"http://purl.oclc.org/ooxml/officeDocument/relationships/officeDocument\",\n                                    \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\"\n                                ].indexOf(doc.relsTypes[target]) === -1) {\n                                    continue;\n                                }\n                                ftCandidate = key;\n                                if (filetypes.main.indexOf(_ct) !== -1 || _ct === filetypes.pptx[0]) {\n                                    doc.textTarget || (doc.textTarget = target);\n                                }\n                                if (ftCandidate === \"xlsx\") {\n                                    continue;\n                                }\n                                doc.targets.push(target);\n                            }\n                        }\n                    }\n                    if (ftCandidate) {\n                        return ftCandidate;\n                    }\n                }\n                return ftCandidate;\n            }\n        }\n    ]);\n}();\nmodule.exports = function() {\n    return wrapper(new Common());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSyxnQkFBZ0JDLENBQUMsRUFBRUMsQ0FBQztJQUFJLElBQUksQ0FBRUQsQ0FBQUEsYUFBYUMsQ0FBQUEsR0FBSSxNQUFNLElBQUlDLFVBQVU7QUFBc0M7QUFDbEgsU0FBU0Msa0JBQWtCQyxDQUFDLEVBQUVDLENBQUM7SUFBSSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUQsRUFBRUUsTUFBTSxFQUFFRCxJQUFLO1FBQUUsSUFBSVosSUFBSVcsQ0FBQyxDQUFDQyxFQUFFO1FBQUVaLEVBQUVjLFVBQVUsR0FBR2QsRUFBRWMsVUFBVSxJQUFJLENBQUMsR0FBR2QsRUFBRWUsWUFBWSxHQUFHLENBQUMsR0FBRyxXQUFXZixLQUFNQSxDQUFBQSxFQUFFZ0IsUUFBUSxHQUFHLENBQUMsSUFBSUMsT0FBT0MsY0FBYyxDQUFDUixHQUFHUyxlQUFlbkIsRUFBRW9CLEdBQUcsR0FBR3BCO0lBQUk7QUFBRTtBQUN2TyxTQUFTcUIsYUFBYVgsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUM7SUFBSSxPQUFPRCxLQUFLRixrQkFBa0JDLEVBQUVOLFNBQVMsRUFBRU8sSUFBSUMsS0FBS0gsa0JBQWtCQyxHQUFHRSxJQUFJSyxPQUFPQyxjQUFjLENBQUNSLEdBQUcsYUFBYTtRQUFFTSxVQUFV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QUNFLE9BQU8sQ0FBQ2YsSUFBSWMsU0FBUyxDQUFDRCxPQUFPLE1BQU0sQ0FBQyxHQUFHO29DQUNuTztnQ0FDRjtnQ0FDQVAsY0FBY2hDO2dDQUNkLElBQUlZLFVBQVU4QixJQUFJLENBQUNELE9BQU8sQ0FBQ0wsU0FBUyxDQUFDLEtBQUtBLFFBQVF4QixVQUFVK0IsSUFBSSxDQUFDLEVBQUUsRUFBRTtvQ0FDbkVqQixJQUFJa0IsVUFBVSxJQUFLbEIsQ0FBQUEsSUFBSWtCLFVBQVUsR0FBR0wsTUFBSztnQ0FDM0M7Z0NBQ0EsSUFBSVAsZ0JBQWdCLFFBQVE7b0NBQzFCO2dDQUNGO2dDQUNBTixJQUFJSSxPQUFPLENBQUNlLElBQUksQ0FBQ047NEJBQ25CO3dCQUNGO29CQUNGO29CQUNBLElBQUlQLGFBQWE7d0JBQ2YsT0FBT0E7b0JBQ1Q7Z0JBQ0Y7Z0JBQ0EsT0FBT0E7WUFDVDtRQUNGO0tBQUU7QUFDSjtBQUNBYyxPQUFPQyxPQUFPLEdBQUc7SUFDZixPQUFPcEMsUUFBUSxJQUFJVTtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Jpa2UtcmVudGFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL2NvbW1vbi5qcz8wM2IyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vZG9jLXV0aWxzLmpzXCIpLFxuICBwdXNoQXJyYXkgPSBfcmVxdWlyZS5wdXNoQXJyYXk7XG52YXIgd3JhcHBlciA9IHJlcXVpcmUoXCIuLi9tb2R1bGUtd3JhcHBlci5qc1wiKTtcbnZhciBmaWxldHlwZXMgPSByZXF1aXJlKFwiLi4vZmlsZXR5cGVzLmpzXCIpO1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuLi9jb250ZW50LXR5cGVzLmpzXCIpLFxuICBzZXR0aW5nc0NvbnRlbnRUeXBlID0gX3JlcXVpcmUyLnNldHRpbmdzQ29udGVudFR5cGUsXG4gIGNvcmVDb250ZW50VHlwZSA9IF9yZXF1aXJlMi5jb3JlQ29udGVudFR5cGUsXG4gIGFwcENvbnRlbnRUeXBlID0gX3JlcXVpcmUyLmFwcENvbnRlbnRUeXBlLFxuICBjdXN0b21Db250ZW50VHlwZSA9IF9yZXF1aXJlMi5jdXN0b21Db250ZW50VHlwZSxcbiAgZGlhZ3JhbURhdGFDb250ZW50VHlwZSA9IF9yZXF1aXJlMi5kaWFncmFtRGF0YUNvbnRlbnRUeXBlLFxuICBkaWFncmFtRHJhd2luZ0NvbnRlbnRUeXBlID0gX3JlcXVpcmUyLmRpYWdyYW1EcmF3aW5nQ29udGVudFR5cGU7XG52YXIgY29tbW9uQ29udGVudFR5cGVzID0gW3NldHRpbmdzQ29udGVudFR5cGUsIGNvcmVDb250ZW50VHlwZSwgYXBwQ29udGVudFR5cGUsIGN1c3RvbUNvbnRlbnRUeXBlLCBkaWFncmFtRGF0YUNvbnRlbnRUeXBlLCBkaWFncmFtRHJhd2luZ0NvbnRlbnRUeXBlXTtcbnZhciBDb21tb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb21tb24oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbW1vbik7XG4gICAgdGhpcy5uYW1lID0gXCJDb21tb25cIjtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENvbW1vbiwgW3tcbiAgICBrZXk6IFwiZ2V0RmlsZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmlsZVR5cGUoX3JlZikge1xuICAgICAgdmFyIGRvYyA9IF9yZWYuZG9jO1xuICAgICAgdmFyIGludmVydGVkQ29udGVudFR5cGVzID0gZG9jLmludmVydGVkQ29udGVudFR5cGVzO1xuICAgICAgaWYgKCFpbnZlcnRlZENvbnRlbnRUeXBlcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBjb21tb25Db250ZW50VHlwZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgY3QgPSBjb21tb25Db250ZW50VHlwZXNbX2kyXTtcbiAgICAgICAgaWYgKGludmVydGVkQ29udGVudFR5cGVzW2N0XSkge1xuICAgICAgICAgIHB1c2hBcnJheShkb2MudGFyZ2V0cywgaW52ZXJ0ZWRDb250ZW50VHlwZXNbY3RdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGtleXMgPSBbXCJkb2N4XCIsIFwicHB0eFwiLCBcInhsc3hcIl07XG4gICAgICB2YXIgZnRDYW5kaWRhdGU7XG4gICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBrZXlzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbX2k0XTtcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlcyA9IGZpbGV0eXBlc1trZXldO1xuICAgICAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBjb250ZW50VHlwZXMubGVuZ3RoOyBfaTYrKykge1xuICAgICAgICAgIHZhciBfY3QgPSBjb250ZW50VHlwZXNbX2k2XTtcbiAgICAgICAgICBpZiAoaW52ZXJ0ZWRDb250ZW50VHlwZXNbX2N0XSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2k4ID0gMCwgX2ludmVydGVkQ29udGVudFR5cGVzMiA9IGludmVydGVkQ29udGVudFR5cGVzW19jdF07IF9pOCA8IF9pbnZlcnRlZENvbnRlbnRUeXBlczIubGVuZ3RoOyBfaTgrKykge1xuICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gX2ludmVydGVkQ29udGVudFR5cGVzMltfaThdO1xuICAgICAgICAgICAgICBpZiAoZG9jLnJlbHNUeXBlc1t0YXJnZXRdICYmIFtcImh0dHA6Ly9wdXJsLm9jbGMub3JnL29veG1sL29mZmljZURvY3VtZW50L3JlbGF0aW9uc2hpcHMvb2ZmaWNlRG9jdW1lbnRcIiwgXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL29mZmljZURvY3VtZW50XCJdLmluZGV4T2YoZG9jLnJlbHNUeXBlc1t0YXJnZXRdKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdENhbmRpZGF0ZSA9IGtleTtcbiAgICAgICAgICAgICAgaWYgKGZpbGV0eXBlcy5tYWluLmluZGV4T2YoX2N0KSAhPT0gLTEgfHwgX2N0ID09PSBmaWxldHlwZXMucHB0eFswXSkge1xuICAgICAgICAgICAgICAgIGRvYy50ZXh0VGFyZ2V0IHx8IChkb2MudGV4dFRhcmdldCA9IHRhcmdldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZ0Q2FuZGlkYXRlID09PSBcInhsc3hcIikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRvYy50YXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ0Q2FuZGlkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ0Q2FuZGlkYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnRDYW5kaWRhdGU7XG4gICAgfVxuICB9XSk7XG59KCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHdyYXBwZXIobmV3IENvbW1vbigpKTtcbn07Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9jbGFzc0NhbGxDaGVjayIsImEiLCJuIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJlIiwiciIsInQiLCJsZW5ndGgiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl90b1Byb3BlcnR5S2V5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwiaSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiY2FsbCIsIlN0cmluZyIsIk51bWJlciIsIl9yZXF1aXJlIiwicmVxdWlyZSIsInB1c2hBcnJheSIsIndyYXBwZXIiLCJmaWxldHlwZXMiLCJfcmVxdWlyZTIiLCJzZXR0aW5nc0NvbnRlbnRUeXBlIiwiY29yZUNvbnRlbnRUeXBlIiwiYXBwQ29udGVudFR5cGUiLCJjdXN0b21Db250ZW50VHlwZSIsImRpYWdyYW1EYXRhQ29udGVudFR5cGUiLCJkaWFncmFtRHJhd2luZ0NvbnRlbnRUeXBlIiwiY29tbW9uQ29udGVudFR5cGVzIiwiQ29tbW9uIiwibmFtZSIsInZhbHVlIiwiZ2V0RmlsZVR5cGUiLCJfcmVmIiwiZG9jIiwiaW52ZXJ0ZWRDb250ZW50VHlwZXMiLCJfaTIiLCJjdCIsInRhcmdldHMiLCJrZXlzIiwiZnRDYW5kaWRhdGUiLCJfaTQiLCJjb250ZW50VHlwZXMiLCJfaTYiLCJfY3QiLCJfaTgiLCJfaW52ZXJ0ZWRDb250ZW50VHlwZXMyIiwidGFyZ2V0IiwicmVsc1R5cGVzIiwiaW5kZXhPZiIsIm1haW4iLCJwcHR4IiwidGV4dFRhcmdldCIsInB1c2giLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/modules/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/modules/expand-pair-trait.js":
/*!********************************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/expand-pair-trait.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n    for(var t = 0; t < r.length; t++){\n        var o = r[t];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n}\nfunction _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n        writable: !1\n    }), e;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar traitName = \"expandPair\";\nvar mergeSort = __webpack_require__(/*! ../merge-sort.js */ \"(rsc)/./node_modules/docxtemplater/js/merge-sort.js\");\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"), getLeft = _require.getLeft, getRight = _require.getRight, pushArray = _require.pushArray;\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(rsc)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar _require2 = __webpack_require__(/*! ../traits.js */ \"(rsc)/./node_modules/docxtemplater/js/traits.js\"), getExpandToDefault = _require2.getExpandToDefault;\nvar _require3 = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\"), getUnmatchedLoopException = _require3.getUnmatchedLoopException, getClosingTagNotMatchOpeningTag = _require3.getClosingTagNotMatchOpeningTag, getUnbalancedLoopException = _require3.getUnbalancedLoopException;\nfunction getOpenCountChange(part) {\n    switch(part.location){\n        case \"start\":\n            return 1;\n        case \"end\":\n            return -1;\n    }\n}\nfunction match(start, end) {\n    return start != null && end != null && (start.part.location === \"start\" && end.part.location === \"end\" && start.part.value === end.part.value || end.part.value === \"\");\n}\nfunction transformer(traits) {\n    var i = 0;\n    var errors = [];\n    while(i < traits.length){\n        var part = traits[i].part;\n        if (part.location === \"end\") {\n            if (i === 0) {\n                traits.splice(0, 1);\n                errors.push(getUnmatchedLoopException(part));\n                return {\n                    traits: traits,\n                    errors: errors\n                };\n            }\n            var endIndex = i;\n            var startIndex = i - 1;\n            var offseter = 1;\n            if (match(traits[startIndex], traits[endIndex])) {\n                traits.splice(endIndex, 1);\n                traits.splice(startIndex, 1);\n                return {\n                    errors: errors,\n                    traits: traits\n                };\n            }\n            while(offseter < 50){\n                var startCandidate = traits[startIndex - offseter];\n                var endCandidate = traits[endIndex + offseter];\n                if (match(startCandidate, traits[endIndex])) {\n                    traits.splice(endIndex, 1);\n                    traits.splice(startIndex - offseter, 1);\n                    return {\n                        errors: errors,\n                        traits: traits\n                    };\n                }\n                if (match(traits[startIndex], endCandidate)) {\n                    traits.splice(endIndex + offseter, 1);\n                    traits.splice(startIndex, 1);\n                    return {\n                        errors: errors,\n                        traits: traits\n                    };\n                }\n                offseter++;\n            }\n            errors.push(getClosingTagNotMatchOpeningTag({\n                tags: [\n                    traits[startIndex].part,\n                    traits[endIndex].part\n                ]\n            }));\n            traits.splice(endIndex, 1);\n            traits.splice(startIndex, 1);\n            return {\n                traits: traits,\n                errors: errors\n            };\n        }\n        i++;\n    }\n    for(var _i2 = 0; _i2 < traits.length; _i2++){\n        var _part = traits[_i2].part;\n        errors.push(getUnmatchedLoopException(_part));\n    }\n    return {\n        traits: [],\n        errors: errors\n    };\n}\nfunction getPairs(traits) {\n    var levelTraits = {};\n    var errors = [];\n    var pairs = [];\n    var transformedTraits = [];\n    pushArray(transformedTraits, traits);\n    while(transformedTraits.length > 0){\n        var result = transformer(transformedTraits);\n        pushArray(errors, result.errors);\n        transformedTraits = result.traits;\n    }\n    // Stryker disable all : because this check makes the function return quicker\n    if (errors.length > 0) {\n        return {\n            pairs: pairs,\n            errors: errors\n        };\n    }\n    // Stryker restore all\n    var countOpen = 0;\n    for(var _i4 = 0; _i4 < traits.length; _i4++){\n        var currentTrait = traits[_i4];\n        var part = currentTrait.part;\n        var change = getOpenCountChange(part);\n        countOpen += change;\n        if (change === 1) {\n            levelTraits[countOpen] = currentTrait;\n        } else {\n            var startTrait = levelTraits[countOpen + 1];\n            if (countOpen === 0) {\n                pairs.push([\n                    startTrait,\n                    currentTrait\n                ]);\n            }\n        }\n        countOpen = countOpen >= 0 ? countOpen : 0;\n    }\n    return {\n        pairs: pairs,\n        errors: errors\n    };\n}\nvar ExpandPairTrait = /*#__PURE__*/ function() {\n    function ExpandPairTrait() {\n        _classCallCheck(this, ExpandPairTrait);\n        this.name = \"ExpandPairTrait\";\n    }\n    return _createClass(ExpandPairTrait, [\n        {\n            key: \"optionsTransformer\",\n            value: function optionsTransformer(options, docxtemplater) {\n                if (docxtemplater.options.paragraphLoop) {\n                    pushArray(docxtemplater.fileTypeConfig.expandTags, docxtemplater.fileTypeConfig.onParagraphLoop);\n                }\n                this.expandTags = docxtemplater.fileTypeConfig.expandTags;\n                return options;\n            }\n        },\n        {\n            key: \"postparse\",\n            value: function postparse(postparsed, _ref) {\n                var _this = this;\n                var getTraits = _ref.getTraits, _postparse = _ref.postparse, fileType = _ref.fileType;\n                var traits = getTraits(traitName, postparsed);\n                traits = traits.map(function(trait) {\n                    return trait || [];\n                });\n                traits = mergeSort(traits);\n                var _getPairs = getPairs(traits), pairs = _getPairs.pairs, errors = _getPairs.errors;\n                var lastRight = 0;\n                var lastPair = null;\n                var expandedPairs = pairs.map(function(pair) {\n                    var expandTo = pair[0].part.expandTo;\n                    if (expandTo === \"auto\" && fileType !== \"text\") {\n                        var result = getExpandToDefault(postparsed, pair, _this.expandTags);\n                        if (result.error) {\n                            errors.push(result.error);\n                        }\n                        expandTo = result.value;\n                    }\n                    if (!expandTo || fileType === \"text\") {\n                        var _left = pair[0].offset;\n                        var _right = pair[1].offset;\n                        if (_left < lastRight && !_this.docxtemplater.options.syntax.allowUnbalancedLoops) {\n                            errors.push(getUnbalancedLoopException(pair, lastPair));\n                        }\n                        lastPair = pair;\n                        lastRight = _right;\n                        return [\n                            _left,\n                            _right\n                        ];\n                    }\n                    var left, right;\n                    try {\n                        left = getLeft(postparsed, expandTo, pair[0].offset);\n                    } catch (e) {\n                        errors.push(e);\n                    }\n                    try {\n                        right = getRight(postparsed, expandTo, pair[1].offset);\n                    } catch (e) {\n                        errors.push(e);\n                    }\n                    if (left < lastRight && !_this.docxtemplater.options.syntax.allowUnbalancedLoops) {\n                        errors.push(getUnbalancedLoopException(pair, lastPair));\n                    }\n                    lastRight = right;\n                    lastPair = pair;\n                    return [\n                        left,\n                        right\n                    ];\n                });\n                // Stryker disable all : because this check makes the function return quicker\n                if (errors.length > 0) {\n                    return {\n                        postparsed: postparsed,\n                        errors: errors\n                    };\n                }\n                // Stryker restore all\n                var currentPairIndex = 0;\n                var innerParts;\n                var newParsed = postparsed.reduce(function(newParsed, part, i) {\n                    var inPair = currentPairIndex < pairs.length && expandedPairs[currentPairIndex][0] <= i && i <= expandedPairs[currentPairIndex][1];\n                    var pair = pairs[currentPairIndex];\n                    var expandedPair = expandedPairs[currentPairIndex];\n                    if (!inPair) {\n                        newParsed.push(part);\n                        return newParsed;\n                    }\n                    // We're inside the pair\n                    if (expandedPair[0] === i) {\n                        // Start pair\n                        innerParts = [];\n                    }\n                    if (pair[0].offset !== i && pair[1].offset !== i) {\n                        // Exclude inner pair indexes\n                        innerParts.push(part);\n                    }\n                    if (expandedPair[1] === i) {\n                        // End pair\n                        var basePart = postparsed[pair[0].offset];\n                        basePart.subparsed = _postparse(innerParts, {\n                            basePart: basePart\n                        });\n                        basePart.endLindex = pair[1].part.lIndex;\n                        delete basePart.location;\n                        delete basePart.expandTo;\n                        newParsed.push(basePart);\n                        currentPairIndex++;\n                        var _expandedPair = expandedPairs[currentPairIndex];\n                        while(_expandedPair && _expandedPair[0] < i){\n                            /*\n             * If we have :\n             * expandedPairs =[[5,72],[51,67],[90,106]]\n             * Then after treating [5,72], we need to treat [90,106]\n             * Fixed since v3.58.4\n             */ currentPairIndex++;\n                            _expandedPair = expandedPairs[currentPairIndex];\n                        }\n                    }\n                    return newParsed;\n                }, []);\n                return {\n                    postparsed: newParsed,\n                    errors: errors\n                };\n            }\n        }\n    ]);\n}();\nmodule.exports = function() {\n    return wrapper(new ExpandPairTrait());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL2V4cGFuZC1wYWlyLXRyYWl0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNLLGdCQUFnQkMsQ0FBQyxFQUFFQyxDQUFDO0lBQUksSUFBSSxDQUFFRCxDQUFBQSxhQUFhQyxDQUFBQSxHQUFJLE1BQU0sSUFBSUMsVUFBVTtBQUFzQztBQUNsSCxTQUFTQyxrQkFBa0JDLENBQUMsRUFBRUMsQ0FBQztJQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxFQUFFRSxNQUFNLEVBQUVELElBQUs7UUFBRSxJQUFJWixJQUFJVyxDQUFDLENBQUNDLEVBQUU7UUFBRVosRUFBRWMsVUFBVSxHQUFHZCxFQUFFYyxVQUFVLElBQUksQ0FBQyxHQUFHZCxFQUFFZSxZQUFZLEdBQUcsQ0FBQyxHQUFHLFdBQVdmLEtBQU1BLENBQUFBLEVBQUVnQixRQUFRLEdBQUcsQ0FBQyxJQUFJQyxPQUFPQyxjQUFjLENBQUNSLEdBQUdTLGVBQWVuQixFQUFFb0IsR0FBRyxHQUFHcEI7SUFBSTtBQUFFO0FBQ3ZPLFNBQVNxQixhQUFhWCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQztJQUFJLE9BQU9ELEtBQUtGLGtCQUFrQkMsRUFBRU4sU0FBUyxFQUFFTyxJQUFJQyxLQUFLSCxrQkFBa0JDLEdBQUdFLElBQUlLLE9BQU9DLGNBQWMsQ0FBQ1IsR0FBRyxhQUFh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Q0FBQ1csaUJBQWlCO3dCQUNuRCxNQUFPVSxpQkFBaUJBLGFBQWEsQ0FBQyxFQUFFLEdBQUc1RixFQUFHOzRCQUM1Qzs7Ozs7YUFLQyxHQUNEa0Y7NEJBQ0FVLGdCQUFnQnJCLGFBQWEsQ0FBQ1csaUJBQWlCO3dCQUNqRDtvQkFDRjtvQkFDQSxPQUFPRTtnQkFDVCxHQUFHLEVBQUU7Z0JBQ0wsT0FBTztvQkFDTHhCLFlBQVl3QjtvQkFDWnZELFFBQVFBO2dCQUNWO1lBQ0Y7UUFDRjtLQUFFO0FBQ0o7QUFDQWdFLE9BQU9DLE9BQU8sR0FBRztJQUNmLE9BQU9qRixRQUFRLElBQUlxQztBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Jpa2UtcmVudGFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL2V4cGFuZC1wYWlyLXRyYWl0LmpzPzJmODUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciB0cmFpdE5hbWUgPSBcImV4cGFuZFBhaXJcIjtcbnZhciBtZXJnZVNvcnQgPSByZXF1aXJlKFwiLi4vbWVyZ2Utc29ydC5qc1wiKTtcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9kb2MtdXRpbHMuanNcIiksXG4gIGdldExlZnQgPSBfcmVxdWlyZS5nZXRMZWZ0LFxuICBnZXRSaWdodCA9IF9yZXF1aXJlLmdldFJpZ2h0LFxuICBwdXNoQXJyYXkgPSBfcmVxdWlyZS5wdXNoQXJyYXk7XG52YXIgd3JhcHBlciA9IHJlcXVpcmUoXCIuLi9tb2R1bGUtd3JhcHBlci5qc1wiKTtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi4vdHJhaXRzLmpzXCIpLFxuICBnZXRFeHBhbmRUb0RlZmF1bHQgPSBfcmVxdWlyZTIuZ2V0RXhwYW5kVG9EZWZhdWx0O1xudmFyIF9yZXF1aXJlMyA9IHJlcXVpcmUoXCIuLi9lcnJvcnMuanNcIiksXG4gIGdldFVubWF0Y2hlZExvb3BFeGNlcHRpb24gPSBfcmVxdWlyZTMuZ2V0VW5tYXRjaGVkTG9vcEV4Y2VwdGlvbixcbiAgZ2V0Q2xvc2luZ1RhZ05vdE1hdGNoT3BlbmluZ1RhZyA9IF9yZXF1aXJlMy5nZXRDbG9zaW5nVGFnTm90TWF0Y2hPcGVuaW5nVGFnLFxuICBnZXRVbmJhbGFuY2VkTG9vcEV4Y2VwdGlvbiA9IF9yZXF1aXJlMy5nZXRVbmJhbGFuY2VkTG9vcEV4Y2VwdGlvbjtcbmZ1bmN0aW9uIGdldE9wZW5Db3VudENoYW5nZShwYXJ0KSB7XG4gIHN3aXRjaCAocGFydC5sb2NhdGlvbikge1xuICAgIGNhc2UgXCJzdGFydFwiOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSBcImVuZFwiOlxuICAgICAgcmV0dXJuIC0xO1xuICB9XG59XG5mdW5jdGlvbiBtYXRjaChzdGFydCwgZW5kKSB7XG4gIHJldHVybiBzdGFydCAhPSBudWxsICYmIGVuZCAhPSBudWxsICYmIChzdGFydC5wYXJ0LmxvY2F0aW9uID09PSBcInN0YXJ0XCIgJiYgZW5kLnBhcnQubG9jYXRpb24gPT09IFwiZW5kXCIgJiYgc3RhcnQucGFydC52YWx1ZSA9PT0gZW5kLnBhcnQudmFsdWUgfHwgZW5kLnBhcnQudmFsdWUgPT09IFwiXCIpO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtZXIodHJhaXRzKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB3aGlsZSAoaSA8IHRyYWl0cy5sZW5ndGgpIHtcbiAgICB2YXIgcGFydCA9IHRyYWl0c1tpXS5wYXJ0O1xuICAgIGlmIChwYXJ0LmxvY2F0aW9uID09PSBcImVuZFwiKSB7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICB0cmFpdHMuc3BsaWNlKDAsIDEpO1xuICAgICAgICBlcnJvcnMucHVzaChnZXRVbm1hdGNoZWRMb29wRXhjZXB0aW9uKHBhcnQpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0cmFpdHM6IHRyYWl0cyxcbiAgICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIGVuZEluZGV4ID0gaTtcbiAgICAgIHZhciBzdGFydEluZGV4ID0gaSAtIDE7XG4gICAgICB2YXIgb2Zmc2V0ZXIgPSAxO1xuICAgICAgaWYgKG1hdGNoKHRyYWl0c1tzdGFydEluZGV4XSwgdHJhaXRzW2VuZEluZGV4XSkpIHtcbiAgICAgICAgdHJhaXRzLnNwbGljZShlbmRJbmRleCwgMSk7XG4gICAgICAgIHRyYWl0cy5zcGxpY2Uoc3RhcnRJbmRleCwgMSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgICAgdHJhaXRzOiB0cmFpdHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvZmZzZXRlciA8IDUwKSB7XG4gICAgICAgIHZhciBzdGFydENhbmRpZGF0ZSA9IHRyYWl0c1tzdGFydEluZGV4IC0gb2Zmc2V0ZXJdO1xuICAgICAgICB2YXIgZW5kQ2FuZGlkYXRlID0gdHJhaXRzW2VuZEluZGV4ICsgb2Zmc2V0ZXJdO1xuICAgICAgICBpZiAobWF0Y2goc3RhcnRDYW5kaWRhdGUsIHRyYWl0c1tlbmRJbmRleF0pKSB7XG4gICAgICAgICAgdHJhaXRzLnNwbGljZShlbmRJbmRleCwgMSk7XG4gICAgICAgICAgdHJhaXRzLnNwbGljZShzdGFydEluZGV4IC0gb2Zmc2V0ZXIsIDEpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgICAgICAgIHRyYWl0czogdHJhaXRzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2godHJhaXRzW3N0YXJ0SW5kZXhdLCBlbmRDYW5kaWRhdGUpKSB7XG4gICAgICAgICAgdHJhaXRzLnNwbGljZShlbmRJbmRleCArIG9mZnNldGVyLCAxKTtcbiAgICAgICAgICB0cmFpdHMuc3BsaWNlKHN0YXJ0SW5kZXgsIDEpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgICAgICAgIHRyYWl0czogdHJhaXRzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXRlcisrO1xuICAgICAgfVxuICAgICAgZXJyb3JzLnB1c2goZ2V0Q2xvc2luZ1RhZ05vdE1hdGNoT3BlbmluZ1RhZyh7XG4gICAgICAgIHRhZ3M6IFt0cmFpdHNbc3RhcnRJbmRleF0ucGFydCwgdHJhaXRzW2VuZEluZGV4XS5wYXJ0XVxuICAgICAgfSkpO1xuICAgICAgdHJhaXRzLnNwbGljZShlbmRJbmRleCwgMSk7XG4gICAgICB0cmFpdHMuc3BsaWNlKHN0YXJ0SW5kZXgsIDEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhaXRzOiB0cmFpdHMsXG4gICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICB9O1xuICAgIH1cbiAgICBpKys7XG4gIH1cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdHJhaXRzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX3BhcnQgPSB0cmFpdHNbX2kyXS5wYXJ0O1xuICAgIGVycm9ycy5wdXNoKGdldFVubWF0Y2hlZExvb3BFeGNlcHRpb24oX3BhcnQpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRyYWl0czogW10sXG4gICAgZXJyb3JzOiBlcnJvcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhaXJzKHRyYWl0cykge1xuICB2YXIgbGV2ZWxUcmFpdHMgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgcGFpcnMgPSBbXTtcbiAgdmFyIHRyYW5zZm9ybWVkVHJhaXRzID0gW107XG4gIHB1c2hBcnJheSh0cmFuc2Zvcm1lZFRyYWl0cywgdHJhaXRzKTtcbiAgd2hpbGUgKHRyYW5zZm9ybWVkVHJhaXRzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJhbnNmb3JtZXIodHJhbnNmb3JtZWRUcmFpdHMpO1xuICAgIHB1c2hBcnJheShlcnJvcnMsIHJlc3VsdC5lcnJvcnMpO1xuICAgIHRyYW5zZm9ybWVkVHJhaXRzID0gcmVzdWx0LnRyYWl0cztcbiAgfVxuXG4gIC8vIFN0cnlrZXIgZGlzYWJsZSBhbGwgOiBiZWNhdXNlIHRoaXMgY2hlY2sgbWFrZXMgdGhlIGZ1bmN0aW9uIHJldHVybiBxdWlja2VyXG4gIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBwYWlyczogcGFpcnMsXG4gICAgICBlcnJvcnM6IGVycm9yc1xuICAgIH07XG4gIH1cbiAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxuICB2YXIgY291bnRPcGVuID0gMDtcbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgdHJhaXRzLmxlbmd0aDsgX2k0KyspIHtcbiAgICB2YXIgY3VycmVudFRyYWl0ID0gdHJhaXRzW19pNF07XG4gICAgdmFyIHBhcnQgPSBjdXJyZW50VHJhaXQucGFydDtcbiAgICB2YXIgY2hhbmdlID0gZ2V0T3BlbkNvdW50Q2hhbmdlKHBhcnQpO1xuICAgIGNvdW50T3BlbiArPSBjaGFuZ2U7XG4gICAgaWYgKGNoYW5nZSA9PT0gMSkge1xuICAgICAgbGV2ZWxUcmFpdHNbY291bnRPcGVuXSA9IGN1cnJlbnRUcmFpdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0VHJhaXQgPSBsZXZlbFRyYWl0c1tjb3VudE9wZW4gKyAxXTtcbiAgICAgIGlmIChjb3VudE9wZW4gPT09IDApIHtcbiAgICAgICAgcGFpcnMucHVzaChbc3RhcnRUcmFpdCwgY3VycmVudFRyYWl0XSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvdW50T3BlbiA9IGNvdW50T3BlbiA+PSAwID8gY291bnRPcGVuIDogMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHBhaXJzOiBwYWlycyxcbiAgICBlcnJvcnM6IGVycm9yc1xuICB9O1xufVxudmFyIEV4cGFuZFBhaXJUcmFpdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV4cGFuZFBhaXJUcmFpdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXhwYW5kUGFpclRyYWl0KTtcbiAgICB0aGlzLm5hbWUgPSBcIkV4cGFuZFBhaXJUcmFpdFwiO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRXhwYW5kUGFpclRyYWl0LCBbe1xuICAgIGtleTogXCJvcHRpb25zVHJhbnNmb3JtZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW9uc1RyYW5zZm9ybWVyKG9wdGlvbnMsIGRvY3h0ZW1wbGF0ZXIpIHtcbiAgICAgIGlmIChkb2N4dGVtcGxhdGVyLm9wdGlvbnMucGFyYWdyYXBoTG9vcCkge1xuICAgICAgICBwdXNoQXJyYXkoZG9jeHRlbXBsYXRlci5maWxlVHlwZUNvbmZpZy5leHBhbmRUYWdzLCBkb2N4dGVtcGxhdGVyLmZpbGVUeXBlQ29uZmlnLm9uUGFyYWdyYXBoTG9vcCk7XG4gICAgICB9XG4gICAgICB0aGlzLmV4cGFuZFRhZ3MgPSBkb2N4dGVtcGxhdGVyLmZpbGVUeXBlQ29uZmlnLmV4cGFuZFRhZ3M7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zdHBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3RwYXJzZShwb3N0cGFyc2VkLCBfcmVmKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGdldFRyYWl0cyA9IF9yZWYuZ2V0VHJhaXRzLFxuICAgICAgICBfcG9zdHBhcnNlID0gX3JlZi5wb3N0cGFyc2UsXG4gICAgICAgIGZpbGVUeXBlID0gX3JlZi5maWxlVHlwZTtcbiAgICAgIHZhciB0cmFpdHMgPSBnZXRUcmFpdHModHJhaXROYW1lLCBwb3N0cGFyc2VkKTtcbiAgICAgIHRyYWl0cyA9IHRyYWl0cy5tYXAoZnVuY3Rpb24gKHRyYWl0KSB7XG4gICAgICAgIHJldHVybiB0cmFpdCB8fCBbXTtcbiAgICAgIH0pO1xuICAgICAgdHJhaXRzID0gbWVyZ2VTb3J0KHRyYWl0cyk7XG4gICAgICB2YXIgX2dldFBhaXJzID0gZ2V0UGFpcnModHJhaXRzKSxcbiAgICAgICAgcGFpcnMgPSBfZ2V0UGFpcnMucGFpcnMsXG4gICAgICAgIGVycm9ycyA9IF9nZXRQYWlycy5lcnJvcnM7XG4gICAgICB2YXIgbGFzdFJpZ2h0ID0gMDtcbiAgICAgIHZhciBsYXN0UGFpciA9IG51bGw7XG4gICAgICB2YXIgZXhwYW5kZWRQYWlycyA9IHBhaXJzLm1hcChmdW5jdGlvbiAocGFpcikge1xuICAgICAgICB2YXIgZXhwYW5kVG8gPSBwYWlyWzBdLnBhcnQuZXhwYW5kVG87XG4gICAgICAgIGlmIChleHBhbmRUbyA9PT0gXCJhdXRvXCIgJiYgZmlsZVR5cGUgIT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGdldEV4cGFuZFRvRGVmYXVsdChwb3N0cGFyc2VkLCBwYWlyLCBfdGhpcy5leHBhbmRUYWdzKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChyZXN1bHQuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBhbmRUbyA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV4cGFuZFRvIHx8IGZpbGVUeXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgIHZhciBfbGVmdCA9IHBhaXJbMF0ub2Zmc2V0O1xuICAgICAgICAgIHZhciBfcmlnaHQgPSBwYWlyWzFdLm9mZnNldDtcbiAgICAgICAgICBpZiAoX2xlZnQgPCBsYXN0UmlnaHQgJiYgIV90aGlzLmRvY3h0ZW1wbGF0ZXIub3B0aW9ucy5zeW50YXguYWxsb3dVbmJhbGFuY2VkTG9vcHMpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKGdldFVuYmFsYW5jZWRMb29wRXhjZXB0aW9uKHBhaXIsIGxhc3RQYWlyKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RQYWlyID0gcGFpcjtcbiAgICAgICAgICBsYXN0UmlnaHQgPSBfcmlnaHQ7XG4gICAgICAgICAgcmV0dXJuIFtfbGVmdCwgX3JpZ2h0XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVmdCwgcmlnaHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGVmdCA9IGdldExlZnQocG9zdHBhcnNlZCwgZXhwYW5kVG8sIHBhaXJbMF0ub2Zmc2V0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmlnaHQgPSBnZXRSaWdodChwb3N0cGFyc2VkLCBleHBhbmRUbywgcGFpclsxXS5vZmZzZXQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQgPCBsYXN0UmlnaHQgJiYgIV90aGlzLmRvY3h0ZW1wbGF0ZXIub3B0aW9ucy5zeW50YXguYWxsb3dVbmJhbGFuY2VkTG9vcHMpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChnZXRVbmJhbGFuY2VkTG9vcEV4Y2VwdGlvbihwYWlyLCBsYXN0UGFpcikpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RSaWdodCA9IHJpZ2h0O1xuICAgICAgICBsYXN0UGFpciA9IHBhaXI7XG4gICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFN0cnlrZXIgZGlzYWJsZSBhbGwgOiBiZWNhdXNlIHRoaXMgY2hlY2sgbWFrZXMgdGhlIGZ1bmN0aW9uIHJldHVybiBxdWlja2VyXG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwb3N0cGFyc2VkOiBwb3N0cGFyc2VkLFxuICAgICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG4gICAgICB2YXIgY3VycmVudFBhaXJJbmRleCA9IDA7XG4gICAgICB2YXIgaW5uZXJQYXJ0cztcbiAgICAgIHZhciBuZXdQYXJzZWQgPSBwb3N0cGFyc2VkLnJlZHVjZShmdW5jdGlvbiAobmV3UGFyc2VkLCBwYXJ0LCBpKSB7XG4gICAgICAgIHZhciBpblBhaXIgPSBjdXJyZW50UGFpckluZGV4IDwgcGFpcnMubGVuZ3RoICYmIGV4cGFuZGVkUGFpcnNbY3VycmVudFBhaXJJbmRleF1bMF0gPD0gaSAmJiBpIDw9IGV4cGFuZGVkUGFpcnNbY3VycmVudFBhaXJJbmRleF1bMV07XG4gICAgICAgIHZhciBwYWlyID0gcGFpcnNbY3VycmVudFBhaXJJbmRleF07XG4gICAgICAgIHZhciBleHBhbmRlZFBhaXIgPSBleHBhbmRlZFBhaXJzW2N1cnJlbnRQYWlySW5kZXhdO1xuICAgICAgICBpZiAoIWluUGFpcikge1xuICAgICAgICAgIG5ld1BhcnNlZC5wdXNoKHBhcnQpO1xuICAgICAgICAgIHJldHVybiBuZXdQYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UncmUgaW5zaWRlIHRoZSBwYWlyXG4gICAgICAgIGlmIChleHBhbmRlZFBhaXJbMF0gPT09IGkpIHtcbiAgICAgICAgICAvLyBTdGFydCBwYWlyXG4gICAgICAgICAgaW5uZXJQYXJ0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWlyWzBdLm9mZnNldCAhPT0gaSAmJiBwYWlyWzFdLm9mZnNldCAhPT0gaSkge1xuICAgICAgICAgIC8vIEV4Y2x1ZGUgaW5uZXIgcGFpciBpbmRleGVzXG4gICAgICAgICAgaW5uZXJQYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBhbmRlZFBhaXJbMV0gPT09IGkpIHtcbiAgICAgICAgICAvLyBFbmQgcGFpclxuICAgICAgICAgIHZhciBiYXNlUGFydCA9IHBvc3RwYXJzZWRbcGFpclswXS5vZmZzZXRdO1xuICAgICAgICAgIGJhc2VQYXJ0LnN1YnBhcnNlZCA9IF9wb3N0cGFyc2UoaW5uZXJQYXJ0cywge1xuICAgICAgICAgICAgYmFzZVBhcnQ6IGJhc2VQYXJ0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYmFzZVBhcnQuZW5kTGluZGV4ID0gcGFpclsxXS5wYXJ0LmxJbmRleDtcbiAgICAgICAgICBkZWxldGUgYmFzZVBhcnQubG9jYXRpb247XG4gICAgICAgICAgZGVsZXRlIGJhc2VQYXJ0LmV4cGFuZFRvO1xuICAgICAgICAgIG5ld1BhcnNlZC5wdXNoKGJhc2VQYXJ0KTtcbiAgICAgICAgICBjdXJyZW50UGFpckluZGV4Kys7XG4gICAgICAgICAgdmFyIF9leHBhbmRlZFBhaXIgPSBleHBhbmRlZFBhaXJzW2N1cnJlbnRQYWlySW5kZXhdO1xuICAgICAgICAgIHdoaWxlIChfZXhwYW5kZWRQYWlyICYmIF9leHBhbmRlZFBhaXJbMF0gPCBpKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogSWYgd2UgaGF2ZSA6XG4gICAgICAgICAgICAgKiBleHBhbmRlZFBhaXJzID1bWzUsNzJdLFs1MSw2N10sWzkwLDEwNl1dXG4gICAgICAgICAgICAgKiBUaGVuIGFmdGVyIHRyZWF0aW5nIFs1LDcyXSwgd2UgbmVlZCB0byB0cmVhdCBbOTAsMTA2XVxuICAgICAgICAgICAgICogRml4ZWQgc2luY2UgdjMuNTguNFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjdXJyZW50UGFpckluZGV4Kys7XG4gICAgICAgICAgICBfZXhwYW5kZWRQYWlyID0gZXhwYW5kZWRQYWlyc1tjdXJyZW50UGFpckluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1BhcnNlZDtcbiAgICAgIH0sIFtdKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvc3RwYXJzZWQ6IG5ld1BhcnNlZCxcbiAgICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG59KCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHdyYXBwZXIobmV3IEV4cGFuZFBhaXJUcmFpdCgpKTtcbn07Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9jbGFzc0NhbGxDaGVjayIsImEiLCJuIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJlIiwiciIsInQiLCJsZW5ndGgiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl90b1Byb3BlcnR5S2V5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwiaSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiY2FsbCIsIlN0cmluZyIsIk51bWJlciIsInRyYWl0TmFtZSIsIm1lcmdlU29ydCIsInJlcXVpcmUiLCJfcmVxdWlyZSIsImdldExlZnQiLCJnZXRSaWdodCIsInB1c2hBcnJheSIsIndyYXBwZXIiLCJfcmVxdWlyZTIiLCJnZXRFeHBhbmRUb0RlZmF1bHQiLCJfcmVxdWlyZTMiLCJnZXRVbm1hdGNoZWRMb29wRXhjZXB0aW9uIiwiZ2V0Q2xvc2luZ1RhZ05vdE1hdGNoT3BlbmluZ1RhZyIsImdldFVuYmFsYW5jZWRMb29wRXhjZXB0aW9uIiwiZ2V0T3BlbkNvdW50Q2hhbmdlIiwicGFydCIsImxvY2F0aW9uIiwibWF0Y2giLCJzdGFydCIsImVuZCIsInZhbHVlIiwidHJhbnNmb3JtZXIiLCJ0cmFpdHMiLCJlcnJvcnMiLCJzcGxpY2UiLCJwdXNoIiwiZW5kSW5kZXgiLCJzdGFydEluZGV4Iiwib2Zmc2V0ZXIiLCJzdGFydENhbmRpZGF0ZSIsImVuZENhbmRpZGF0ZSIsInRhZ3MiLCJfaTIiLCJfcGFydCIsImdldFBhaXJzIiwibGV2ZWxUcmFpdHMiLCJwYWlycyIsInRyYW5zZm9ybWVkVHJhaXRzIiwicmVzdWx0IiwiY291bnRPcGVuIiwiX2k0IiwiY3VycmVudFRyYWl0IiwiY2hhbmdlIiwic3RhcnRUcmFpdCIsIkV4cGFuZFBhaXJUcmFpdCIsIm5hbWUiLCJvcHRpb25zVHJhbnNmb3JtZXIiLCJvcHRpb25zIiwiZG9jeHRlbXBsYXRlciIsInBhcmFncmFwaExvb3AiLCJmaWxlVHlwZUNvbmZpZyIsImV4cGFuZFRhZ3MiLCJvblBhcmFncmFwaExvb3AiLCJwb3N0cGFyc2UiLCJwb3N0cGFyc2VkIiwiX3JlZiIsIl90aGlzIiwiZ2V0VHJhaXRzIiwiX3Bvc3RwYXJzZSIsImZpbGVUeXBlIiwibWFwIiwidHJhaXQiLCJfZ2V0UGFpcnMiLCJsYXN0UmlnaHQiLCJsYXN0UGFpciIsImV4cGFuZGVkUGFpcnMiLCJwYWlyIiwiZXhwYW5kVG8iLCJlcnJvciIsIl9sZWZ0Iiwib2Zmc2V0IiwiX3JpZ2h0Iiwic3ludGF4IiwiYWxsb3dVbmJhbGFuY2VkTG9vcHMiLCJsZWZ0IiwicmlnaHQiLCJjdXJyZW50UGFpckluZGV4IiwiaW5uZXJQYXJ0cyIsIm5ld1BhcnNlZCIsInJlZHVjZSIsImluUGFpciIsImV4cGFuZGVkUGFpciIsImJhc2VQYXJ0Iiwic3VicGFyc2VkIiwiZW5kTGluZGV4IiwibEluZGV4IiwiX2V4cGFuZGVkUGFpciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/modules/expand-pair-trait.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/modules/loop.js":
/*!*******************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/loop.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\nfunction _slicedToArray(r, e) {\n    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(r, a) {\n    if (r) {\n        if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n        var t = ({}).toString.call(r).slice(8, -1);\n        return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n    }\n}\nfunction _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];\n    return n;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(r) {\n    if (Array.isArray(r)) return r;\n}\nfunction _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n    for(var t = 0; t < r.length; t++){\n        var o = r[t];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n}\nfunction _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n        writable: !1\n    }), e;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"), chunkBy = _require.chunkBy, last = _require.last, isParagraphStart = _require.isParagraphStart, isModule = _require.isModule, pushArray = _require.pushArray, isParagraphEnd = _require.isParagraphEnd, isContent = _require.isContent, startsWith = _require.startsWith, isTagEnd = _require.isTagEnd, isTagStart = _require.isTagStart, getSingleAttribute = _require.getSingleAttribute, setSingleAttribute = _require.setSingleAttribute;\nvar filetypes = __webpack_require__(/*! ../filetypes.js */ \"(rsc)/./node_modules/docxtemplater/js/filetypes.js\");\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(rsc)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar moduleName = \"loop\";\nfunction hasContent(parts) {\n    return parts.some(function(part) {\n        return isContent(part);\n    });\n}\nfunction getFirstMeaningFulPart(parsed) {\n    for(var _i2 = 0; _i2 < parsed.length; _i2++){\n        var part = parsed[_i2];\n        if (part.type !== \"content\") {\n            return part;\n        }\n    }\n    return null;\n}\nfunction isInsideParagraphLoop(part) {\n    var firstMeaningfulPart = getFirstMeaningFulPart(part.subparsed);\n    return firstMeaningfulPart != null && firstMeaningfulPart.tag !== \"w:t\";\n}\nfunction getPageBreakIfApplies(part) {\n    return part.hasPageBreak && isInsideParagraphLoop(part) ? '<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>' : \"\";\n}\nfunction isEnclosedByParagraphs(parsed) {\n    return parsed.length && isParagraphStart(parsed[0]) && isParagraphEnd(last(parsed));\n}\nfunction getOffset(chunk) {\n    return hasContent(chunk) ? 0 : chunk.length;\n}\nfunction addPageBreakAtEnd(subRendered) {\n    var j = subRendered.parts.length - 1;\n    if (subRendered.parts[j] === \"</w:p>\") {\n        subRendered.parts.splice(j, 0, '<w:r><w:br w:type=\"page\"/></w:r>');\n    } else {\n        subRendered.parts.push('<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>');\n    }\n}\nfunction addPageBreakAtBeginning(subRendered) {\n    subRendered.parts.unshift('<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>');\n}\nfunction isContinuous(parts) {\n    return parts.some(function(part) {\n        return isTagStart(\"w:type\", part) && part.value.indexOf(\"continuous\") !== -1;\n    });\n}\nfunction isNextPage(parts) {\n    return parts.some(function(part) {\n        return isTagStart(\"w:type\", part) && part.value.indexOf('w:val=\"nextPage\"') !== -1;\n    });\n}\nfunction addSectionBefore(parts, sect) {\n    return pushArray([\n        \"<w:p><w:pPr>\".concat(sect.map(function(_ref) {\n            var value = _ref.value;\n            return value;\n        }).join(\"\"), \"</w:pPr></w:p>\")\n    ], parts);\n}\nfunction addContinuousType(parts) {\n    var stop = false;\n    var inSectPr = false;\n    return parts.reduce(function(result, part) {\n        if (stop === false && startsWith(part, \"<w:sectPr\")) {\n            inSectPr = true;\n        }\n        if (inSectPr) {\n            if (startsWith(part, \"<w:type\")) {\n                stop = true;\n            }\n            if (stop === false && startsWith(part, \"</w:sectPr\")) {\n                result.push('<w:type w:val=\"continuous\"/>');\n            }\n        }\n        result.push(part);\n        return result;\n    }, []);\n}\nfunction dropHeaderFooterRefs(parts) {\n    return parts.filter(function(text) {\n        return !startsWith(text, \"<w:headerReference\") && !startsWith(text, \"<w:footerReference\");\n    });\n}\nfunction hasPageBreak(chunk) {\n    return chunk.some(function(part) {\n        return part.tag === \"w:br\" && part.value.indexOf('w:type=\"page\"') !== -1;\n    });\n}\nfunction hasImage(chunk) {\n    return chunk.some(function(_ref2) {\n        var tag = _ref2.tag;\n        return tag === \"w:drawing\";\n    });\n}\nfunction getSectPr(chunks) {\n    var collectSectPr = false;\n    var sectPrs = [];\n    for(var _i4 = 0; _i4 < chunks.length; _i4++){\n        var part = chunks[_i4];\n        if (isTagStart(\"w:sectPr\", part)) {\n            sectPrs.push([]);\n            collectSectPr = true;\n        }\n        if (collectSectPr) {\n            sectPrs[sectPrs.length - 1].push(part);\n        }\n        if (isTagEnd(\"w:sectPr\", part)) {\n            collectSectPr = false;\n        }\n    }\n    return sectPrs;\n}\nfunction getSectPrHeaderFooterChangeCount(chunks) {\n    var collectSectPr = false;\n    var sectPrCount = 0;\n    for(var _i6 = 0; _i6 < chunks.length; _i6++){\n        var part = chunks[_i6];\n        if (isTagStart(\"w:sectPr\", part)) {\n            collectSectPr = true;\n        }\n        if (collectSectPr) {\n            if (part.tag === \"w:headerReference\" || part.tag === \"w:footerReference\") {\n                sectPrCount++;\n                collectSectPr = false;\n            }\n        }\n        if (isTagEnd(\"w:sectPr\", part)) {\n            collectSectPr = false;\n        }\n    }\n    return sectPrCount;\n}\nfunction getLastSectPr(parsed) {\n    var sectPr = [];\n    var inSectPr = false;\n    for(var i = parsed.length - 1; i >= 0; i--){\n        var part = parsed[i];\n        if (isTagEnd(\"w:sectPr\", part)) {\n            inSectPr = true;\n        }\n        if (isTagStart(\"w:sectPr\", part)) {\n            sectPr.unshift(part.value);\n            inSectPr = false;\n        }\n        if (inSectPr) {\n            sectPr.unshift(part.value);\n        }\n        if (isParagraphStart(part)) {\n            if (sectPr.length > 0) {\n                return sectPr.join(\"\");\n            }\n            break;\n        }\n    }\n    return \"\";\n}\nvar LoopModule = /*#__PURE__*/ function() {\n    function LoopModule() {\n        _classCallCheck(this, LoopModule);\n        this.name = \"LoopModule\";\n        this.inXfrm = false;\n        this.totalSectPr = 0;\n        this.prefix = {\n            start: \"#\",\n            end: \"/\",\n            dash: /^-([^\\s]+)\\s(.+)/,\n            inverted: \"^\"\n        };\n    }\n    return _createClass(LoopModule, [\n        {\n            key: \"optionsTransformer\",\n            value: function optionsTransformer(opts, docxtemplater) {\n                this.docxtemplater = docxtemplater;\n                return opts;\n            }\n        },\n        {\n            key: \"preparse\",\n            value: function preparse(parsed, _ref3) {\n                var contentType = _ref3.contentType;\n                if (filetypes.main.indexOf(contentType) !== -1) {\n                    this.sects = getSectPr(parsed);\n                }\n            }\n        },\n        {\n            key: \"matchers\",\n            value: function matchers() {\n                var module1 = moduleName;\n                return [\n                    [\n                        this.prefix.start,\n                        module1,\n                        {\n                            expandTo: \"auto\",\n                            location: \"start\",\n                            inverted: false\n                        }\n                    ],\n                    [\n                        this.prefix.inverted,\n                        module1,\n                        {\n                            expandTo: \"auto\",\n                            location: \"start\",\n                            inverted: true\n                        }\n                    ],\n                    [\n                        this.prefix.end,\n                        module1,\n                        {\n                            location: \"end\"\n                        }\n                    ],\n                    [\n                        this.prefix.dash,\n                        module1,\n                        function(_ref4) {\n                            var _ref5 = _slicedToArray(_ref4, 3), expandTo = _ref5[1], value = _ref5[2];\n                            return {\n                                location: \"start\",\n                                inverted: false,\n                                expandTo: expandTo,\n                                value: value\n                            };\n                        }\n                    ]\n                ];\n            }\n        },\n        {\n            key: \"getTraits\",\n            value: function getTraits(traitName, parsed) {\n                // Stryker disable all : because getTraits should disappear in v4\n                if (traitName !== \"expandPair\") {\n                    return;\n                }\n                // Stryker restore all\n                return parsed.reduce(function(tags, part, offset) {\n                    if (isModule(part, moduleName) && part.subparsed == null) {\n                        tags.push({\n                            part: part,\n                            offset: offset\n                        });\n                    }\n                    return tags;\n                }, []);\n            }\n        },\n        {\n            key: \"postparse\",\n            value: function postparse(parsed, _ref6) {\n                var basePart = _ref6.basePart;\n                if (basePart && this.docxtemplater.fileType === \"docx\" && parsed.length > 0) {\n                    basePart.sectPrCount = getSectPrHeaderFooterChangeCount(parsed);\n                    this.totalSectPr += basePart.sectPrCount;\n                    var sects = this.sects;\n                    sects.some(function(sect, index) {\n                        if (basePart.lIndex < sect[0].lIndex) {\n                            if (index + 1 < sects.length && isContinuous(sects[index + 1])) {\n                                basePart.addContinuousType = true;\n                            }\n                            return true;\n                        }\n                        if (parsed[0].lIndex < sect[0].lIndex && sect[0].lIndex < basePart.lIndex) {\n                            if (isNextPage(sects[index])) {\n                                basePart.addNextPage = {\n                                    index: index\n                                };\n                            }\n                            return true;\n                        }\n                    });\n                    basePart.lastParagrapSectPr = getLastSectPr(parsed);\n                }\n                if (!basePart || basePart.expandTo !== \"auto\" || basePart.module !== moduleName || !isEnclosedByParagraphs(parsed)) {\n                    return parsed;\n                }\n                basePart.paragraphLoop = true;\n                var level = 0;\n                var chunks = chunkBy(parsed, function(p) {\n                    if (isParagraphStart(p)) {\n                        level++;\n                        if (level === 1) {\n                            return \"start\";\n                        }\n                    }\n                    if (isParagraphEnd(p)) {\n                        level--;\n                        if (level === 0) {\n                            return \"end\";\n                        }\n                    }\n                    return null;\n                });\n                var firstChunk = chunks[0];\n                var lastChunk = last(chunks);\n                var firstOffset = getOffset(firstChunk);\n                var lastOffset = getOffset(lastChunk);\n                basePart.hasPageBreakBeginning = hasPageBreak(firstChunk);\n                basePart.hasPageBreak = hasPageBreak(lastChunk);\n                if (hasImage(firstChunk)) {\n                    firstOffset = 0;\n                }\n                if (hasImage(lastChunk)) {\n                    lastOffset = 0;\n                }\n                return parsed.slice(firstOffset, parsed.length - lastOffset);\n            }\n        },\n        {\n            key: \"resolve\",\n            value: function resolve(part, options) {\n                if (!isModule(part, moduleName)) {\n                    return null;\n                }\n                var sm = options.scopeManager;\n                var promisedValue = sm.getValueAsync(part.value, {\n                    part: part\n                });\n                var promises = [];\n                function loopOver(scope, i, length) {\n                    var scopeManager = sm.createSubScopeManager(scope, part.value, i, part, length);\n                    promises.push(options.resolve(_objectSpread(_objectSpread({}, options), {}, {\n                        compiled: part.subparsed,\n                        tags: {},\n                        scopeManager: scopeManager\n                    })));\n                }\n                var errorList = [];\n                return promisedValue.then(function(values) {\n                    return new Promise(function(resolve) {\n                        if (values instanceof Array) {\n                            Promise.all(values).then(resolve);\n                        } else {\n                            resolve(values);\n                        }\n                    }).then(function(values) {\n                        sm.loopOverValue(values, loopOver, part.inverted);\n                        return Promise.all(promises).then(function(r) {\n                            return r.map(function(_ref7) {\n                                var resolved = _ref7.resolved, errors = _ref7.errors;\n                                pushArray(errorList, errors);\n                                return resolved;\n                            });\n                        }).then(function(value) {\n                            if (errorList.length > 0) {\n                                throw errorList;\n                            }\n                            return value;\n                        });\n                    });\n                });\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(part, options) {\n                if (part.tag === \"p:xfrm\") {\n                    this.inXfrm = part.position === \"start\";\n                }\n                if (part.tag === \"a:ext\" && this.inXfrm) {\n                    this.lastExt = part;\n                    return part;\n                }\n                if (!isModule(part, moduleName)) {\n                    return null;\n                }\n                var totalValue = [];\n                var errors = [];\n                var heightOffset = 0;\n                var self = this;\n                var firstTag = part.subparsed[0];\n                var tagHeight = 0;\n                if ((firstTag === null || firstTag === void 0 ? void 0 : firstTag.tag) === \"a:tr\") {\n                    tagHeight = +getSingleAttribute(firstTag.value, \"h\");\n                }\n                heightOffset -= tagHeight;\n                var a16RowIdOffset = 0;\n                var insideParagraphLoop = isInsideParagraphLoop(part);\n                function loopOver(scope, i, length) {\n                    heightOffset += tagHeight;\n                    var scopeManager = options.scopeManager.createSubScopeManager(scope, part.value, i, part, length);\n                    for(var _i8 = 0, _part$subparsed2 = part.subparsed; _i8 < _part$subparsed2.length; _i8++){\n                        var pp = _part$subparsed2[_i8];\n                        if (isTagStart(\"a16:rowId\", pp)) {\n                            var val = +getSingleAttribute(pp.value, \"val\") + a16RowIdOffset;\n                            a16RowIdOffset = 1;\n                            pp.value = setSingleAttribute(pp.value, \"val\", val);\n                        }\n                    }\n                    var subRendered = options.render(_objectSpread(_objectSpread({}, options), {}, {\n                        compiled: part.subparsed,\n                        tags: {},\n                        scopeManager: scopeManager\n                    }));\n                    if (part.hasPageBreak && i === length - 1 && insideParagraphLoop) {\n                        addPageBreakAtEnd(subRendered);\n                    }\n                    var isNotFirst = scopeManager.scopePathItem.some(function(i) {\n                        return i !== 0;\n                    });\n                    if (isNotFirst) {\n                        if (part.sectPrCount === 1) {\n                            subRendered.parts = dropHeaderFooterRefs(subRendered.parts);\n                        }\n                        if (part.addContinuousType) {\n                            subRendered.parts = addContinuousType(subRendered.parts);\n                        }\n                    } else if (part.addNextPage) {\n                        subRendered.parts = addSectionBefore(subRendered.parts, self.sects[part.addNextPage.index]);\n                    }\n                    if (part.addNextPage) {\n                        addPageBreakAtEnd(subRendered);\n                    }\n                    if (part.hasPageBreakBeginning && insideParagraphLoop) {\n                        addPageBreakAtBeginning(subRendered);\n                    }\n                    for(var _i10 = 0, _subRendered$parts2 = subRendered.parts; _i10 < _subRendered$parts2.length; _i10++){\n                        var _val = _subRendered$parts2[_i10];\n                        totalValue.push(_val);\n                    }\n                    pushArray(errors, subRendered.errors);\n                }\n                var result = options.scopeManager.loopOver(part.value, loopOver, part.inverted, {\n                    part: part\n                });\n                // if the loop is showing empty content\n                if (result === false) {\n                    if (part.lastParagrapSectPr) {\n                        if (part.paragraphLoop) {\n                            return {\n                                value: \"<w:p><w:pPr>\".concat(part.lastParagrapSectPr, \"</w:pPr></w:p>\")\n                            };\n                        }\n                        return {\n                            value: \"</w:t></w:r></w:p><w:p><w:pPr>\".concat(part.lastParagrapSectPr, \"</w:pPr><w:r><w:t>\")\n                        };\n                    }\n                    return {\n                        value: getPageBreakIfApplies(part) || \"\",\n                        errors: errors\n                    };\n                }\n                if (heightOffset !== 0) {\n                    var cy = +getSingleAttribute(this.lastExt.value, \"cy\");\n                    /*\n         * We do edit the value of a previous result here\n         * #edit-value-backwards\n         */ this.lastExt.value = setSingleAttribute(this.lastExt.value, \"cy\", cy + heightOffset);\n                }\n                return {\n                    value: options.joinUncorrupt(totalValue, _objectSpread(_objectSpread({}, options), {}, {\n                        basePart: part\n                    })),\n                    errors: errors\n                };\n            }\n        }\n    ]);\n}();\nmodule.exports = function() {\n    return wrapper(new LoopModule());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL2xvb3AuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRUcsV0FBVyxLQUFLRixVQUFVRCxNQUFNQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1QsU0FBU0ssUUFBUUMsQ0FBQyxFQUFFQyxDQUFDO0lBQUksSUFBSUMsSUFBSUMsT0FBT0MsSUFBSSxDQUFDSjtJQUFJLElBQUlHLE9BQU9FLHFCQUFxQixFQUFFO1FBQUUsSUFBSVgsSUFBSVMsT0FBT0UscUJBQXFCLENBQUNMO1FBQUlDLEtBQU1QLENBQUFBLElBQUlBLEVBQUVZLE1BQU0sQ0FBQyxTQUFVTCxDQUFDO1lBQUksT0FBT0UsT0FBT0ksd0JBQXdCLENBQUNQLEdBQUdDLEdBQUdPLFVBQVU7UUFBRSxFQUFDLEdBQUlOLEVBQUVPLElBQUksQ0FBQ0MsS0FBSyxDQUFDUixHQUFHUjtJQUFJO0lBQUUsT0FBT1E7QUFBRztBQUM5UCxTQUFTUyxjQUFjWCxDQUFDO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlXLFVBQVVDLE1BQU0sRUFBRVosSUFBSztRQUFFLElBQUlDLElBQUksUUFBUVUsU0FBUyxDQUFDWCxFQUFFLEdBQUdXLFNBQVMsQ0FBQ1gsRUFBRSxHQUFHLENBQUM7UUFBR0EsSUFBSSxJQUFJRixRQUFRSSxPQUFPRCxJQUFJLENBQUMsR0FBR1ksT0FBTyxDQUFDLFNBQVViLENBQUM7WUFBSWMsZ0JBQWdCZixHQUFHQyxHQUFHQyxDQUFDLENBQUNELEVBQUU7UUFB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THZJLE9BQU8saUNBQWlDK0UsTUFBTSxDQUFDekIsS0FBS2lGLGtCQUFrQixFQUFFO3dCQUMxRTtvQkFDRjtvQkFDQSxPQUFPO3dCQUNMdkksT0FBTytELHNCQUFzQlQsU0FBUzt3QkFDdEM2RyxRQUFRQTtvQkFDVjtnQkFDRjtnQkFDQSxJQUFJSyxpQkFBaUIsR0FBRztvQkFDdEIsSUFBSWUsS0FBSyxDQUFDekksbUJBQW1CLElBQUksQ0FBQ3dILE9BQU8sQ0FBQ3RLLEtBQUssRUFBRTtvQkFDakQ7OztTQUdDLEdBQ0QsSUFBSSxDQUFDc0ssT0FBTyxDQUFDdEssS0FBSyxHQUFHK0MsbUJBQW1CLElBQUksQ0FBQ3VILE9BQU8sQ0FBQ3RLLEtBQUssRUFBRSxNQUFNdUwsS0FBS2Y7Z0JBQ3pFO2dCQUNBLE9BQU87b0JBQ0x4SyxPQUFPaUosUUFBUXVDLGFBQWEsQ0FBQ2pCLFlBQVloTCxjQUFjQSxjQUFjLENBQUMsR0FBRzBKLFVBQVUsQ0FBQyxHQUFHO3dCQUNyRmYsVUFBVTVFO29CQUNaO29CQUNBNkcsUUFBUUE7Z0JBQ1Y7WUFDRjtRQUNGO0tBQUU7QUFDSjtBQUNBNUMsT0FBT2tFLE9BQU8sR0FBRztJQUNmLE9BQU94SSxRQUFRLElBQUlxRDtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Jpa2UtcmVudGFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL2xvb3AuanM/YTllMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkgeyByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7IHZhbHVlOiB0LCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVtyXSA9IHQsIGU7IH1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9kb2MtdXRpbHMuanNcIiksXG4gIGNodW5rQnkgPSBfcmVxdWlyZS5jaHVua0J5LFxuICBsYXN0ID0gX3JlcXVpcmUubGFzdCxcbiAgaXNQYXJhZ3JhcGhTdGFydCA9IF9yZXF1aXJlLmlzUGFyYWdyYXBoU3RhcnQsXG4gIGlzTW9kdWxlID0gX3JlcXVpcmUuaXNNb2R1bGUsXG4gIHB1c2hBcnJheSA9IF9yZXF1aXJlLnB1c2hBcnJheSxcbiAgaXNQYXJhZ3JhcGhFbmQgPSBfcmVxdWlyZS5pc1BhcmFncmFwaEVuZCxcbiAgaXNDb250ZW50ID0gX3JlcXVpcmUuaXNDb250ZW50LFxuICBzdGFydHNXaXRoID0gX3JlcXVpcmUuc3RhcnRzV2l0aCxcbiAgaXNUYWdFbmQgPSBfcmVxdWlyZS5pc1RhZ0VuZCxcbiAgaXNUYWdTdGFydCA9IF9yZXF1aXJlLmlzVGFnU3RhcnQsXG4gIGdldFNpbmdsZUF0dHJpYnV0ZSA9IF9yZXF1aXJlLmdldFNpbmdsZUF0dHJpYnV0ZSxcbiAgc2V0U2luZ2xlQXR0cmlidXRlID0gX3JlcXVpcmUuc2V0U2luZ2xlQXR0cmlidXRlO1xudmFyIGZpbGV0eXBlcyA9IHJlcXVpcmUoXCIuLi9maWxldHlwZXMuanNcIik7XG52YXIgd3JhcHBlciA9IHJlcXVpcmUoXCIuLi9tb2R1bGUtd3JhcHBlci5qc1wiKTtcbnZhciBtb2R1bGVOYW1lID0gXCJsb29wXCI7XG5mdW5jdGlvbiBoYXNDb250ZW50KHBhcnRzKSB7XG4gIHJldHVybiBwYXJ0cy5zb21lKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgcmV0dXJuIGlzQ29udGVudChwYXJ0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRGaXJzdE1lYW5pbmdGdWxQYXJ0KHBhcnNlZCkge1xuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwYXJzZWQubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBwYXJ0ID0gcGFyc2VkW19pMl07XG4gICAgaWYgKHBhcnQudHlwZSAhPT0gXCJjb250ZW50XCIpIHtcbiAgICAgIHJldHVybiBwYXJ0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzSW5zaWRlUGFyYWdyYXBoTG9vcChwYXJ0KSB7XG4gIHZhciBmaXJzdE1lYW5pbmdmdWxQYXJ0ID0gZ2V0Rmlyc3RNZWFuaW5nRnVsUGFydChwYXJ0LnN1YnBhcnNlZCk7XG4gIHJldHVybiBmaXJzdE1lYW5pbmdmdWxQYXJ0ICE9IG51bGwgJiYgZmlyc3RNZWFuaW5nZnVsUGFydC50YWcgIT09IFwidzp0XCI7XG59XG5mdW5jdGlvbiBnZXRQYWdlQnJlYWtJZkFwcGxpZXMocGFydCkge1xuICByZXR1cm4gcGFydC5oYXNQYWdlQnJlYWsgJiYgaXNJbnNpZGVQYXJhZ3JhcGhMb29wKHBhcnQpID8gJzx3OnA+PHc6cj48dzpiciB3OnR5cGU9XCJwYWdlXCIvPjwvdzpyPjwvdzpwPicgOiBcIlwiO1xufVxuZnVuY3Rpb24gaXNFbmNsb3NlZEJ5UGFyYWdyYXBocyhwYXJzZWQpIHtcbiAgcmV0dXJuIHBhcnNlZC5sZW5ndGggJiYgaXNQYXJhZ3JhcGhTdGFydChwYXJzZWRbMF0pICYmIGlzUGFyYWdyYXBoRW5kKGxhc3QocGFyc2VkKSk7XG59XG5mdW5jdGlvbiBnZXRPZmZzZXQoY2h1bmspIHtcbiAgcmV0dXJuIGhhc0NvbnRlbnQoY2h1bmspID8gMCA6IGNodW5rLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGFkZFBhZ2VCcmVha0F0RW5kKHN1YlJlbmRlcmVkKSB7XG4gIHZhciBqID0gc3ViUmVuZGVyZWQucGFydHMubGVuZ3RoIC0gMTtcbiAgaWYgKHN1YlJlbmRlcmVkLnBhcnRzW2pdID09PSBcIjwvdzpwPlwiKSB7XG4gICAgc3ViUmVuZGVyZWQucGFydHMuc3BsaWNlKGosIDAsICc8dzpyPjx3OmJyIHc6dHlwZT1cInBhZ2VcIi8+PC93OnI+Jyk7XG4gIH0gZWxzZSB7XG4gICAgc3ViUmVuZGVyZWQucGFydHMucHVzaCgnPHc6cD48dzpyPjx3OmJyIHc6dHlwZT1cInBhZ2VcIi8+PC93OnI+PC93OnA+Jyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFBhZ2VCcmVha0F0QmVnaW5uaW5nKHN1YlJlbmRlcmVkKSB7XG4gIHN1YlJlbmRlcmVkLnBhcnRzLnVuc2hpZnQoJzx3OnA+PHc6cj48dzpiciB3OnR5cGU9XCJwYWdlXCIvPjwvdzpyPjwvdzpwPicpO1xufVxuZnVuY3Rpb24gaXNDb250aW51b3VzKHBhcnRzKSB7XG4gIHJldHVybiBwYXJ0cy5zb21lKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgcmV0dXJuIGlzVGFnU3RhcnQoXCJ3OnR5cGVcIiwgcGFydCkgJiYgcGFydC52YWx1ZS5pbmRleE9mKFwiY29udGludW91c1wiKSAhPT0gLTE7XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNOZXh0UGFnZShwYXJ0cykge1xuICByZXR1cm4gcGFydHMuc29tZShmdW5jdGlvbiAocGFydCkge1xuICAgIHJldHVybiBpc1RhZ1N0YXJ0KFwidzp0eXBlXCIsIHBhcnQpICYmIHBhcnQudmFsdWUuaW5kZXhPZigndzp2YWw9XCJuZXh0UGFnZVwiJykgIT09IC0xO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZFNlY3Rpb25CZWZvcmUocGFydHMsIHNlY3QpIHtcbiAgcmV0dXJuIHB1c2hBcnJheShbXCI8dzpwPjx3OnBQcj5cIi5jb25jYXQoc2VjdC5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSkuam9pbihcIlwiKSwgXCI8L3c6cFByPjwvdzpwPlwiKV0sIHBhcnRzKTtcbn1cbmZ1bmN0aW9uIGFkZENvbnRpbnVvdXNUeXBlKHBhcnRzKSB7XG4gIHZhciBzdG9wID0gZmFsc2U7XG4gIHZhciBpblNlY3RQciA9IGZhbHNlO1xuICByZXR1cm4gcGFydHMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHBhcnQpIHtcbiAgICBpZiAoc3RvcCA9PT0gZmFsc2UgJiYgc3RhcnRzV2l0aChwYXJ0LCBcIjx3OnNlY3RQclwiKSkge1xuICAgICAgaW5TZWN0UHIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaW5TZWN0UHIpIHtcbiAgICAgIGlmIChzdGFydHNXaXRoKHBhcnQsIFwiPHc6dHlwZVwiKSkge1xuICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdG9wID09PSBmYWxzZSAmJiBzdGFydHNXaXRoKHBhcnQsIFwiPC93OnNlY3RQclwiKSkge1xuICAgICAgICByZXN1bHQucHVzaCgnPHc6dHlwZSB3OnZhbD1cImNvbnRpbnVvdXNcIi8+Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHBhcnQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIGRyb3BIZWFkZXJGb290ZXJSZWZzKHBhcnRzKSB7XG4gIHJldHVybiBwYXJ0cy5maWx0ZXIoZnVuY3Rpb24gKHRleHQpIHtcbiAgICByZXR1cm4gIXN0YXJ0c1dpdGgodGV4dCwgXCI8dzpoZWFkZXJSZWZlcmVuY2VcIikgJiYgIXN0YXJ0c1dpdGgodGV4dCwgXCI8dzpmb290ZXJSZWZlcmVuY2VcIik7XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFzUGFnZUJyZWFrKGNodW5rKSB7XG4gIHJldHVybiBjaHVuay5zb21lKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgcmV0dXJuIHBhcnQudGFnID09PSBcInc6YnJcIiAmJiBwYXJ0LnZhbHVlLmluZGV4T2YoJ3c6dHlwZT1cInBhZ2VcIicpICE9PSAtMTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoYXNJbWFnZShjaHVuaykge1xuICByZXR1cm4gY2h1bmsuc29tZShmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgdGFnID0gX3JlZjIudGFnO1xuICAgIHJldHVybiB0YWcgPT09IFwidzpkcmF3aW5nXCI7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2VjdFByKGNodW5rcykge1xuICB2YXIgY29sbGVjdFNlY3RQciA9IGZhbHNlO1xuICB2YXIgc2VjdFBycyA9IFtdO1xuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBjaHVua3MubGVuZ3RoOyBfaTQrKykge1xuICAgIHZhciBwYXJ0ID0gY2h1bmtzW19pNF07XG4gICAgaWYgKGlzVGFnU3RhcnQoXCJ3OnNlY3RQclwiLCBwYXJ0KSkge1xuICAgICAgc2VjdFBycy5wdXNoKFtdKTtcbiAgICAgIGNvbGxlY3RTZWN0UHIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29sbGVjdFNlY3RQcikge1xuICAgICAgc2VjdFByc1tzZWN0UHJzLmxlbmd0aCAtIDFdLnB1c2gocGFydCk7XG4gICAgfVxuICAgIGlmIChpc1RhZ0VuZChcInc6c2VjdFByXCIsIHBhcnQpKSB7XG4gICAgICBjb2xsZWN0U2VjdFByID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWN0UHJzO1xufVxuZnVuY3Rpb24gZ2V0U2VjdFBySGVhZGVyRm9vdGVyQ2hhbmdlQ291bnQoY2h1bmtzKSB7XG4gIHZhciBjb2xsZWN0U2VjdFByID0gZmFsc2U7XG4gIHZhciBzZWN0UHJDb3VudCA9IDA7XG4gIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGNodW5rcy5sZW5ndGg7IF9pNisrKSB7XG4gICAgdmFyIHBhcnQgPSBjaHVua3NbX2k2XTtcbiAgICBpZiAoaXNUYWdTdGFydChcInc6c2VjdFByXCIsIHBhcnQpKSB7XG4gICAgICBjb2xsZWN0U2VjdFByID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNvbGxlY3RTZWN0UHIpIHtcbiAgICAgIGlmIChwYXJ0LnRhZyA9PT0gXCJ3OmhlYWRlclJlZmVyZW5jZVwiIHx8IHBhcnQudGFnID09PSBcInc6Zm9vdGVyUmVmZXJlbmNlXCIpIHtcbiAgICAgICAgc2VjdFByQ291bnQrKztcbiAgICAgICAgY29sbGVjdFNlY3RQciA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNUYWdFbmQoXCJ3OnNlY3RQclwiLCBwYXJ0KSkge1xuICAgICAgY29sbGVjdFNlY3RQciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VjdFByQ291bnQ7XG59XG5mdW5jdGlvbiBnZXRMYXN0U2VjdFByKHBhcnNlZCkge1xuICB2YXIgc2VjdFByID0gW107XG4gIHZhciBpblNlY3RQciA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gcGFyc2VkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJzZWRbaV07XG4gICAgaWYgKGlzVGFnRW5kKFwidzpzZWN0UHJcIiwgcGFydCkpIHtcbiAgICAgIGluU2VjdFByID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzVGFnU3RhcnQoXCJ3OnNlY3RQclwiLCBwYXJ0KSkge1xuICAgICAgc2VjdFByLnVuc2hpZnQocGFydC52YWx1ZSk7XG4gICAgICBpblNlY3RQciA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaW5TZWN0UHIpIHtcbiAgICAgIHNlY3RQci51bnNoaWZ0KHBhcnQudmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaXNQYXJhZ3JhcGhTdGFydChwYXJ0KSkge1xuICAgICAgaWYgKHNlY3RQci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBzZWN0UHIuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbnZhciBMb29wTW9kdWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTG9vcE1vZHVsZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTG9vcE1vZHVsZSk7XG4gICAgdGhpcy5uYW1lID0gXCJMb29wTW9kdWxlXCI7XG4gICAgdGhpcy5pblhmcm0gPSBmYWxzZTtcbiAgICB0aGlzLnRvdGFsU2VjdFByID0gMDtcbiAgICB0aGlzLnByZWZpeCA9IHtcbiAgICAgIHN0YXJ0OiBcIiNcIixcbiAgICAgIGVuZDogXCIvXCIsXG4gICAgICBkYXNoOiAvXi0oW15cXHNdKylcXHMoLispLyxcbiAgICAgIGludmVydGVkOiBcIl5cIlxuICAgIH07XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhMb29wTW9kdWxlLCBbe1xuICAgIGtleTogXCJvcHRpb25zVHJhbnNmb3JtZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW9uc1RyYW5zZm9ybWVyKG9wdHMsIGRvY3h0ZW1wbGF0ZXIpIHtcbiAgICAgIHRoaXMuZG9jeHRlbXBsYXRlciA9IGRvY3h0ZW1wbGF0ZXI7XG4gICAgICByZXR1cm4gb3B0cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlcGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyc2UocGFyc2VkLCBfcmVmMykge1xuICAgICAgdmFyIGNvbnRlbnRUeXBlID0gX3JlZjMuY29udGVudFR5cGU7XG4gICAgICBpZiAoZmlsZXR5cGVzLm1haW4uaW5kZXhPZihjb250ZW50VHlwZSkgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuc2VjdHMgPSBnZXRTZWN0UHIocGFyc2VkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hlcnMoKSB7XG4gICAgICB2YXIgbW9kdWxlID0gbW9kdWxlTmFtZTtcbiAgICAgIHJldHVybiBbW3RoaXMucHJlZml4LnN0YXJ0LCBtb2R1bGUsIHtcbiAgICAgICAgZXhwYW5kVG86IFwiYXV0b1wiLFxuICAgICAgICBsb2NhdGlvbjogXCJzdGFydFwiLFxuICAgICAgICBpbnZlcnRlZDogZmFsc2VcbiAgICAgIH1dLCBbdGhpcy5wcmVmaXguaW52ZXJ0ZWQsIG1vZHVsZSwge1xuICAgICAgICBleHBhbmRUbzogXCJhdXRvXCIsXG4gICAgICAgIGxvY2F0aW9uOiBcInN0YXJ0XCIsXG4gICAgICAgIGludmVydGVkOiB0cnVlXG4gICAgICB9XSwgW3RoaXMucHJlZml4LmVuZCwgbW9kdWxlLCB7XG4gICAgICAgIGxvY2F0aW9uOiBcImVuZFwiXG4gICAgICB9XSwgW3RoaXMucHJlZml4LmRhc2gsIG1vZHVsZSwgZnVuY3Rpb24gKF9yZWY0KSB7XG4gICAgICAgIHZhciBfcmVmNSA9IF9zbGljZWRUb0FycmF5KF9yZWY0LCAzKSxcbiAgICAgICAgICBleHBhbmRUbyA9IF9yZWY1WzFdLFxuICAgICAgICAgIHZhbHVlID0gX3JlZjVbMl07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbG9jYXRpb246IFwic3RhcnRcIixcbiAgICAgICAgICBpbnZlcnRlZDogZmFsc2UsXG4gICAgICAgICAgZXhwYW5kVG86IGV4cGFuZFRvLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfV1dO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmFpdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJhaXRzKHRyYWl0TmFtZSwgcGFyc2VkKSB7XG4gICAgICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSBnZXRUcmFpdHMgc2hvdWxkIGRpc2FwcGVhciBpbiB2NFxuICAgICAgaWYgKHRyYWl0TmFtZSAhPT0gXCJleHBhbmRQYWlyXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxuXG4gICAgICByZXR1cm4gcGFyc2VkLnJlZHVjZShmdW5jdGlvbiAodGFncywgcGFydCwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChpc01vZHVsZShwYXJ0LCBtb2R1bGVOYW1lKSAmJiBwYXJ0LnN1YnBhcnNlZCA9PSBudWxsKSB7XG4gICAgICAgICAgdGFncy5wdXNoKHtcbiAgICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWdzO1xuICAgICAgfSwgW10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3N0cGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdHBhcnNlKHBhcnNlZCwgX3JlZjYpIHtcbiAgICAgIHZhciBiYXNlUGFydCA9IF9yZWY2LmJhc2VQYXJ0O1xuICAgICAgaWYgKGJhc2VQYXJ0ICYmIHRoaXMuZG9jeHRlbXBsYXRlci5maWxlVHlwZSA9PT0gXCJkb2N4XCIgJiYgcGFyc2VkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYmFzZVBhcnQuc2VjdFByQ291bnQgPSBnZXRTZWN0UHJIZWFkZXJGb290ZXJDaGFuZ2VDb3VudChwYXJzZWQpO1xuICAgICAgICB0aGlzLnRvdGFsU2VjdFByICs9IGJhc2VQYXJ0LnNlY3RQckNvdW50O1xuICAgICAgICB2YXIgc2VjdHMgPSB0aGlzLnNlY3RzO1xuICAgICAgICBzZWN0cy5zb21lKGZ1bmN0aW9uIChzZWN0LCBpbmRleCkge1xuICAgICAgICAgIGlmIChiYXNlUGFydC5sSW5kZXggPCBzZWN0WzBdLmxJbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ICsgMSA8IHNlY3RzLmxlbmd0aCAmJiBpc0NvbnRpbnVvdXMoc2VjdHNbaW5kZXggKyAxXSkpIHtcbiAgICAgICAgICAgICAgYmFzZVBhcnQuYWRkQ29udGludW91c1R5cGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJzZWRbMF0ubEluZGV4IDwgc2VjdFswXS5sSW5kZXggJiYgc2VjdFswXS5sSW5kZXggPCBiYXNlUGFydC5sSW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpc05leHRQYWdlKHNlY3RzW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgYmFzZVBhcnQuYWRkTmV4dFBhZ2UgPSB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBiYXNlUGFydC5sYXN0UGFyYWdyYXBTZWN0UHIgPSBnZXRMYXN0U2VjdFByKHBhcnNlZCk7XG4gICAgICB9XG4gICAgICBpZiAoIWJhc2VQYXJ0IHx8IGJhc2VQYXJ0LmV4cGFuZFRvICE9PSBcImF1dG9cIiB8fCBiYXNlUGFydC5tb2R1bGUgIT09IG1vZHVsZU5hbWUgfHwgIWlzRW5jbG9zZWRCeVBhcmFncmFwaHMocGFyc2VkKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfVxuICAgICAgYmFzZVBhcnQucGFyYWdyYXBoTG9vcCA9IHRydWU7XG4gICAgICB2YXIgbGV2ZWwgPSAwO1xuICAgICAgdmFyIGNodW5rcyA9IGNodW5rQnkocGFyc2VkLCBmdW5jdGlvbiAocCkge1xuICAgICAgICBpZiAoaXNQYXJhZ3JhcGhTdGFydChwKSkge1xuICAgICAgICAgIGxldmVsKys7XG4gICAgICAgICAgaWYgKGxldmVsID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJzdGFydFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQYXJhZ3JhcGhFbmQocCkpIHtcbiAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiZW5kXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSk7XG4gICAgICB2YXIgZmlyc3RDaHVuayA9IGNodW5rc1swXTtcbiAgICAgIHZhciBsYXN0Q2h1bmsgPSBsYXN0KGNodW5rcyk7XG4gICAgICB2YXIgZmlyc3RPZmZzZXQgPSBnZXRPZmZzZXQoZmlyc3RDaHVuayk7XG4gICAgICB2YXIgbGFzdE9mZnNldCA9IGdldE9mZnNldChsYXN0Q2h1bmspO1xuICAgICAgYmFzZVBhcnQuaGFzUGFnZUJyZWFrQmVnaW5uaW5nID0gaGFzUGFnZUJyZWFrKGZpcnN0Q2h1bmspO1xuICAgICAgYmFzZVBhcnQuaGFzUGFnZUJyZWFrID0gaGFzUGFnZUJyZWFrKGxhc3RDaHVuayk7XG4gICAgICBpZiAoaGFzSW1hZ2UoZmlyc3RDaHVuaykpIHtcbiAgICAgICAgZmlyc3RPZmZzZXQgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0ltYWdlKGxhc3RDaHVuaykpIHtcbiAgICAgICAgbGFzdE9mZnNldCA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VkLnNsaWNlKGZpcnN0T2Zmc2V0LCBwYXJzZWQubGVuZ3RoIC0gbGFzdE9mZnNldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZShwYXJ0LCBvcHRpb25zKSB7XG4gICAgICBpZiAoIWlzTW9kdWxlKHBhcnQsIG1vZHVsZU5hbWUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHNtID0gb3B0aW9ucy5zY29wZU1hbmFnZXI7XG4gICAgICB2YXIgcHJvbWlzZWRWYWx1ZSA9IHNtLmdldFZhbHVlQXN5bmMocGFydC52YWx1ZSwge1xuICAgICAgICBwYXJ0OiBwYXJ0XG4gICAgICB9KTtcbiAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgZnVuY3Rpb24gbG9vcE92ZXIoc2NvcGUsIGksIGxlbmd0aCkge1xuICAgICAgICB2YXIgc2NvcGVNYW5hZ2VyID0gc20uY3JlYXRlU3ViU2NvcGVNYW5hZ2VyKHNjb3BlLCBwYXJ0LnZhbHVlLCBpLCBwYXJ0LCBsZW5ndGgpO1xuICAgICAgICBwcm9taXNlcy5wdXNoKG9wdGlvbnMucmVzb2x2ZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIGNvbXBpbGVkOiBwYXJ0LnN1YnBhcnNlZCxcbiAgICAgICAgICB0YWdzOiB7fSxcbiAgICAgICAgICBzY29wZU1hbmFnZXI6IHNjb3BlTWFuYWdlclxuICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgICAgdmFyIGVycm9yTGlzdCA9IFtdO1xuICAgICAgcmV0dXJuIHByb21pc2VkVmFsdWUudGhlbihmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgUHJvbWlzZS5hbGwodmFsdWVzKS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgICBzbS5sb29wT3ZlclZhbHVlKHZhbHVlcywgbG9vcE92ZXIsIHBhcnQuaW52ZXJ0ZWQpO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgcmV0dXJuIHIubWFwKGZ1bmN0aW9uIChfcmVmNykge1xuICAgICAgICAgICAgICB2YXIgcmVzb2x2ZWQgPSBfcmVmNy5yZXNvbHZlZCxcbiAgICAgICAgICAgICAgICBlcnJvcnMgPSBfcmVmNy5lcnJvcnM7XG4gICAgICAgICAgICAgIHB1c2hBcnJheShlcnJvckxpc3QsIGVycm9ycyk7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3JMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3JMaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHBhcnQsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChwYXJ0LnRhZyA9PT0gXCJwOnhmcm1cIikge1xuICAgICAgICB0aGlzLmluWGZybSA9IHBhcnQucG9zaXRpb24gPT09IFwic3RhcnRcIjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0LnRhZyA9PT0gXCJhOmV4dFwiICYmIHRoaXMuaW5YZnJtKSB7XG4gICAgICAgIHRoaXMubGFzdEV4dCA9IHBhcnQ7XG4gICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgfVxuICAgICAgaWYgKCFpc01vZHVsZShwYXJ0LCBtb2R1bGVOYW1lKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciB0b3RhbFZhbHVlID0gW107XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgaGVpZ2h0T2Zmc2V0ID0gMDtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBmaXJzdFRhZyA9IHBhcnQuc3VicGFyc2VkWzBdO1xuICAgICAgdmFyIHRhZ0hlaWdodCA9IDA7XG4gICAgICBpZiAoKGZpcnN0VGFnID09PSBudWxsIHx8IGZpcnN0VGFnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaXJzdFRhZy50YWcpID09PSBcImE6dHJcIikge1xuICAgICAgICB0YWdIZWlnaHQgPSArZ2V0U2luZ2xlQXR0cmlidXRlKGZpcnN0VGFnLnZhbHVlLCBcImhcIik7XG4gICAgICB9XG4gICAgICBoZWlnaHRPZmZzZXQgLT0gdGFnSGVpZ2h0O1xuICAgICAgdmFyIGExNlJvd0lkT2Zmc2V0ID0gMDtcbiAgICAgIHZhciBpbnNpZGVQYXJhZ3JhcGhMb29wID0gaXNJbnNpZGVQYXJhZ3JhcGhMb29wKHBhcnQpO1xuICAgICAgZnVuY3Rpb24gbG9vcE92ZXIoc2NvcGUsIGksIGxlbmd0aCkge1xuICAgICAgICBoZWlnaHRPZmZzZXQgKz0gdGFnSGVpZ2h0O1xuICAgICAgICB2YXIgc2NvcGVNYW5hZ2VyID0gb3B0aW9ucy5zY29wZU1hbmFnZXIuY3JlYXRlU3ViU2NvcGVNYW5hZ2VyKHNjb3BlLCBwYXJ0LnZhbHVlLCBpLCBwYXJ0LCBsZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBfaTggPSAwLCBfcGFydCRzdWJwYXJzZWQyID0gcGFydC5zdWJwYXJzZWQ7IF9pOCA8IF9wYXJ0JHN1YnBhcnNlZDIubGVuZ3RoOyBfaTgrKykge1xuICAgICAgICAgIHZhciBwcCA9IF9wYXJ0JHN1YnBhcnNlZDJbX2k4XTtcbiAgICAgICAgICBpZiAoaXNUYWdTdGFydChcImExNjpyb3dJZFwiLCBwcCkpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSArZ2V0U2luZ2xlQXR0cmlidXRlKHBwLnZhbHVlLCBcInZhbFwiKSArIGExNlJvd0lkT2Zmc2V0O1xuICAgICAgICAgICAgYTE2Um93SWRPZmZzZXQgPSAxO1xuICAgICAgICAgICAgcHAudmFsdWUgPSBzZXRTaW5nbGVBdHRyaWJ1dGUocHAudmFsdWUsIFwidmFsXCIsIHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzdWJSZW5kZXJlZCA9IG9wdGlvbnMucmVuZGVyKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgY29tcGlsZWQ6IHBhcnQuc3VicGFyc2VkLFxuICAgICAgICAgIHRhZ3M6IHt9LFxuICAgICAgICAgIHNjb3BlTWFuYWdlcjogc2NvcGVNYW5hZ2VyXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKHBhcnQuaGFzUGFnZUJyZWFrICYmIGkgPT09IGxlbmd0aCAtIDEgJiYgaW5zaWRlUGFyYWdyYXBoTG9vcCkge1xuICAgICAgICAgIGFkZFBhZ2VCcmVha0F0RW5kKHN1YlJlbmRlcmVkKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNOb3RGaXJzdCA9IHNjb3BlTWFuYWdlci5zY29wZVBhdGhJdGVtLnNvbWUoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gaSAhPT0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc05vdEZpcnN0KSB7XG4gICAgICAgICAgaWYgKHBhcnQuc2VjdFByQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHN1YlJlbmRlcmVkLnBhcnRzID0gZHJvcEhlYWRlckZvb3RlclJlZnMoc3ViUmVuZGVyZWQucGFydHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydC5hZGRDb250aW51b3VzVHlwZSkge1xuICAgICAgICAgICAgc3ViUmVuZGVyZWQucGFydHMgPSBhZGRDb250aW51b3VzVHlwZShzdWJSZW5kZXJlZC5wYXJ0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBhcnQuYWRkTmV4dFBhZ2UpIHtcbiAgICAgICAgICBzdWJSZW5kZXJlZC5wYXJ0cyA9IGFkZFNlY3Rpb25CZWZvcmUoc3ViUmVuZGVyZWQucGFydHMsIHNlbGYuc2VjdHNbcGFydC5hZGROZXh0UGFnZS5pbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LmFkZE5leHRQYWdlKSB7XG4gICAgICAgICAgYWRkUGFnZUJyZWFrQXRFbmQoc3ViUmVuZGVyZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0Lmhhc1BhZ2VCcmVha0JlZ2lubmluZyAmJiBpbnNpZGVQYXJhZ3JhcGhMb29wKSB7XG4gICAgICAgICAgYWRkUGFnZUJyZWFrQXRCZWdpbm5pbmcoc3ViUmVuZGVyZWQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pMTAgPSAwLCBfc3ViUmVuZGVyZWQkcGFydHMyID0gc3ViUmVuZGVyZWQucGFydHM7IF9pMTAgPCBfc3ViUmVuZGVyZWQkcGFydHMyLmxlbmd0aDsgX2kxMCsrKSB7XG4gICAgICAgICAgdmFyIF92YWwgPSBfc3ViUmVuZGVyZWQkcGFydHMyW19pMTBdO1xuICAgICAgICAgIHRvdGFsVmFsdWUucHVzaChfdmFsKTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoQXJyYXkoZXJyb3JzLCBzdWJSZW5kZXJlZC5lcnJvcnMpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbnMuc2NvcGVNYW5hZ2VyLmxvb3BPdmVyKHBhcnQudmFsdWUsIGxvb3BPdmVyLCBwYXJ0LmludmVydGVkLCB7XG4gICAgICAgIHBhcnQ6IHBhcnRcbiAgICAgIH0pO1xuICAgICAgLy8gaWYgdGhlIGxvb3AgaXMgc2hvd2luZyBlbXB0eSBjb250ZW50XG4gICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICBpZiAocGFydC5sYXN0UGFyYWdyYXBTZWN0UHIpIHtcbiAgICAgICAgICBpZiAocGFydC5wYXJhZ3JhcGhMb29wKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWx1ZTogXCI8dzpwPjx3OnBQcj5cIi5jb25jYXQocGFydC5sYXN0UGFyYWdyYXBTZWN0UHIsIFwiPC93OnBQcj48L3c6cD5cIilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogXCI8L3c6dD48L3c6cj48L3c6cD48dzpwPjx3OnBQcj5cIi5jb25jYXQocGFydC5sYXN0UGFyYWdyYXBTZWN0UHIsIFwiPC93OnBQcj48dzpyPjx3OnQ+XCIpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBnZXRQYWdlQnJlYWtJZkFwcGxpZXMocGFydCkgfHwgXCJcIixcbiAgICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodE9mZnNldCAhPT0gMCkge1xuICAgICAgICB2YXIgY3kgPSArZ2V0U2luZ2xlQXR0cmlidXRlKHRoaXMubGFzdEV4dC52YWx1ZSwgXCJjeVwiKTtcbiAgICAgICAgLypcbiAgICAgICAgICogV2UgZG8gZWRpdCB0aGUgdmFsdWUgb2YgYSBwcmV2aW91cyByZXN1bHQgaGVyZVxuICAgICAgICAgKiAjZWRpdC12YWx1ZS1iYWNrd2FyZHNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdEV4dC52YWx1ZSA9IHNldFNpbmdsZUF0dHJpYnV0ZSh0aGlzLmxhc3RFeHQudmFsdWUsIFwiY3lcIiwgY3kgKyBoZWlnaHRPZmZzZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IG9wdGlvbnMuam9pblVuY29ycnVwdCh0b3RhbFZhbHVlLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIGJhc2VQYXJ0OiBwYXJ0XG4gICAgICAgIH0pKSxcbiAgICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG59KCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHdyYXBwZXIobmV3IExvb3BNb2R1bGUoKSk7XG59OyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJvd25LZXlzIiwiZSIsInIiLCJ0IiwiT2JqZWN0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfc2xpY2VkVG9BcnJheSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJUeXBlRXJyb3IiLCJhIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwibiIsImwiLCJpIiwidSIsImYiLCJuZXh0IiwiZG9uZSIsImlzQXJyYXkiLCJfY2xhc3NDYWxsQ2hlY2siLCJfZGVmaW5lUHJvcGVydGllcyIsImtleSIsIl9jcmVhdGVDbGFzcyIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiX3JlcXVpcmUiLCJyZXF1aXJlIiwiY2h1bmtCeSIsImxhc3QiLCJpc1BhcmFncmFwaFN0YXJ0IiwiaXNNb2R1bGUiLCJwdXNoQXJyYXkiLCJpc1BhcmFncmFwaEVuZCIsImlzQ29udGVudCIsInN0YXJ0c1dpdGgiLCJpc1RhZ0VuZCIsImlzVGFnU3RhcnQiLCJnZXRTaW5nbGVBdHRyaWJ1dGUiLCJzZXRTaW5nbGVBdHRyaWJ1dGUiLCJmaWxldHlwZXMiLCJ3cmFwcGVyIiwibW9kdWxlTmFtZSIsImhhc0NvbnRlbnQiLCJwYXJ0cyIsInNvbWUiLCJwYXJ0IiwiZ2V0Rmlyc3RNZWFuaW5nRnVsUGFydCIsInBhcnNlZCIsIl9pMiIsInR5cGUiLCJpc0luc2lkZVBhcmFncmFwaExvb3AiLCJmaXJzdE1lYW5pbmdmdWxQYXJ0Iiwic3VicGFyc2VkIiwidGFnIiwiZ2V0UGFnZUJyZWFrSWZBcHBsaWVzIiwiaGFzUGFnZUJyZWFrIiwiaXNFbmNsb3NlZEJ5UGFyYWdyYXBocyIsImdldE9mZnNldCIsImNodW5rIiwiYWRkUGFnZUJyZWFrQXRFbmQiLCJzdWJSZW5kZXJlZCIsImoiLCJzcGxpY2UiLCJhZGRQYWdlQnJlYWtBdEJlZ2lubmluZyIsInVuc2hpZnQiLCJpc0NvbnRpbnVvdXMiLCJpbmRleE9mIiwiaXNOZXh0UGFnZSIsImFkZFNlY3Rpb25CZWZvcmUiLCJzZWN0IiwiY29uY2F0IiwibWFwIiwiX3JlZiIsImpvaW4iLCJhZGRDb250aW51b3VzVHlwZSIsInN0b3AiLCJpblNlY3RQciIsInJlZHVjZSIsInJlc3VsdCIsImRyb3BIZWFkZXJGb290ZXJSZWZzIiwidGV4dCIsImhhc0ltYWdlIiwiX3JlZjIiLCJnZXRTZWN0UHIiLCJjaHVua3MiLCJjb2xsZWN0U2VjdFByIiwic2VjdFBycyIsIl9pNCIsImdldFNlY3RQckhlYWRlckZvb3RlckNoYW5nZUNvdW50Iiwic2VjdFByQ291bnQiLCJfaTYiLCJnZXRMYXN0U2VjdFByIiwic2VjdFByIiwiTG9vcE1vZHVsZSIsImluWGZybSIsInRvdGFsU2VjdFByIiwicHJlZml4Iiwic3RhcnQiLCJlbmQiLCJkYXNoIiwiaW52ZXJ0ZWQiLCJvcHRpb25zVHJhbnNmb3JtZXIiLCJvcHRzIiwiZG9jeHRlbXBsYXRlciIsInByZXBhcnNlIiwiX3JlZjMiLCJjb250ZW50VHlwZSIsIm1haW4iLCJzZWN0cyIsIm1hdGNoZXJzIiwibW9kdWxlIiwiZXhwYW5kVG8iLCJsb2NhdGlvbiIsIl9yZWY0IiwiX3JlZjUiLCJnZXRUcmFpdHMiLCJ0cmFpdE5hbWUiLCJ0YWdzIiwib2Zmc2V0IiwicG9zdHBhcnNlIiwiX3JlZjYiLCJiYXNlUGFydCIsImZpbGVUeXBlIiwiaW5kZXgiLCJsSW5kZXgiLCJhZGROZXh0UGFnZSIsImxhc3RQYXJhZ3JhcFNlY3RQciIsInBhcmFncmFwaExvb3AiLCJsZXZlbCIsInAiLCJmaXJzdENodW5rIiwibGFzdENodW5rIiwiZmlyc3RPZmZzZXQiLCJsYXN0T2Zmc2V0IiwiaGFzUGFnZUJyZWFrQmVnaW5uaW5nIiwicmVzb2x2ZSIsIm9wdGlvbnMiLCJzbSIsInNjb3BlTWFuYWdlciIsInByb21pc2VkVmFsdWUiLCJnZXRWYWx1ZUFzeW5jIiwicHJvbWlzZXMiLCJsb29wT3ZlciIsInNjb3BlIiwiY3JlYXRlU3ViU2NvcGVNYW5hZ2VyIiwiY29tcGlsZWQiLCJlcnJvckxpc3QiLCJ0aGVuIiwidmFsdWVzIiwiUHJvbWlzZSIsImFsbCIsImxvb3BPdmVyVmFsdWUiLCJfcmVmNyIsInJlc29sdmVkIiwiZXJyb3JzIiwicmVuZGVyIiwicG9zaXRpb24iLCJsYXN0RXh0IiwidG90YWxWYWx1ZSIsImhlaWdodE9mZnNldCIsInNlbGYiLCJmaXJzdFRhZyIsInRhZ0hlaWdodCIsImExNlJvd0lkT2Zmc2V0IiwiaW5zaWRlUGFyYWdyYXBoTG9vcCIsIl9pOCIsIl9wYXJ0JHN1YnBhcnNlZDIiLCJwcCIsInZhbCIsImlzTm90Rmlyc3QiLCJzY29wZVBhdGhJdGVtIiwiX2kxMCIsIl9zdWJSZW5kZXJlZCRwYXJ0czIiLCJfdmFsIiwiY3kiLCJqb2luVW5jb3JydXB0IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/modules/loop.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/modules/rawxml.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/rawxml.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n    for(var t = 0; t < r.length; t++){\n        var o = r[t];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n}\nfunction _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n        writable: !1\n    }), e;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar traits = __webpack_require__(/*! ../traits.js */ \"(rsc)/./node_modules/docxtemplater/js/traits.js\");\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"), isContent = _require.isContent;\nvar _require2 = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\"), throwRawTagShouldBeOnlyTextInParagraph = _require2.throwRawTagShouldBeOnlyTextInParagraph, getInvalidRawXMLValueException = _require2.getInvalidRawXMLValueException;\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(rsc)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar moduleName = \"rawxml\";\nfunction getInner(_ref) {\n    var part = _ref.part, left = _ref.left, right = _ref.right, postparsed = _ref.postparsed, index = _ref.index;\n    var paragraphParts = postparsed.slice(left + 1, right);\n    for(var i = 0, len = paragraphParts.length; i < len; i++){\n        if (i === index - left - 1) {\n            continue;\n        }\n        var p = paragraphParts[i];\n        if (isContent(p)) {\n            throwRawTagShouldBeOnlyTextInParagraph({\n                paragraphParts: paragraphParts,\n                part: part\n            });\n        }\n    }\n    return part;\n}\nvar RawXmlModule = /*#__PURE__*/ function() {\n    function RawXmlModule() {\n        _classCallCheck(this, RawXmlModule);\n        this.name = \"RawXmlModule\";\n        this.prefix = \"@\";\n    }\n    return _createClass(RawXmlModule, [\n        {\n            key: \"optionsTransformer\",\n            value: function optionsTransformer(options, docxtemplater) {\n                this.fileTypeConfig = docxtemplater.fileTypeConfig;\n                return options;\n            }\n        },\n        {\n            key: \"matchers\",\n            value: function matchers() {\n                return [\n                    [\n                        this.prefix,\n                        moduleName\n                    ]\n                ];\n            }\n        },\n        {\n            key: \"postparse\",\n            value: function postparse(postparsed) {\n                return traits.expandToOne(postparsed, {\n                    moduleName: moduleName,\n                    getInner: getInner,\n                    expandTo: this.fileTypeConfig.tagRawXml,\n                    error: {\n                        message: \"Raw tag not in paragraph\",\n                        id: \"raw_tag_outerxml_invalid\",\n                        explanation: function explanation(part) {\n                            return 'The tag \"'.concat(part.value, '\" is not inside a paragraph, putting raw tags inside an inline loop is disallowed.');\n                        }\n                    }\n                });\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(part, options) {\n                if (part.module !== moduleName) {\n                    return null;\n                }\n                var value;\n                var errors = [];\n                try {\n                    value = options.scopeManager.getValue(part.value, {\n                        part: part\n                    });\n                    value !== null && value !== void 0 ? value : value = options.nullGetter(part);\n                } catch (e) {\n                    errors.push(e);\n                    return {\n                        errors: errors\n                    };\n                }\n                value = value ? value : \"\";\n                if (typeof value === \"string\") {\n                    return {\n                        value: value\n                    };\n                }\n                return {\n                    errors: [\n                        getInvalidRawXMLValueException({\n                            tag: part.value,\n                            value: value,\n                            offset: part.offset\n                        })\n                    ]\n                };\n            }\n        }\n    ]);\n}();\nmodule.exports = function() {\n    return wrapper(new RawXmlModule());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL3Jhd3htbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSyxnQkFBZ0JDLENBQUMsRUFBRUMsQ0FBQztJQUFJLElBQUksQ0FBRUQsQ0FBQUEsYUFBYUMsQ0FBQUEsR0FBSSxNQUFNLElBQUlDLFVBQVU7QUFBc0M7QUFDbEgsU0FBU0Msa0JBQWtCQyxDQUFDLEVBQUVDLENBQUM7SUFBSSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUQsRUFBRUUsTUFBTSxFQUFFRCxJQUFLO1FBQUUsSUFBSVosSUFBSVcsQ0FBQyxDQUFDQyxFQUFFO1FBQUVaLEVBQUVjLFVBQVUsR0FBR2QsRUFBRWMsVUFBVSxJQUFJLENBQUMsR0FBR2QsRUFBRWUsWUFBWSxHQUFHLENBQUMsR0FBRyxXQUFXZixLQUFNQSxDQUFBQSxFQUFFZ0IsUUFBUSxHQUFHLENBQUMsSUFBSUMsT0FBT0MsY0FBYyxDQUFDUixHQUFHUyxlQUFlbkIsRUFBRW9CLEdBQUcsR0FBR3BCO0lBQUk7QUFBRTtBQUN2TyxTQUFTcUIsYUFBYVgsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUM7SUFBSSxPQUFPRCxLQUFLRixrQkFBa0JDLEVBQUVOLFNBQVMsRUFBRU8sSUFBSUMsS0FBS0gsa0JBQWtCQyxHQUFHRSxJQUFJSyxPQUFPQyxjQUFjLENBQUNSLEdBQUcsYUFBYTtRQUFFTSxVQUFVLENBQUM7SUFBRSxJQUFJTjtBQUFHO0FBQzFLLFNBQVNTLGVBQWVQLENBQUM7SUFBSSxJQUFJVSxJQUFJQyxhQUFhWCxHQUFHO0lBQVcsT0FBTyxZQUFZYixRQUFRdUIsS0FBS0EsSUFBSUEsSUFBSTtBQUFJO0FBQzVHLFNBQVNDLGFBQWFYLENBQUMsRUFBRUQsQ0FBQztJQUFJLElBQUksWUFBWVosUUFBUWEsTUFBTSxDQUFDQSxHQUFHLE9BQU9BO0lBQUcsSUFBSUYsSUFBSUUsQ0FBQyxDQUFDWCxPQUFPdUIsV0FBVyxDQUFDO0lBQUUsSUFBSSxLQUFLLE1BQU1kLEdBQUc7UUFBRSxJQUFJWSxJQUFJWixFQUFFZSxJQUFJLENBQUNiLEdBQUdELEtBQUs7UUFBWSxJQUFJLFlBQVlaLFFBQVF1QixJQUFJLE9BQU9BO1FBQUcsTUFBTSxJQUFJZCxVQUFVO0lBQWlEO0lBQUUsT0FBTyxDQUFDLGFBQWFHLElBQUllLFNBQVNDLE1BQUssRUFBR2Y7QUFBSTtBQUMzVCxJQUFJZ0IsU0FBU0MsbUJBQU9BLENBQUMscUVBQWM7QUFDbkMsSUFBSUMsV0FBV0QsbUJBQU9BLENBQUMsMkVBQWlCLEdBQ3RDRSxZQUFZRCxTQUFTQyxTQUFTO0FBQ2hDLElBQUlDLFlBQVlILG1CQUFPQSxDQUFDLHFFQUFjLEdBQ3BDSSx5Q0FBeUNELFVBQVVDLHNDQUFzQyxFQUN6RkMsaUNBQWlDRixVQUFVRSw4QkFBOEI7QUFDM0UsSUFBSUMsVUFBVU4sbUJBQU9BLENBQUMscUZBQXNCO0FBQzVDLElBQUlPLGFBQWE7QUFDakIsU0FBU0MsU0FBU0MsSUFBSTtJQUNwQixJQUFJQyxPQUFPRCxLQUFLQyxJQUFJLEVBQ2xCQyxPQUFPRixLQUFLRSxJQUFJLEVBQ2hCQyxRQUFRSCxLQUFLRyxLQUFLLEVBQ2xCQyxhQUFhSixLQUFLSSxVQUFVLEVBQzVCQyxRQUFRTCxLQUFLSyxLQUFLO0lBQ3BCLElBQUlDLGlCQUFpQkYsV0FBV0csS0FBSyxDQUFDTCxPQUFPLEdBQUdDO0lBQ2hELElBQUssSUFBSW5CLElBQUksR0FBR3dCLE1BQU1GLGVBQWUvQixNQUFNLEVBQUVTLElBQUl3QixLQUFLeEIsSUFBSztRQUN6RCxJQUFJQSxNQUFNcUIsUUFBUUgsT0FBTyxHQUFHO1lBQzFCO1FBQ0Y7UUFDQSxJQUFJTyxJQUFJSCxjQUFjLENBQUN0QixFQUFFO1FBQ3pCLElBQUlTLFVBQVVnQixJQUFJO1lBQ2hCZCx1Q0FBdUM7Z0JBQ3JDVyxnQkFBZ0JBO2dCQUNoQkwsTUFBTUE7WUFDUjtRQUNGO0lBQ0Y7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsSUFBSVMsZUFBZSxXQUFXLEdBQUU7SUFDOUIsU0FBU0E7UUFDUDNDLGdCQUFnQixJQUFJLEVBQUUyQztRQUN0QixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsTUFBTSxHQUFHO0lBQ2hCO0lBQ0EsT0FBTzdCLGFBQWEyQixjQUFjO1FBQUM7WUFDakM1QixLQUFLO1lBQ0wrQixPQUFPLFNBQVNDLG1CQUFtQkMsT0FBTyxFQUFFQyxhQUFhO2dCQUN2RCxJQUFJLENBQUNDLGNBQWMsR0FBR0QsY0FBY0MsY0FBYztnQkFDbEQsT0FBT0Y7WUFDVDtRQUNGO1FBQUc7WUFDRGpDLEtBQUs7WUFDTCtCLE9BQU8sU0FBU0s7Z0JBQ2QsT0FBTztvQkFBQzt3QkFBQyxJQUFJLENBQUNOLE1BQU07d0JBQUVkO3FCQUFXO2lCQUFDO1lBQ3BDO1FBQ0Y7UUFBRztZQUNEaEIsS0FBSztZQUNMK0IsT0FBTyxTQUFTTSxVQUFVZixVQUFVO2dCQUNsQyxPQUFPZCxPQUFPOEIsV0FBVyxDQUFDaEIsWUFBWTtvQkFDcENOLFlBQVlBO29CQUNaQyxVQUFVQTtvQkFDVnNCLFVBQVUsSUFBSSxDQUFDSixjQUFjLENBQUNLLFNBQVM7b0JBQ3ZDQyxPQUFPO3dCQUNMQyxTQUFTO3dCQUNUQyxJQUFJO3dCQUNKQyxhQUFhLFNBQVNBLFlBQVl6QixJQUFJOzRCQUNwQyxPQUFPLFlBQWEwQixNQUFNLENBQUMxQixLQUFLWSxLQUFLLEVBQUU7d0JBQ3pDO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtRQUFHO1lBQ0QvQixLQUFLO1lBQ0wrQixPQUFPLFNBQVNlLE9BQU8zQixJQUFJLEVBQUVjLE9BQU87Z0JBQ2xDLElBQUlkLEtBQUs0QixNQUFNLEtBQUsvQixZQUFZO29CQUM5QixPQUFPO2dCQUNUO2dCQUNBLElBQUllO2dCQUNKLElBQUlpQixTQUFTLEVBQUU7Z0JBQ2YsSUFBSTtvQkFDRmpCLFFBQVFFLFFBQVFnQixZQUFZLENBQUNDLFFBQVEsQ0FBQy9CLEtBQUtZLEtBQUssRUFBRTt3QkFDaERaLE1BQU1BO29CQUNSO29CQUNBWSxVQUFVLFFBQVFBLFVBQVUsS0FBSyxJQUFJQSxRQUFRQSxRQUFRRSxRQUFRa0IsVUFBVSxDQUFDaEM7Z0JBQzFFLEVBQUUsT0FBTzdCLEdBQUc7b0JBQ1YwRCxPQUFPSSxJQUFJLENBQUM5RDtvQkFDWixPQUFPO3dCQUNMMEQsUUFBUUE7b0JBQ1Y7Z0JBQ0Y7Z0JBQ0FqQixRQUFRQSxRQUFRQSxRQUFRO2dCQUN4QixJQUFJLE9BQU9BLFVBQVUsVUFBVTtvQkFDN0IsT0FBTzt3QkFDTEEsT0FBT0E7b0JBQ1Q7Z0JBQ0Y7Z0JBQ0EsT0FBTztvQkFDTGlCLFFBQVE7d0JBQUNsQywrQkFBK0I7NEJBQ3RDdUMsS0FBS2xDLEtBQUtZLEtBQUs7NEJBQ2ZBLE9BQU9BOzRCQUNQdUIsUUFBUW5DLEtBQUttQyxNQUFNO3dCQUNyQjtxQkFBRztnQkFDTDtZQUNGO1FBQ0Y7S0FBRTtBQUNKO0FBQ0FQLE9BQU9RLE9BQU8sR0FBRztJQUNmLE9BQU94QyxRQUFRLElBQUlhO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlrZS1yZW50YWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL21vZHVsZXMvcmF3eG1sLmpzP2YxMmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciB0cmFpdHMgPSByZXF1aXJlKFwiLi4vdHJhaXRzLmpzXCIpO1xudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uL2RvYy11dGlscy5qc1wiKSxcbiAgaXNDb250ZW50ID0gX3JlcXVpcmUuaXNDb250ZW50O1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuLi9lcnJvcnMuanNcIiksXG4gIHRocm93UmF3VGFnU2hvdWxkQmVPbmx5VGV4dEluUGFyYWdyYXBoID0gX3JlcXVpcmUyLnRocm93UmF3VGFnU2hvdWxkQmVPbmx5VGV4dEluUGFyYWdyYXBoLFxuICBnZXRJbnZhbGlkUmF3WE1MVmFsdWVFeGNlcHRpb24gPSBfcmVxdWlyZTIuZ2V0SW52YWxpZFJhd1hNTFZhbHVlRXhjZXB0aW9uO1xudmFyIHdyYXBwZXIgPSByZXF1aXJlKFwiLi4vbW9kdWxlLXdyYXBwZXIuanNcIik7XG52YXIgbW9kdWxlTmFtZSA9IFwicmF3eG1sXCI7XG5mdW5jdGlvbiBnZXRJbm5lcihfcmVmKSB7XG4gIHZhciBwYXJ0ID0gX3JlZi5wYXJ0LFxuICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgcmlnaHQgPSBfcmVmLnJpZ2h0LFxuICAgIHBvc3RwYXJzZWQgPSBfcmVmLnBvc3RwYXJzZWQsXG4gICAgaW5kZXggPSBfcmVmLmluZGV4O1xuICB2YXIgcGFyYWdyYXBoUGFydHMgPSBwb3N0cGFyc2VkLnNsaWNlKGxlZnQgKyAxLCByaWdodCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJhZ3JhcGhQYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChpID09PSBpbmRleCAtIGxlZnQgLSAxKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHAgPSBwYXJhZ3JhcGhQYXJ0c1tpXTtcbiAgICBpZiAoaXNDb250ZW50KHApKSB7XG4gICAgICB0aHJvd1Jhd1RhZ1Nob3VsZEJlT25seVRleHRJblBhcmFncmFwaCh7XG4gICAgICAgIHBhcmFncmFwaFBhcnRzOiBwYXJhZ3JhcGhQYXJ0cyxcbiAgICAgICAgcGFydDogcGFydFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0O1xufVxudmFyIFJhd1htbE1vZHVsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJhd1htbE1vZHVsZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmF3WG1sTW9kdWxlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlJhd1htbE1vZHVsZVwiO1xuICAgIHRoaXMucHJlZml4ID0gXCJAXCI7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhSYXdYbWxNb2R1bGUsIFt7XG4gICAga2V5OiBcIm9wdGlvbnNUcmFuc2Zvcm1lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpb25zVHJhbnNmb3JtZXIob3B0aW9ucywgZG9jeHRlbXBsYXRlcikge1xuICAgICAgdGhpcy5maWxlVHlwZUNvbmZpZyA9IGRvY3h0ZW1wbGF0ZXIuZmlsZVR5cGVDb25maWc7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hlcnMoKSB7XG4gICAgICByZXR1cm4gW1t0aGlzLnByZWZpeCwgbW9kdWxlTmFtZV1dO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3N0cGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdHBhcnNlKHBvc3RwYXJzZWQpIHtcbiAgICAgIHJldHVybiB0cmFpdHMuZXhwYW5kVG9PbmUocG9zdHBhcnNlZCwge1xuICAgICAgICBtb2R1bGVOYW1lOiBtb2R1bGVOYW1lLFxuICAgICAgICBnZXRJbm5lcjogZ2V0SW5uZXIsXG4gICAgICAgIGV4cGFuZFRvOiB0aGlzLmZpbGVUeXBlQ29uZmlnLnRhZ1Jhd1htbCxcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICBtZXNzYWdlOiBcIlJhdyB0YWcgbm90IGluIHBhcmFncmFwaFwiLFxuICAgICAgICAgIGlkOiBcInJhd190YWdfb3V0ZXJ4bWxfaW52YWxpZFwiLFxuICAgICAgICAgIGV4cGxhbmF0aW9uOiBmdW5jdGlvbiBleHBsYW5hdGlvbihwYXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gXCJUaGUgdGFnIFxcXCJcIi5jb25jYXQocGFydC52YWx1ZSwgXCJcXFwiIGlzIG5vdCBpbnNpZGUgYSBwYXJhZ3JhcGgsIHB1dHRpbmcgcmF3IHRhZ3MgaW5zaWRlIGFuIGlubGluZSBsb29wIGlzIGRpc2FsbG93ZWQuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocGFydCwgb3B0aW9ucykge1xuICAgICAgaWYgKHBhcnQubW9kdWxlICE9PSBtb2R1bGVOYW1lKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlO1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWUgPSBvcHRpb25zLnNjb3BlTWFuYWdlci5nZXRWYWx1ZShwYXJ0LnZhbHVlLCB7XG4gICAgICAgICAgcGFydDogcGFydFxuICAgICAgICB9KTtcbiAgICAgICAgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDogdmFsdWUgPSBvcHRpb25zLm51bGxHZXR0ZXIocGFydCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlID8gdmFsdWUgOiBcIlwiO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3JzOiBbZ2V0SW52YWxpZFJhd1hNTFZhbHVlRXhjZXB0aW9uKHtcbiAgICAgICAgICB0YWc6IHBhcnQudmFsdWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIG9mZnNldDogcGFydC5vZmZzZXRcbiAgICAgICAgfSldXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xufSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB3cmFwcGVyKG5ldyBSYXdYbWxNb2R1bGUoKSk7XG59OyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJhIiwibiIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwiZSIsInIiLCJ0IiwibGVuZ3RoIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsImtleSIsIl9jcmVhdGVDbGFzcyIsImkiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsImNhbGwiLCJTdHJpbmciLCJOdW1iZXIiLCJ0cmFpdHMiLCJyZXF1aXJlIiwiX3JlcXVpcmUiLCJpc0NvbnRlbnQiLCJfcmVxdWlyZTIiLCJ0aHJvd1Jhd1RhZ1Nob3VsZEJlT25seVRleHRJblBhcmFncmFwaCIsImdldEludmFsaWRSYXdYTUxWYWx1ZUV4Y2VwdGlvbiIsIndyYXBwZXIiLCJtb2R1bGVOYW1lIiwiZ2V0SW5uZXIiLCJfcmVmIiwicGFydCIsImxlZnQiLCJyaWdodCIsInBvc3RwYXJzZWQiLCJpbmRleCIsInBhcmFncmFwaFBhcnRzIiwic2xpY2UiLCJsZW4iLCJwIiwiUmF3WG1sTW9kdWxlIiwibmFtZSIsInByZWZpeCIsInZhbHVlIiwib3B0aW9uc1RyYW5zZm9ybWVyIiwib3B0aW9ucyIsImRvY3h0ZW1wbGF0ZXIiLCJmaWxlVHlwZUNvbmZpZyIsIm1hdGNoZXJzIiwicG9zdHBhcnNlIiwiZXhwYW5kVG9PbmUiLCJleHBhbmRUbyIsInRhZ1Jhd1htbCIsImVycm9yIiwibWVzc2FnZSIsImlkIiwiZXhwbGFuYXRpb24iLCJjb25jYXQiLCJyZW5kZXIiLCJtb2R1bGUiLCJlcnJvcnMiLCJzY29wZU1hbmFnZXIiLCJnZXRWYWx1ZSIsIm51bGxHZXR0ZXIiLCJwdXNoIiwidGFnIiwib2Zmc2V0IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/modules/rawxml.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/modules/render.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/render.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n    for(var t = 0; t < r.length; t++){\n        var o = r[t];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n}\nfunction _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n        writable: !1\n    }), e;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(rsc)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar _require = __webpack_require__(/*! ../errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\"), getScopeCompilationError = _require.getScopeCompilationError, getCorruptCharactersException = _require.getCorruptCharactersException;\nvar _require2 = __webpack_require__(/*! ../doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"), utf8ToWord = _require2.utf8ToWord, hasCorruptCharacters = _require2.hasCorruptCharacters, removeCorruptCharacters = _require2.removeCorruptCharacters;\nvar _require3 = __webpack_require__(/*! ../content-types.js */ \"(rsc)/./node_modules/docxtemplater/js/content-types.js\"), settingsContentType = _require3.settingsContentType, coreContentType = _require3.coreContentType, appContentType = _require3.appContentType, customContentType = _require3.customContentType;\nvar NON_LINE_BREAKS_CONTENT_TYPE = [\n    settingsContentType,\n    coreContentType,\n    appContentType,\n    customContentType\n];\nvar ftprefix = {\n    docx: \"w\",\n    pptx: \"a\"\n};\nvar Render = /*#__PURE__*/ function() {\n    function Render() {\n        _classCallCheck(this, Render);\n        this.name = \"Render\";\n        this.recordRun = false;\n        this.recordedRun = [];\n    }\n    return _createClass(Render, [\n        {\n            key: \"optionsTransformer\",\n            value: function optionsTransformer(options, docxtemplater) {\n                this.docxtemplater = docxtemplater;\n                this.brTag = docxtemplater.fileType === \"docx\" ? \"<w:r><w:br/></w:r>\" : \"<a:br/>\";\n                this.prefix = ftprefix[docxtemplater.fileType];\n                this.runStartTag = \"\".concat(this.prefix, \":r\");\n                this.runPropsStartTag = \"\".concat(this.prefix, \":rPr\");\n                return options;\n            }\n        },\n        {\n            key: \"set\",\n            value: function set(obj) {\n                if (obj.compiled) {\n                    this.compiled = obj.compiled;\n                }\n                if (obj.data != null) {\n                    this.data = obj.data;\n                }\n            }\n        },\n        {\n            key: \"getRenderedMap\",\n            value: function getRenderedMap(mapper) {\n                for(var from in this.compiled){\n                    mapper[from] = {\n                        from: from,\n                        data: this.data\n                    };\n                }\n                return mapper;\n            }\n        },\n        {\n            key: \"postparse\",\n            value: function postparse(postparsed, options) {\n                var errors = [];\n                for(var _i2 = 0; _i2 < postparsed.length; _i2++){\n                    var p = postparsed[_i2];\n                    if (p.type === \"placeholder\") {\n                        var tag = p.value;\n                        try {\n                            options.cachedParsers[p.lIndex] = this.docxtemplater.parser(tag, {\n                                tag: p\n                            });\n                        } catch (rootError) {\n                            errors.push(getScopeCompilationError({\n                                tag: tag,\n                                rootError: rootError,\n                                offset: p.offset\n                            }));\n                        }\n                    }\n                }\n                return {\n                    postparsed: postparsed,\n                    errors: errors\n                };\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(part, _ref) {\n                var contentType = _ref.contentType, scopeManager = _ref.scopeManager, linebreaks = _ref.linebreaks, nullGetter = _ref.nullGetter, fileType = _ref.fileType, stripInvalidXMLChars = _ref.stripInvalidXMLChars;\n                if (NON_LINE_BREAKS_CONTENT_TYPE.indexOf(contentType) !== -1) {\n                    // Fixes issue tested in #docprops-linebreak\n                    linebreaks = false;\n                }\n                if (linebreaks) {\n                    this.recordRuns(part);\n                }\n                if (part.type !== \"placeholder\" || part.module) {\n                    return;\n                }\n                var value;\n                try {\n                    value = scopeManager.getValue(part.value, {\n                        part: part\n                    });\n                } catch (e) {\n                    return {\n                        errors: [\n                            e\n                        ]\n                    };\n                }\n                value !== null && value !== void 0 ? value : value = nullGetter(part);\n                if (typeof value === \"string\") {\n                    if (stripInvalidXMLChars) {\n                        value = removeCorruptCharacters(value);\n                    } else if ([\n                        \"docx\",\n                        \"pptx\",\n                        \"xlsx\"\n                    ].indexOf(fileType) !== -1 && hasCorruptCharacters(value)) {\n                        return {\n                            errors: [\n                                getCorruptCharactersException({\n                                    tag: part.value,\n                                    value: value,\n                                    offset: part.offset\n                                })\n                            ]\n                        };\n                    }\n                }\n                if (fileType === \"text\") {\n                    return {\n                        value: value\n                    };\n                }\n                return {\n                    value: linebreaks && typeof value === \"string\" ? this.renderLineBreaks(value) : utf8ToWord(value)\n                };\n            }\n        },\n        {\n            key: \"recordRuns\",\n            value: function recordRuns(part) {\n                if (part.tag === this.runStartTag) {\n                    this.recordedRun = \"\";\n                } else if (part.tag === this.runPropsStartTag) {\n                    if (part.position === \"start\") {\n                        this.recordRun = true;\n                        this.recordedRun += part.value;\n                    }\n                    if (part.position === \"end\" || part.position === \"selfclosing\") {\n                        this.recordedRun += part.value;\n                        this.recordRun = false;\n                    }\n                } else if (this.recordRun) {\n                    this.recordedRun += part.value;\n                }\n            }\n        },\n        {\n            key: \"renderLineBreaks\",\n            value: function renderLineBreaks(value) {\n                var result = [];\n                var lines = value.split(\"\\n\");\n                for(var i = 0, len = lines.length; i < len; i++){\n                    result.push(utf8ToWord(lines[i]));\n                    if (i < lines.length - 1) {\n                        result.push(\"</\".concat(this.prefix, \":t></\").concat(this.prefix, \":r>\").concat(this.brTag, \"<\").concat(this.prefix, \":r>\").concat(this.recordedRun, \"<\").concat(this.prefix, \":t\").concat(this.docxtemplater.fileType === \"docx\" ? ' xml:space=\"preserve\"' : \"\", \">\"));\n                    }\n                }\n                return result;\n            }\n        }\n    ]);\n}();\nmodule.exports = function() {\n    return wrapper(new Render());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL3JlbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxTQUFTSyxnQkFBZ0JDLENBQUMsRUFBRUMsQ0FBQztJQUFJLElBQUksQ0FBRUQsQ0FBQUEsYUFBYUMsQ0FBQUEsR0FBSSxNQUFNLElBQUlDLFVBQVU7QUFBc0M7QUFDbEgsU0FBU0Msa0JBQWtCQyxDQUFDLEVBQUVDLENBQUM7SUFBSSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUQsRUFBRUUsTUFBTSxFQUFFRCxJQUFLO1FBQUUsSUFBSVosSUFBSVcsQ0FBQyxDQUFDQyxFQUFFO1FBQUVaLEVBQUVjLFVBQVUsR0FBR2QsRUFBRWMsVUFBVSxJQUFJLENBQUMsR0FBR2QsRUFBRWUsWUFBWSxHQUFHLENBQUMsR0FBRyxXQUFXZixLQUFNQSxDQUFBQSxFQUFFZ0IsUUFBUSxHQUFHLENBQUMsSUFBSUMsT0FBT0MsY0FBYyxDQUFDUixHQUFHUyxlQUFlbkIsRUFBRW9CLEdBQUcsR0FBR3BCO0lBQUk7QUFBRTtBQUN2TyxTQUFTcUIsYUFBYVgsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUM7SUFBSSxPQUFPRCxLQUFLRixrQkFBa0JDLEVBQUVOLFNBQVMsRUFBRU8sSUFBSUMsS0FBS0gsa0JBQWtCQyxHQUFHRSxJQUFJSyxPQUFPQyxjQUFjLENBQUNSLEdBQUcsYUFBYTtRQUFFTSxVQUFV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QUNULFdBQVcsRUFBRSxLQUFLUyxNQUFNLENBQUMsSUFBSSxDQUFDRixNQUFNLEVBQUUsTUFBTUUsTUFBTSxDQUFDLElBQUksQ0FBQ0wsYUFBYSxDQUFDRSxRQUFRLEtBQUssU0FBUywwQkFBMEIsSUFBSTtvQkFDcFE7Z0JBQ0Y7Z0JBQ0EsT0FBT3VDO1lBQ1Q7UUFDRjtLQUFFO0FBQ0o7QUFDQUosT0FBT1EsT0FBTyxHQUFHO0lBQ2YsT0FBT3RFLFFBQVEsSUFBSWtCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlrZS1yZW50YWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL21vZHVsZXMvcmVuZGVyLmpzPzhkZjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciB3cmFwcGVyID0gcmVxdWlyZShcIi4uL21vZHVsZS13cmFwcGVyLmpzXCIpO1xudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uL2Vycm9ycy5qc1wiKSxcbiAgZ2V0U2NvcGVDb21waWxhdGlvbkVycm9yID0gX3JlcXVpcmUuZ2V0U2NvcGVDb21waWxhdGlvbkVycm9yLFxuICBnZXRDb3JydXB0Q2hhcmFjdGVyc0V4Y2VwdGlvbiA9IF9yZXF1aXJlLmdldENvcnJ1cHRDaGFyYWN0ZXJzRXhjZXB0aW9uO1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuLi9kb2MtdXRpbHMuanNcIiksXG4gIHV0ZjhUb1dvcmQgPSBfcmVxdWlyZTIudXRmOFRvV29yZCxcbiAgaGFzQ29ycnVwdENoYXJhY3RlcnMgPSBfcmVxdWlyZTIuaGFzQ29ycnVwdENoYXJhY3RlcnMsXG4gIHJlbW92ZUNvcnJ1cHRDaGFyYWN0ZXJzID0gX3JlcXVpcmUyLnJlbW92ZUNvcnJ1cHRDaGFyYWN0ZXJzO1xudmFyIF9yZXF1aXJlMyA9IHJlcXVpcmUoXCIuLi9jb250ZW50LXR5cGVzLmpzXCIpLFxuICBzZXR0aW5nc0NvbnRlbnRUeXBlID0gX3JlcXVpcmUzLnNldHRpbmdzQ29udGVudFR5cGUsXG4gIGNvcmVDb250ZW50VHlwZSA9IF9yZXF1aXJlMy5jb3JlQ29udGVudFR5cGUsXG4gIGFwcENvbnRlbnRUeXBlID0gX3JlcXVpcmUzLmFwcENvbnRlbnRUeXBlLFxuICBjdXN0b21Db250ZW50VHlwZSA9IF9yZXF1aXJlMy5jdXN0b21Db250ZW50VHlwZTtcbnZhciBOT05fTElORV9CUkVBS1NfQ09OVEVOVF9UWVBFID0gW3NldHRpbmdzQ29udGVudFR5cGUsIGNvcmVDb250ZW50VHlwZSwgYXBwQ29udGVudFR5cGUsIGN1c3RvbUNvbnRlbnRUeXBlXTtcbnZhciBmdHByZWZpeCA9IHtcbiAgZG9jeDogXCJ3XCIsXG4gIHBwdHg6IFwiYVwiXG59O1xudmFyIFJlbmRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlbmRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVuZGVyKTtcbiAgICB0aGlzLm5hbWUgPSBcIlJlbmRlclwiO1xuICAgIHRoaXMucmVjb3JkUnVuID0gZmFsc2U7XG4gICAgdGhpcy5yZWNvcmRlZFJ1biA9IFtdO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUmVuZGVyLCBbe1xuICAgIGtleTogXCJvcHRpb25zVHJhbnNmb3JtZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW9uc1RyYW5zZm9ybWVyKG9wdGlvbnMsIGRvY3h0ZW1wbGF0ZXIpIHtcbiAgICAgIHRoaXMuZG9jeHRlbXBsYXRlciA9IGRvY3h0ZW1wbGF0ZXI7XG4gICAgICB0aGlzLmJyVGFnID0gZG9jeHRlbXBsYXRlci5maWxlVHlwZSA9PT0gXCJkb2N4XCIgPyBcIjx3OnI+PHc6YnIvPjwvdzpyPlwiIDogXCI8YTpici8+XCI7XG4gICAgICB0aGlzLnByZWZpeCA9IGZ0cHJlZml4W2RvY3h0ZW1wbGF0ZXIuZmlsZVR5cGVdO1xuICAgICAgdGhpcy5ydW5TdGFydFRhZyA9IFwiXCIuY29uY2F0KHRoaXMucHJlZml4LCBcIjpyXCIpO1xuICAgICAgdGhpcy5ydW5Qcm9wc1N0YXJ0VGFnID0gXCJcIi5jb25jYXQodGhpcy5wcmVmaXgsIFwiOnJQclwiKTtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KG9iaikge1xuICAgICAgaWYgKG9iai5jb21waWxlZCkge1xuICAgICAgICB0aGlzLmNvbXBpbGVkID0gb2JqLmNvbXBpbGVkO1xuICAgICAgfVxuICAgICAgaWYgKG9iai5kYXRhICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gb2JqLmRhdGE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFJlbmRlcmVkTWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlbmRlcmVkTWFwKG1hcHBlcikge1xuICAgICAgZm9yICh2YXIgZnJvbSBpbiB0aGlzLmNvbXBpbGVkKSB7XG4gICAgICAgIG1hcHBlcltmcm9tXSA9IHtcbiAgICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcHBlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zdHBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3RwYXJzZShwb3N0cGFyc2VkLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwb3N0cGFyc2VkLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIHAgPSBwb3N0cGFyc2VkW19pMl07XG4gICAgICAgIGlmIChwLnR5cGUgPT09IFwicGxhY2Vob2xkZXJcIikge1xuICAgICAgICAgIHZhciB0YWcgPSBwLnZhbHVlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhY2hlZFBhcnNlcnNbcC5sSW5kZXhdID0gdGhpcy5kb2N4dGVtcGxhdGVyLnBhcnNlcih0YWcsIHtcbiAgICAgICAgICAgICAgdGFnOiBwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChyb290RXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKGdldFNjb3BlQ29tcGlsYXRpb25FcnJvcih7XG4gICAgICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgICAgICByb290RXJyb3I6IHJvb3RFcnJvcixcbiAgICAgICAgICAgICAgb2Zmc2V0OiBwLm9mZnNldFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9zdHBhcnNlZDogcG9zdHBhcnNlZCxcbiAgICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocGFydCwgX3JlZikge1xuICAgICAgdmFyIGNvbnRlbnRUeXBlID0gX3JlZi5jb250ZW50VHlwZSxcbiAgICAgICAgc2NvcGVNYW5hZ2VyID0gX3JlZi5zY29wZU1hbmFnZXIsXG4gICAgICAgIGxpbmVicmVha3MgPSBfcmVmLmxpbmVicmVha3MsXG4gICAgICAgIG51bGxHZXR0ZXIgPSBfcmVmLm51bGxHZXR0ZXIsXG4gICAgICAgIGZpbGVUeXBlID0gX3JlZi5maWxlVHlwZSxcbiAgICAgICAgc3RyaXBJbnZhbGlkWE1MQ2hhcnMgPSBfcmVmLnN0cmlwSW52YWxpZFhNTENoYXJzO1xuICAgICAgaWYgKE5PTl9MSU5FX0JSRUFLU19DT05URU5UX1RZUEUuaW5kZXhPZihjb250ZW50VHlwZSkgIT09IC0xKSB7XG4gICAgICAgIC8vIEZpeGVzIGlzc3VlIHRlc3RlZCBpbiAjZG9jcHJvcHMtbGluZWJyZWFrXG4gICAgICAgIGxpbmVicmVha3MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lYnJlYWtzKSB7XG4gICAgICAgIHRoaXMucmVjb3JkUnVucyhwYXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0LnR5cGUgIT09IFwicGxhY2Vob2xkZXJcIiB8fCBwYXJ0Lm1vZHVsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB0cnkge1xuICAgICAgICB2YWx1ZSA9IHNjb3BlTWFuYWdlci5nZXRWYWx1ZShwYXJ0LnZhbHVlLCB7XG4gICAgICAgICAgcGFydDogcGFydFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlcnJvcnM6IFtlXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDogdmFsdWUgPSBudWxsR2V0dGVyKHBhcnQpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoc3RyaXBJbnZhbGlkWE1MQ2hhcnMpIHtcbiAgICAgICAgICB2YWx1ZSA9IHJlbW92ZUNvcnJ1cHRDaGFyYWN0ZXJzKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChbXCJkb2N4XCIsIFwicHB0eFwiLCBcInhsc3hcIl0uaW5kZXhPZihmaWxlVHlwZSkgIT09IC0xICYmIGhhc0NvcnJ1cHRDaGFyYWN0ZXJzKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcnM6IFtnZXRDb3JydXB0Q2hhcmFjdGVyc0V4Y2VwdGlvbih7XG4gICAgICAgICAgICAgIHRhZzogcGFydC52YWx1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICBvZmZzZXQ6IHBhcnQub2Zmc2V0XG4gICAgICAgICAgICB9KV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZmlsZVR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogbGluZWJyZWFrcyAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB0aGlzLnJlbmRlckxpbmVCcmVha3ModmFsdWUpIDogdXRmOFRvV29yZCh2YWx1ZSlcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlY29yZFJ1bnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb3JkUnVucyhwYXJ0KSB7XG4gICAgICBpZiAocGFydC50YWcgPT09IHRoaXMucnVuU3RhcnRUYWcpIHtcbiAgICAgICAgdGhpcy5yZWNvcmRlZFJ1biA9IFwiXCI7XG4gICAgICB9IGVsc2UgaWYgKHBhcnQudGFnID09PSB0aGlzLnJ1blByb3BzU3RhcnRUYWcpIHtcbiAgICAgICAgaWYgKHBhcnQucG9zaXRpb24gPT09IFwic3RhcnRcIikge1xuICAgICAgICAgIHRoaXMucmVjb3JkUnVuID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnJlY29yZGVkUnVuICs9IHBhcnQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQucG9zaXRpb24gPT09IFwiZW5kXCIgfHwgcGFydC5wb3NpdGlvbiA9PT0gXCJzZWxmY2xvc2luZ1wiKSB7XG4gICAgICAgICAgdGhpcy5yZWNvcmRlZFJ1biArPSBwYXJ0LnZhbHVlO1xuICAgICAgICAgIHRoaXMucmVjb3JkUnVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZWNvcmRSdW4pIHtcbiAgICAgICAgdGhpcy5yZWNvcmRlZFJ1biArPSBwYXJ0LnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJMaW5lQnJlYWtzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckxpbmVCcmVha3ModmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciBsaW5lcyA9IHZhbHVlLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHV0ZjhUb1dvcmQobGluZXNbaV0pKTtcbiAgICAgICAgaWYgKGkgPCBsaW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goXCI8L1wiLmNvbmNhdCh0aGlzLnByZWZpeCwgXCI6dD48L1wiKS5jb25jYXQodGhpcy5wcmVmaXgsIFwiOnI+XCIpLmNvbmNhdCh0aGlzLmJyVGFnLCBcIjxcIikuY29uY2F0KHRoaXMucHJlZml4LCBcIjpyPlwiKS5jb25jYXQodGhpcy5yZWNvcmRlZFJ1biwgXCI8XCIpLmNvbmNhdCh0aGlzLnByZWZpeCwgXCI6dFwiKS5jb25jYXQodGhpcy5kb2N4dGVtcGxhdGVyLmZpbGVUeXBlID09PSBcImRvY3hcIiA/ICcgeG1sOnNwYWNlPVwicHJlc2VydmVcIicgOiBcIlwiLCBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfV0pO1xufSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB3cmFwcGVyKG5ldyBSZW5kZXIoKSk7XG59OyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJhIiwibiIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwiZSIsInIiLCJ0IiwibGVuZ3RoIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsImtleSIsIl9jcmVhdGVDbGFzcyIsImkiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsImNhbGwiLCJTdHJpbmciLCJOdW1iZXIiLCJ3cmFwcGVyIiwicmVxdWlyZSIsIl9yZXF1aXJlIiwiZ2V0U2NvcGVDb21waWxhdGlvbkVycm9yIiwiZ2V0Q29ycnVwdENoYXJhY3RlcnNFeGNlcHRpb24iLCJfcmVxdWlyZTIiLCJ1dGY4VG9Xb3JkIiwiaGFzQ29ycnVwdENoYXJhY3RlcnMiLCJyZW1vdmVDb3JydXB0Q2hhcmFjdGVycyIsIl9yZXF1aXJlMyIsInNldHRpbmdzQ29udGVudFR5cGUiLCJjb3JlQ29udGVudFR5cGUiLCJhcHBDb250ZW50VHlwZSIsImN1c3RvbUNvbnRlbnRUeXBlIiwiTk9OX0xJTkVfQlJFQUtTX0NPTlRFTlRfVFlQRSIsImZ0cHJlZml4IiwiZG9jeCIsInBwdHgiLCJSZW5kZXIiLCJuYW1lIiwicmVjb3JkUnVuIiwicmVjb3JkZWRSdW4iLCJ2YWx1ZSIsIm9wdGlvbnNUcmFuc2Zvcm1lciIsIm9wdGlvbnMiLCJkb2N4dGVtcGxhdGVyIiwiYnJUYWciLCJmaWxlVHlwZSIsInByZWZpeCIsInJ1blN0YXJ0VGFnIiwiY29uY2F0IiwicnVuUHJvcHNTdGFydFRhZyIsInNldCIsIm9iaiIsImNvbXBpbGVkIiwiZGF0YSIsImdldFJlbmRlcmVkTWFwIiwibWFwcGVyIiwiZnJvbSIsInBvc3RwYXJzZSIsInBvc3RwYXJzZWQiLCJlcnJvcnMiLCJfaTIiLCJwIiwidHlwZSIsInRhZyIsImNhY2hlZFBhcnNlcnMiLCJsSW5kZXgiLCJwYXJzZXIiLCJyb290RXJyb3IiLCJwdXNoIiwib2Zmc2V0IiwicmVuZGVyIiwicGFydCIsIl9yZWYiLCJjb250ZW50VHlwZSIsInNjb3BlTWFuYWdlciIsImxpbmVicmVha3MiLCJudWxsR2V0dGVyIiwic3RyaXBJbnZhbGlkWE1MQ2hhcnMiLCJpbmRleE9mIiwicmVjb3JkUnVucyIsIm1vZHVsZSIsImdldFZhbHVlIiwicmVuZGVyTGluZUJyZWFrcyIsInBvc2l0aW9uIiwicmVzdWx0IiwibGluZXMiLCJzcGxpdCIsImxlbiIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/modules/render.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/modules/space-preserve.js":
/*!*****************************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/space-preserve.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n    for(var t = 0; t < r.length; t++){\n        var o = r[t];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n}\nfunction _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n        writable: !1\n    }), e;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(rsc)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"), isTextStart = _require.isTextStart, isTextEnd = _require.isTextEnd, endsWith = _require.endsWith, startsWith = _require.startsWith, pushArray = _require.pushArray;\nvar wTpreserve = '<w:t xml:space=\"preserve\">';\nvar wTpreservelen = wTpreserve.length;\nvar wtEnd = \"</w:t>\";\nvar wtEndlen = wtEnd.length;\nfunction isWtStart(part) {\n    return isTextStart(part) && part.tag === \"w:t\";\n}\nfunction addXMLPreserve(chunk, index) {\n    var tag = chunk[index].value;\n    if (chunk[index + 1].value === \"</w:t>\") {\n        return tag;\n    }\n    if (tag.indexOf('xml:space=\"preserve\"') !== -1) {\n        return tag;\n    }\n    return tag.substr(0, tag.length - 1) + ' xml:space=\"preserve\">';\n}\nfunction isInsideLoop(meta, chunk) {\n    return meta && meta.basePart && chunk.length > 1;\n}\n// This module is used only for `docx` files\nvar SpacePreserve = /*#__PURE__*/ function() {\n    function SpacePreserve() {\n        _classCallCheck(this, SpacePreserve);\n        this.name = \"SpacePreserveModule\";\n    }\n    return _createClass(SpacePreserve, [\n        {\n            key: \"postparse\",\n            value: function postparse(postparsed, meta) {\n                var chunk = [], inTextTag = false, endLindex = 0, lastTextTag = 0;\n                function isStartingPlaceHolder(part, chunk) {\n                    return part.type === \"placeholder\" && chunk.length > 1;\n                }\n                var result = postparsed.reduce(function(postparsed, part) {\n                    if (isWtStart(part)) {\n                        inTextTag = true;\n                        lastTextTag = chunk.length;\n                    }\n                    if (!inTextTag) {\n                        postparsed.push(part);\n                        return postparsed;\n                    }\n                    chunk.push(part);\n                    if (isInsideLoop(meta, chunk)) {\n                        endLindex = meta.basePart.endLindex;\n                        chunk[0].value = addXMLPreserve(chunk, 0);\n                    }\n                    if (isStartingPlaceHolder(part, chunk)) {\n                        chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);\n                        endLindex = part.endLindex;\n                    }\n                    if (isTextEnd(part) && part.lIndex > endLindex) {\n                        if (endLindex !== 0) {\n                            chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);\n                        }\n                        pushArray(postparsed, chunk);\n                        chunk = [];\n                        inTextTag = false;\n                        endLindex = 0;\n                        lastTextTag = 0;\n                    }\n                    return postparsed;\n                }, []);\n                pushArray(result, chunk);\n                return result;\n            }\n        },\n        {\n            key: \"postrender\",\n            value: function postrender(parts) {\n                var lastNonEmpty = \"\";\n                var lastNonEmptyIndex = 0;\n                for(var i = 0, len = parts.length; i < len; i++){\n                    var p = parts[i];\n                    if (p === \"\") {\n                        continue;\n                    }\n                    if (endsWith(lastNonEmpty, wTpreserve) && startsWith(p, wtEnd)) {\n                        parts[lastNonEmptyIndex] = lastNonEmpty.substr(0, lastNonEmpty.length - wTpreservelen) + \"<w:t/>\";\n                        p = p.substr(wtEndlen);\n                    }\n                    lastNonEmpty = p;\n                    lastNonEmptyIndex = i;\n                    parts[i] = p;\n                }\n                return parts;\n            }\n        }\n    ]);\n}();\nmodule.exports = function() {\n    return wrapper(new SpacePreserve());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL3NwYWNlLXByZXNlcnZlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNLLGdCQUFnQkMsQ0FBQyxFQUFFQyxDQUFDO0lBQUksSUFBSSxDQUFFRCxDQUFBQSxhQUFhQyxDQUFBQSxHQUFJLE1BQU0sSUFBSUMsVUFBVTtBQUFzQztBQUNsSCxTQUFTQyxrQkFBa0JDLENBQUMsRUFBRUMsQ0FBQztJQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxFQUFFRSxNQUFNLEVBQUVELElBQUs7UUFBRSxJQUFJWixJQUFJVyxDQUFDLENBQUNDLEVBQUU7UUFBRVosRUFBRWMsVUFBVSxHQUFHZCxFQUFFYyxVQUFVLElBQUksQ0FBQyxHQUFHZCxFQUFFZSxZQUFZLEdBQUcsQ0FBQyxHQUFHLFdBQVdmLEtBQU1BLENBQUFBLEVBQUVnQixRQUFRLEdBQUcsQ0FBQyxJQUFJQyxPQUFPQyxjQUFjLENBQUNSLEdBQUdTLGVBQWVuQixFQUFFb0IsR0FBRyxHQUFHcEI7SUFBSTtBQUFFO0FBQ3ZPLFNBQVNxQixhQUFhWCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQztJQUFJLE9BQU9ELEtBQUtGLGtCQUFrQkMsRUFBRU4sU0FBUyxFQUFFTyxJQUFJQyxLQUFLSCxrQkFBa0JDLEdBQUdFLElBQUlLLE9BQU9DLGNBQWMsQ0FBQ1IsR0FBRyxhQUFhO1FB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QUssQ0FBQzVDLEVBQUUsR0FBR2dEO2dCQUNiO2dCQUNBLE9BQU9KO1lBQ1Q7UUFDRjtLQUFFO0FBQ0o7QUFDQUssT0FBT0MsT0FBTyxHQUFHO0lBQ2YsT0FBTzVDLFFBQVEsSUFBSXdCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlrZS1yZW50YWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL21vZHVsZXMvc3BhY2UtcHJlc2VydmUuanM/OWUxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIHdyYXBwZXIgPSByZXF1aXJlKFwiLi4vbW9kdWxlLXdyYXBwZXIuanNcIik7XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vZG9jLXV0aWxzLmpzXCIpLFxuICBpc1RleHRTdGFydCA9IF9yZXF1aXJlLmlzVGV4dFN0YXJ0LFxuICBpc1RleHRFbmQgPSBfcmVxdWlyZS5pc1RleHRFbmQsXG4gIGVuZHNXaXRoID0gX3JlcXVpcmUuZW5kc1dpdGgsXG4gIHN0YXJ0c1dpdGggPSBfcmVxdWlyZS5zdGFydHNXaXRoLFxuICBwdXNoQXJyYXkgPSBfcmVxdWlyZS5wdXNoQXJyYXk7XG52YXIgd1RwcmVzZXJ2ZSA9ICc8dzp0IHhtbDpzcGFjZT1cInByZXNlcnZlXCI+JztcbnZhciB3VHByZXNlcnZlbGVuID0gd1RwcmVzZXJ2ZS5sZW5ndGg7XG52YXIgd3RFbmQgPSBcIjwvdzp0PlwiO1xudmFyIHd0RW5kbGVuID0gd3RFbmQubGVuZ3RoO1xuZnVuY3Rpb24gaXNXdFN0YXJ0KHBhcnQpIHtcbiAgcmV0dXJuIGlzVGV4dFN0YXJ0KHBhcnQpICYmIHBhcnQudGFnID09PSBcInc6dFwiO1xufVxuZnVuY3Rpb24gYWRkWE1MUHJlc2VydmUoY2h1bmssIGluZGV4KSB7XG4gIHZhciB0YWcgPSBjaHVua1tpbmRleF0udmFsdWU7XG4gIGlmIChjaHVua1tpbmRleCArIDFdLnZhbHVlID09PSBcIjwvdzp0PlwiKSB7XG4gICAgcmV0dXJuIHRhZztcbiAgfVxuICBpZiAodGFnLmluZGV4T2YoJ3htbDpzcGFjZT1cInByZXNlcnZlXCInKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gdGFnO1xuICB9XG4gIHJldHVybiB0YWcuc3Vic3RyKDAsIHRhZy5sZW5ndGggLSAxKSArICcgeG1sOnNwYWNlPVwicHJlc2VydmVcIj4nO1xufVxuZnVuY3Rpb24gaXNJbnNpZGVMb29wKG1ldGEsIGNodW5rKSB7XG4gIHJldHVybiBtZXRhICYmIG1ldGEuYmFzZVBhcnQgJiYgY2h1bmsubGVuZ3RoID4gMTtcbn1cblxuLy8gVGhpcyBtb2R1bGUgaXMgdXNlZCBvbmx5IGZvciBgZG9jeGAgZmlsZXNcbnZhciBTcGFjZVByZXNlcnZlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3BhY2VQcmVzZXJ2ZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3BhY2VQcmVzZXJ2ZSk7XG4gICAgdGhpcy5uYW1lID0gXCJTcGFjZVByZXNlcnZlTW9kdWxlXCI7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhTcGFjZVByZXNlcnZlLCBbe1xuICAgIGtleTogXCJwb3N0cGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdHBhcnNlKHBvc3RwYXJzZWQsIG1ldGEpIHtcbiAgICAgIHZhciBjaHVuayA9IFtdLFxuICAgICAgICBpblRleHRUYWcgPSBmYWxzZSxcbiAgICAgICAgZW5kTGluZGV4ID0gMCxcbiAgICAgICAgbGFzdFRleHRUYWcgPSAwO1xuICAgICAgZnVuY3Rpb24gaXNTdGFydGluZ1BsYWNlSG9sZGVyKHBhcnQsIGNodW5rKSB7XG4gICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwicGxhY2Vob2xkZXJcIiAmJiBjaHVuay5sZW5ndGggPiAxO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHBvc3RwYXJzZWQucmVkdWNlKGZ1bmN0aW9uIChwb3N0cGFyc2VkLCBwYXJ0KSB7XG4gICAgICAgIGlmIChpc1d0U3RhcnQocGFydCkpIHtcbiAgICAgICAgICBpblRleHRUYWcgPSB0cnVlO1xuICAgICAgICAgIGxhc3RUZXh0VGFnID0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5UZXh0VGFnKSB7XG4gICAgICAgICAgcG9zdHBhcnNlZC5wdXNoKHBhcnQpO1xuICAgICAgICAgIHJldHVybiBwb3N0cGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIGNodW5rLnB1c2gocGFydCk7XG4gICAgICAgIGlmIChpc0luc2lkZUxvb3AobWV0YSwgY2h1bmspKSB7XG4gICAgICAgICAgZW5kTGluZGV4ID0gbWV0YS5iYXNlUGFydC5lbmRMaW5kZXg7XG4gICAgICAgICAgY2h1bmtbMF0udmFsdWUgPSBhZGRYTUxQcmVzZXJ2ZShjaHVuaywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RhcnRpbmdQbGFjZUhvbGRlcihwYXJ0LCBjaHVuaykpIHtcbiAgICAgICAgICBjaHVua1tsYXN0VGV4dFRhZ10udmFsdWUgPSBhZGRYTUxQcmVzZXJ2ZShjaHVuaywgbGFzdFRleHRUYWcpO1xuICAgICAgICAgIGVuZExpbmRleCA9IHBhcnQuZW5kTGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RleHRFbmQocGFydCkgJiYgcGFydC5sSW5kZXggPiBlbmRMaW5kZXgpIHtcbiAgICAgICAgICBpZiAoZW5kTGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICBjaHVua1tsYXN0VGV4dFRhZ10udmFsdWUgPSBhZGRYTUxQcmVzZXJ2ZShjaHVuaywgbGFzdFRleHRUYWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwdXNoQXJyYXkocG9zdHBhcnNlZCwgY2h1bmspO1xuICAgICAgICAgIGNodW5rID0gW107XG4gICAgICAgICAgaW5UZXh0VGFnID0gZmFsc2U7XG4gICAgICAgICAgZW5kTGluZGV4ID0gMDtcbiAgICAgICAgICBsYXN0VGV4dFRhZyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvc3RwYXJzZWQ7XG4gICAgICB9LCBbXSk7XG4gICAgICBwdXNoQXJyYXkocmVzdWx0LCBjaHVuayk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3N0cmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3RyZW5kZXIocGFydHMpIHtcbiAgICAgIHZhciBsYXN0Tm9uRW1wdHkgPSBcIlwiO1xuICAgICAgdmFyIGxhc3ROb25FbXB0eUluZGV4ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgcCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAocCA9PT0gXCJcIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRzV2l0aChsYXN0Tm9uRW1wdHksIHdUcHJlc2VydmUpICYmIHN0YXJ0c1dpdGgocCwgd3RFbmQpKSB7XG4gICAgICAgICAgcGFydHNbbGFzdE5vbkVtcHR5SW5kZXhdID0gbGFzdE5vbkVtcHR5LnN1YnN0cigwLCBsYXN0Tm9uRW1wdHkubGVuZ3RoIC0gd1RwcmVzZXJ2ZWxlbikgKyBcIjx3OnQvPlwiO1xuICAgICAgICAgIHAgPSBwLnN1YnN0cih3dEVuZGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdE5vbkVtcHR5ID0gcDtcbiAgICAgICAgbGFzdE5vbkVtcHR5SW5kZXggPSBpO1xuICAgICAgICBwYXJ0c1tpXSA9IHA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFydHM7XG4gICAgfVxuICB9XSk7XG59KCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHdyYXBwZXIobmV3IFNwYWNlUHJlc2VydmUoKSk7XG59OyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJhIiwibiIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwiZSIsInIiLCJ0IiwibGVuZ3RoIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsImtleSIsIl9jcmVhdGVDbGFzcyIsImkiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsImNhbGwiLCJTdHJpbmciLCJOdW1iZXIiLCJ3cmFwcGVyIiwicmVxdWlyZSIsIl9yZXF1aXJlIiwiaXNUZXh0U3RhcnQiLCJpc1RleHRFbmQiLCJlbmRzV2l0aCIsInN0YXJ0c1dpdGgiLCJwdXNoQXJyYXkiLCJ3VHByZXNlcnZlIiwid1RwcmVzZXJ2ZWxlbiIsInd0RW5kIiwid3RFbmRsZW4iLCJpc1d0U3RhcnQiLCJwYXJ0IiwidGFnIiwiYWRkWE1MUHJlc2VydmUiLCJjaHVuayIsImluZGV4IiwidmFsdWUiLCJpbmRleE9mIiwic3Vic3RyIiwiaXNJbnNpZGVMb29wIiwibWV0YSIsImJhc2VQYXJ0IiwiU3BhY2VQcmVzZXJ2ZSIsIm5hbWUiLCJwb3N0cGFyc2UiLCJwb3N0cGFyc2VkIiwiaW5UZXh0VGFnIiwiZW5kTGluZGV4IiwibGFzdFRleHRUYWciLCJpc1N0YXJ0aW5nUGxhY2VIb2xkZXIiLCJ0eXBlIiwicmVzdWx0IiwicmVkdWNlIiwicHVzaCIsImxJbmRleCIsInBvc3RyZW5kZXIiLCJwYXJ0cyIsImxhc3ROb25FbXB0eSIsImxhc3ROb25FbXB0eUluZGV4IiwibGVuIiwicCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/modules/space-preserve.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/parser.js":
/*!*************************************************!*\
  !*** ./node_modules/docxtemplater/js/parser.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _slicedToArray(r, e) {\n    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(r, a) {\n    if (r) {\n        if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n        var t = ({}).toString.call(r).slice(8, -1);\n        return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n    }\n}\nfunction _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];\n    return n;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(r) {\n    if (Array.isArray(r)) return r;\n}\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"), wordToUtf8 = _require.wordToUtf8, pushArray = _require.pushArray;\nvar _require2 = __webpack_require__(/*! ./prefix-matcher.js */ \"(rsc)/./node_modules/docxtemplater/js/prefix-matcher.js\"), match = _require2.match, getValue = _require2.getValue, getValues = _require2.getValues;\nfunction getMatchers(modules, options) {\n    var allMatchers = [];\n    for(var _i2 = 0; _i2 < modules.length; _i2++){\n        var _module = modules[_i2];\n        if (_module.matchers) {\n            var matchers = _module.matchers(options);\n            if (!(matchers instanceof Array)) {\n                throw new Error(\"module matcher returns a non array\");\n            }\n            pushArray(allMatchers, matchers);\n        }\n    }\n    return allMatchers;\n}\nfunction getMatches(matchers, placeHolderContent, options) {\n    var matches = [];\n    for(var _i4 = 0; _i4 < matchers.length; _i4++){\n        var matcher = matchers[_i4];\n        var _matcher = _slicedToArray(matcher, 2), prefix = _matcher[0], _module2 = _matcher[1];\n        var properties = matcher[2] || {};\n        if (options.match(prefix, placeHolderContent)) {\n            var values = options.getValues(prefix, placeHolderContent);\n            if (typeof properties === \"function\") {\n                properties = properties(values);\n            }\n            if (!properties.value) {\n                var _values = _slicedToArray(values, 2);\n                properties.value = _values[1];\n            }\n            matches.push(_objectSpread({\n                type: \"placeholder\",\n                prefix: prefix,\n                module: _module2,\n                onMatch: properties.onMatch,\n                priority: properties.priority\n            }, properties));\n        }\n    }\n    return matches;\n}\nfunction moduleParse(placeHolderContent, options) {\n    var modules = options.modules;\n    var startOffset = options.startOffset;\n    var endLindex = options.lIndex;\n    var moduleParsed;\n    options.offset = startOffset;\n    options.match = match;\n    options.getValue = getValue;\n    options.getValues = getValues;\n    var matchers = getMatchers(modules, options);\n    var matches = getMatches(matchers, placeHolderContent, options);\n    if (matches.length > 0) {\n        var bestMatch = null;\n        for(var _i6 = 0; _i6 < matches.length; _i6++){\n            var _match = matches[_i6];\n            _match.priority || (_match.priority = -_match.value.length);\n            if (!bestMatch || _match.priority > bestMatch.priority) {\n                bestMatch = _match;\n            }\n        }\n        bestMatch.offset = startOffset;\n        delete bestMatch.priority;\n        bestMatch.endLindex = endLindex;\n        bestMatch.lIndex = endLindex;\n        bestMatch.raw = placeHolderContent;\n        if (bestMatch.onMatch) {\n            bestMatch.onMatch(bestMatch);\n        }\n        delete bestMatch.onMatch;\n        delete bestMatch.prefix;\n        return bestMatch;\n    }\n    for(var _i8 = 0; _i8 < modules.length; _i8++){\n        var _module3 = modules[_i8];\n        moduleParsed = _module3.parse(placeHolderContent, options);\n        if (moduleParsed) {\n            moduleParsed.offset = startOffset;\n            moduleParsed.endLindex = endLindex;\n            moduleParsed.lIndex = endLindex;\n            moduleParsed.raw = placeHolderContent;\n            return moduleParsed;\n        }\n    }\n    return {\n        type: \"placeholder\",\n        value: placeHolderContent,\n        offset: startOffset,\n        endLindex: endLindex,\n        lIndex: endLindex\n    };\n}\nvar parser = {\n    preparse: function preparse(parsed, modules, options) {\n        function preparse(parsed, options) {\n            for(var _i10 = 0; _i10 < modules.length; _i10++){\n                var _module4 = modules[_i10];\n                parsed = _module4.preparse(parsed, options) || parsed;\n            }\n            return parsed;\n        }\n        return preparse(parsed, options);\n    },\n    parse: function parse(lexed, modules, options) {\n        var inPlaceHolder = false;\n        var placeHolderContent = \"\";\n        var startOffset;\n        var tailParts = [];\n        var droppedTags = options.fileTypeConfig.droppedTagsInsidePlaceholder || [];\n        return lexed.reduce(function(parsed, token) {\n            if (token.type === \"delimiter\") {\n                inPlaceHolder = token.position === \"start\";\n                if (token.position === \"end\") {\n                    options.parse = function(placeHolderContent) {\n                        return moduleParse(placeHolderContent, _objectSpread(_objectSpread(_objectSpread({}, options), token), {}, {\n                            startOffset: startOffset,\n                            modules: modules\n                        }));\n                    };\n                    parsed.push(options.parse(wordToUtf8(placeHolderContent)));\n                    pushArray(parsed, tailParts);\n                    tailParts = [];\n                }\n                if (token.position === \"start\") {\n                    tailParts = [];\n                    startOffset = token.offset;\n                }\n                placeHolderContent = \"\";\n                return parsed;\n            }\n            if (!inPlaceHolder) {\n                parsed.push(token);\n                return parsed;\n            }\n            if (token.type !== \"content\" || token.position !== \"insidetag\") {\n                if (droppedTags.indexOf(token.tag) !== -1) {\n                    return parsed;\n                }\n                tailParts.push(token);\n                return parsed;\n            }\n            placeHolderContent += token.value;\n            return parsed;\n        }, []);\n    },\n    postparse: function postparse(postparsed, modules, options) {\n        function getTraits(traitName, postparsed) {\n            return modules.map(function(module1) {\n                return module1.getTraits(traitName, postparsed);\n            });\n        }\n        var errors = [];\n        function _postparse(postparsed, options) {\n            return modules.reduce(function(postparsed, module1) {\n                var r = module1.postparse(postparsed, _objectSpread(_objectSpread({}, options), {}, {\n                    postparse: function postparse(parsed, opts) {\n                        return _postparse(parsed, _objectSpread(_objectSpread({}, options), opts));\n                    },\n                    getTraits: getTraits\n                }));\n                if (r == null) {\n                    return postparsed;\n                }\n                if (r.errors) {\n                    pushArray(errors, r.errors);\n                    return r.postparsed;\n                }\n                return r;\n            }, postparsed);\n        }\n        return {\n            postparsed: _postparse(postparsed, options),\n            errors: errors\n        };\n    }\n};\nmodule.exports = parser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRUcsV0FBVyxLQUFLRixVQUFVRCxNQUFNQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1QsU0FBU0ssUUFBUUMsQ0FBQyxFQUFFQyxDQUFDO0lBQUksSUFBSUMsSUFBSUMsT0FBT0MsSUFBSSxDQUFDSjtJQUFJLElBQUlHLE9BQU9FLHFCQUFxQixFQUFFO1FBQUUsSUFBSVgsSUFBSVMsT0FBT0UscUJBQXFCLENBQUNMO1FBQUlDLEtBQU1QLENBQUFBLElBQUlBLEVBQUVZLE1BQU0sQ0FBQyxTQUFVTCxDQUFDO1lBQUksT0FBT0UsT0FBT0ksd0JBQXdCLENBQUNQLEdBQUdDLEdBQUdPLFVBQVU7UUFBRSxFQUFDLEdBQUlOLEVBQUVPLElBQUksQ0FBQ0MsS0FBSyxDQUFDUixHQUFHUjtJQUFJO0lBQUUsT0FBT1E7QUFBRztBQUM5UCxTQUFTUyxjQUFjWCxDQUFDO0lBQUksSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlXLFVBQVVDLE1BQU0sRUFBRVosSUFBSztRQUFFLElBQUlDLElBQUksUUFBUVUsU0FBUyxDQUFDWCxFQUFFLEdBQUdXLFNBQVMsQ0FBQ1gsRUFBRSxHQUFHLENBQUM7UUFBR0EsSUFBSSxJQUFJRixRQUFRSSxPQUFPRCxJQUFJLENBQUMsR0FBR1ksT0FBTyxDQUFDLFNBQVViLENBQUM7WUFBSWMsZ0JBQWdCZixHQUFHQyxHQUFHQyxDQUFDLENBQUNELEVBQUU7UUFBRyxLQUFL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QU9wRCxRQUFRdUQsR0FBRyxDQUFDLFNBQVVwQyxPQUFNO2dCQUNqQyxPQUFPQSxRQUFPa0MsU0FBUyxDQUFDQyxXQUFXRjtZQUNyQztRQUNGO1FBQ0EsSUFBSUksU0FBUyxFQUFFO1FBQ2YsU0FBU0MsV0FBV0wsVUFBVSxFQUFFbkQsT0FBTztZQUNyQyxPQUFPRCxRQUFROEMsTUFBTSxDQUFDLFNBQVVNLFVBQVUsRUFBRWpDLE9BQU07Z0JBQ2hELElBQUk3RSxJQUFJNkUsUUFBT2dDLFNBQVMsQ0FBQ0MsWUFBWXBHLGNBQWNBLGNBQWMsQ0FBQyxHQUFHaUQsVUFBVSxDQUFDLEdBQUc7b0JBQ2pGa0QsV0FBVyxTQUFTQSxVQUFVZCxNQUFNLEVBQUVxQixJQUFJO3dCQUN4QyxPQUFPRCxXQUFXcEIsUUFBUXJGLGNBQWNBLGNBQWMsQ0FBQyxHQUFHaUQsVUFBVXlEO29CQUN0RTtvQkFDQUwsV0FBV0E7Z0JBQ2I7Z0JBQ0EsSUFBSS9HLEtBQUssTUFBTTtvQkFDYixPQUFPOEc7Z0JBQ1Q7Z0JBQ0EsSUFBSTlHLEVBQUVrSCxNQUFNLEVBQUU7b0JBQ1o5RCxVQUFVOEQsUUFBUWxILEVBQUVrSCxNQUFNO29CQUMxQixPQUFPbEgsRUFBRThHLFVBQVU7Z0JBQ3JCO2dCQUNBLE9BQU85RztZQUNULEdBQUc4RztRQUNMO1FBQ0EsT0FBTztZQUNMQSxZQUFZSyxXQUFXTCxZQUFZbkQ7WUFDbkN1RCxRQUFRQTtRQUNWO0lBQ0Y7QUFDRjtBQUNBckMsT0FBT3dDLE9BQU8sR0FBR3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlrZS1yZW50YWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL3BhcnNlci5qcz80YTg5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7IH1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgd29yZFRvVXRmOCA9IF9yZXF1aXJlLndvcmRUb1V0ZjgsXG4gIHB1c2hBcnJheSA9IF9yZXF1aXJlLnB1c2hBcnJheTtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi9wcmVmaXgtbWF0Y2hlci5qc1wiKSxcbiAgbWF0Y2ggPSBfcmVxdWlyZTIubWF0Y2gsXG4gIGdldFZhbHVlID0gX3JlcXVpcmUyLmdldFZhbHVlLFxuICBnZXRWYWx1ZXMgPSBfcmVxdWlyZTIuZ2V0VmFsdWVzO1xuZnVuY3Rpb24gZ2V0TWF0Y2hlcnMobW9kdWxlcywgb3B0aW9ucykge1xuICB2YXIgYWxsTWF0Y2hlcnMgPSBbXTtcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbW9kdWxlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9tb2R1bGUgPSBtb2R1bGVzW19pMl07XG4gICAgaWYgKF9tb2R1bGUubWF0Y2hlcnMpIHtcbiAgICAgIHZhciBtYXRjaGVycyA9IF9tb2R1bGUubWF0Y2hlcnMob3B0aW9ucyk7XG4gICAgICBpZiAoIShtYXRjaGVycyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2R1bGUgbWF0Y2hlciByZXR1cm5zIGEgbm9uIGFycmF5XCIpO1xuICAgICAgfVxuICAgICAgcHVzaEFycmF5KGFsbE1hdGNoZXJzLCBtYXRjaGVycyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhbGxNYXRjaGVycztcbn1cbmZ1bmN0aW9uIGdldE1hdGNoZXMobWF0Y2hlcnMsIHBsYWNlSG9sZGVyQ29udGVudCwgb3B0aW9ucykge1xuICB2YXIgbWF0Y2hlcyA9IFtdO1xuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBtYXRjaGVycy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgdmFyIG1hdGNoZXIgPSBtYXRjaGVyc1tfaTRdO1xuICAgIHZhciBfbWF0Y2hlciA9IF9zbGljZWRUb0FycmF5KG1hdGNoZXIsIDIpLFxuICAgICAgcHJlZml4ID0gX21hdGNoZXJbMF0sXG4gICAgICBfbW9kdWxlMiA9IF9tYXRjaGVyWzFdO1xuICAgIHZhciBwcm9wZXJ0aWVzID0gbWF0Y2hlclsyXSB8fCB7fTtcbiAgICBpZiAob3B0aW9ucy5tYXRjaChwcmVmaXgsIHBsYWNlSG9sZGVyQ29udGVudCkpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBvcHRpb25zLmdldFZhbHVlcyhwcmVmaXgsIHBsYWNlSG9sZGVyQ29udGVudCk7XG4gICAgICBpZiAodHlwZW9mIHByb3BlcnRpZXMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKCFwcm9wZXJ0aWVzLnZhbHVlKSB7XG4gICAgICAgIHZhciBfdmFsdWVzID0gX3NsaWNlZFRvQXJyYXkodmFsdWVzLCAyKTtcbiAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IF92YWx1ZXNbMV07XG4gICAgICB9XG4gICAgICBtYXRjaGVzLnB1c2goX29iamVjdFNwcmVhZCh7XG4gICAgICAgIHR5cGU6IFwicGxhY2Vob2xkZXJcIixcbiAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgIG1vZHVsZTogX21vZHVsZTIsXG4gICAgICAgIG9uTWF0Y2g6IHByb3BlcnRpZXMub25NYXRjaCxcbiAgICAgICAgcHJpb3JpdHk6IHByb3BlcnRpZXMucHJpb3JpdHlcbiAgICAgIH0sIHByb3BlcnRpZXMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5mdW5jdGlvbiBtb2R1bGVQYXJzZShwbGFjZUhvbGRlckNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgdmFyIG1vZHVsZXMgPSBvcHRpb25zLm1vZHVsZXM7XG4gIHZhciBzdGFydE9mZnNldCA9IG9wdGlvbnMuc3RhcnRPZmZzZXQ7XG4gIHZhciBlbmRMaW5kZXggPSBvcHRpb25zLmxJbmRleDtcbiAgdmFyIG1vZHVsZVBhcnNlZDtcbiAgb3B0aW9ucy5vZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgb3B0aW9ucy5tYXRjaCA9IG1hdGNoO1xuICBvcHRpb25zLmdldFZhbHVlID0gZ2V0VmFsdWU7XG4gIG9wdGlvbnMuZ2V0VmFsdWVzID0gZ2V0VmFsdWVzO1xuICB2YXIgbWF0Y2hlcnMgPSBnZXRNYXRjaGVycyhtb2R1bGVzLCBvcHRpb25zKTtcbiAgdmFyIG1hdGNoZXMgPSBnZXRNYXRjaGVzKG1hdGNoZXJzLCBwbGFjZUhvbGRlckNvbnRlbnQsIG9wdGlvbnMpO1xuICBpZiAobWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGJlc3RNYXRjaCA9IG51bGw7XG4gICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgbWF0Y2hlcy5sZW5ndGg7IF9pNisrKSB7XG4gICAgICB2YXIgX21hdGNoID0gbWF0Y2hlc1tfaTZdO1xuICAgICAgX21hdGNoLnByaW9yaXR5IHx8IChfbWF0Y2gucHJpb3JpdHkgPSAtX21hdGNoLnZhbHVlLmxlbmd0aCk7XG4gICAgICBpZiAoIWJlc3RNYXRjaCB8fCBfbWF0Y2gucHJpb3JpdHkgPiBiZXN0TWF0Y2gucHJpb3JpdHkpIHtcbiAgICAgICAgYmVzdE1hdGNoID0gX21hdGNoO1xuICAgICAgfVxuICAgIH1cbiAgICBiZXN0TWF0Y2gub2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gICAgZGVsZXRlIGJlc3RNYXRjaC5wcmlvcml0eTtcbiAgICBiZXN0TWF0Y2guZW5kTGluZGV4ID0gZW5kTGluZGV4O1xuICAgIGJlc3RNYXRjaC5sSW5kZXggPSBlbmRMaW5kZXg7XG4gICAgYmVzdE1hdGNoLnJhdyA9IHBsYWNlSG9sZGVyQ29udGVudDtcbiAgICBpZiAoYmVzdE1hdGNoLm9uTWF0Y2gpIHtcbiAgICAgIGJlc3RNYXRjaC5vbk1hdGNoKGJlc3RNYXRjaCk7XG4gICAgfVxuICAgIGRlbGV0ZSBiZXN0TWF0Y2gub25NYXRjaDtcbiAgICBkZWxldGUgYmVzdE1hdGNoLnByZWZpeDtcbiAgICByZXR1cm4gYmVzdE1hdGNoO1xuICB9XG4gIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IG1vZHVsZXMubGVuZ3RoOyBfaTgrKykge1xuICAgIHZhciBfbW9kdWxlMyA9IG1vZHVsZXNbX2k4XTtcbiAgICBtb2R1bGVQYXJzZWQgPSBfbW9kdWxlMy5wYXJzZShwbGFjZUhvbGRlckNvbnRlbnQsIG9wdGlvbnMpO1xuICAgIGlmIChtb2R1bGVQYXJzZWQpIHtcbiAgICAgIG1vZHVsZVBhcnNlZC5vZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICAgIG1vZHVsZVBhcnNlZC5lbmRMaW5kZXggPSBlbmRMaW5kZXg7XG4gICAgICBtb2R1bGVQYXJzZWQubEluZGV4ID0gZW5kTGluZGV4O1xuICAgICAgbW9kdWxlUGFyc2VkLnJhdyA9IHBsYWNlSG9sZGVyQ29udGVudDtcbiAgICAgIHJldHVybiBtb2R1bGVQYXJzZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJwbGFjZWhvbGRlclwiLFxuICAgIHZhbHVlOiBwbGFjZUhvbGRlckNvbnRlbnQsXG4gICAgb2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICBlbmRMaW5kZXg6IGVuZExpbmRleCxcbiAgICBsSW5kZXg6IGVuZExpbmRleFxuICB9O1xufVxudmFyIHBhcnNlciA9IHtcbiAgcHJlcGFyc2U6IGZ1bmN0aW9uIHByZXBhcnNlKHBhcnNlZCwgbW9kdWxlcywgb3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIHByZXBhcnNlKHBhcnNlZCwgb3B0aW9ucykge1xuICAgICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCBtb2R1bGVzLmxlbmd0aDsgX2kxMCsrKSB7XG4gICAgICAgIHZhciBfbW9kdWxlNCA9IG1vZHVsZXNbX2kxMF07XG4gICAgICAgIHBhcnNlZCA9IF9tb2R1bGU0LnByZXBhcnNlKHBhcnNlZCwgb3B0aW9ucykgfHwgcGFyc2VkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gICAgcmV0dXJuIHByZXBhcnNlKHBhcnNlZCwgb3B0aW9ucyk7XG4gIH0sXG4gIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShsZXhlZCwgbW9kdWxlcywgb3B0aW9ucykge1xuICAgIHZhciBpblBsYWNlSG9sZGVyID0gZmFsc2U7XG4gICAgdmFyIHBsYWNlSG9sZGVyQ29udGVudCA9IFwiXCI7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0O1xuICAgIHZhciB0YWlsUGFydHMgPSBbXTtcbiAgICB2YXIgZHJvcHBlZFRhZ3MgPSBvcHRpb25zLmZpbGVUeXBlQ29uZmlnLmRyb3BwZWRUYWdzSW5zaWRlUGxhY2Vob2xkZXIgfHwgW107XG4gICAgcmV0dXJuIGxleGVkLnJlZHVjZShmdW5jdGlvbiAocGFyc2VkLCB0b2tlbikge1xuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFwiZGVsaW1pdGVyXCIpIHtcbiAgICAgICAgaW5QbGFjZUhvbGRlciA9IHRva2VuLnBvc2l0aW9uID09PSBcInN0YXJ0XCI7XG4gICAgICAgIGlmICh0b2tlbi5wb3NpdGlvbiA9PT0gXCJlbmRcIikge1xuICAgICAgICAgIG9wdGlvbnMucGFyc2UgPSBmdW5jdGlvbiAocGxhY2VIb2xkZXJDb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlUGFyc2UocGxhY2VIb2xkZXJDb250ZW50LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHRva2VuKSwge30sIHtcbiAgICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IHN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgICBtb2R1bGVzOiBtb2R1bGVzXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBwYXJzZWQucHVzaChvcHRpb25zLnBhcnNlKHdvcmRUb1V0ZjgocGxhY2VIb2xkZXJDb250ZW50KSkpO1xuICAgICAgICAgIHB1c2hBcnJheShwYXJzZWQsIHRhaWxQYXJ0cyk7XG4gICAgICAgICAgdGFpbFBhcnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuLnBvc2l0aW9uID09PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgICB0YWlsUGFydHMgPSBbXTtcbiAgICAgICAgICBzdGFydE9mZnNldCA9IHRva2VuLm9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBwbGFjZUhvbGRlckNvbnRlbnQgPSBcIlwiO1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfVxuICAgICAgaWYgKCFpblBsYWNlSG9sZGVyKSB7XG4gICAgICAgIHBhcnNlZC5wdXNoKHRva2VuKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi50eXBlICE9PSBcImNvbnRlbnRcIiB8fCB0b2tlbi5wb3NpdGlvbiAhPT0gXCJpbnNpZGV0YWdcIikge1xuICAgICAgICBpZiAoZHJvcHBlZFRhZ3MuaW5kZXhPZih0b2tlbi50YWcpICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGFpbFBhcnRzLnB1c2godG9rZW4pO1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfVxuICAgICAgcGxhY2VIb2xkZXJDb250ZW50ICs9IHRva2VuLnZhbHVlO1xuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9LCBbXSk7XG4gIH0sXG4gIHBvc3RwYXJzZTogZnVuY3Rpb24gcG9zdHBhcnNlKHBvc3RwYXJzZWQsIG1vZHVsZXMsIG9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBnZXRUcmFpdHModHJhaXROYW1lLCBwb3N0cGFyc2VkKSB7XG4gICAgICByZXR1cm4gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgICByZXR1cm4gbW9kdWxlLmdldFRyYWl0cyh0cmFpdE5hbWUsIHBvc3RwYXJzZWQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBmdW5jdGlvbiBfcG9zdHBhcnNlKHBvc3RwYXJzZWQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAocG9zdHBhcnNlZCwgbW9kdWxlKSB7XG4gICAgICAgIHZhciByID0gbW9kdWxlLnBvc3RwYXJzZShwb3N0cGFyc2VkLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIHBvc3RwYXJzZTogZnVuY3Rpb24gcG9zdHBhcnNlKHBhcnNlZCwgb3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIF9wb3N0cGFyc2UocGFyc2VkLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCBvcHRzKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXRUcmFpdHM6IGdldFRyYWl0c1xuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChyID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcG9zdHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoci5lcnJvcnMpIHtcbiAgICAgICAgICBwdXNoQXJyYXkoZXJyb3JzLCByLmVycm9ycyk7XG4gICAgICAgICAgcmV0dXJuIHIucG9zdHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH0sIHBvc3RwYXJzZWQpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcG9zdHBhcnNlZDogX3Bvc3RwYXJzZShwb3N0cGFyc2VkLCBvcHRpb25zKSxcbiAgICAgIGVycm9yczogZXJyb3JzXG4gICAgfTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gcGFyc2VyOyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJvd25LZXlzIiwiZSIsInIiLCJ0IiwiT2JqZWN0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJpIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiX3NsaWNlZFRvQXJyYXkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiYSIsIl9hcnJheUxpa2VUb0FycmF5IiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwibiIsImwiLCJ1IiwiZiIsIm5leHQiLCJkb25lIiwiaXNBcnJheSIsIl9yZXF1aXJlIiwicmVxdWlyZSIsIndvcmRUb1V0ZjgiLCJwdXNoQXJyYXkiLCJfcmVxdWlyZTIiLCJtYXRjaCIsImdldFZhbHVlIiwiZ2V0VmFsdWVzIiwiZ2V0TWF0Y2hlcnMiLCJtb2R1bGVzIiwib3B0aW9ucyIsImFsbE1hdGNoZXJzIiwiX2kyIiwiX21vZHVsZSIsIm1hdGNoZXJzIiwiRXJyb3IiLCJnZXRNYXRjaGVzIiwicGxhY2VIb2xkZXJDb250ZW50IiwibWF0Y2hlcyIsIl9pNCIsIm1hdGNoZXIiLCJfbWF0Y2hlciIsInByZWZpeCIsIl9tb2R1bGUyIiwicHJvcGVydGllcyIsInZhbHVlcyIsIl92YWx1ZXMiLCJ0eXBlIiwibW9kdWxlIiwib25NYXRjaCIsInByaW9yaXR5IiwibW9kdWxlUGFyc2UiLCJzdGFydE9mZnNldCIsImVuZExpbmRleCIsImxJbmRleCIsIm1vZHVsZVBhcnNlZCIsIm9mZnNldCIsImJlc3RNYXRjaCIsIl9pNiIsIl9tYXRjaCIsInJhdyIsIl9pOCIsIl9tb2R1bGUzIiwicGFyc2UiLCJwYXJzZXIiLCJwcmVwYXJzZSIsInBhcnNlZCIsIl9pMTAiLCJfbW9kdWxlNCIsImxleGVkIiwiaW5QbGFjZUhvbGRlciIsInRhaWxQYXJ0cyIsImRyb3BwZWRUYWdzIiwiZmlsZVR5cGVDb25maWciLCJkcm9wcGVkVGFnc0luc2lkZVBsYWNlaG9sZGVyIiwicmVkdWNlIiwidG9rZW4iLCJwb3NpdGlvbiIsImluZGV4T2YiLCJ0YWciLCJwb3N0cGFyc2UiLCJwb3N0cGFyc2VkIiwiZ2V0VHJhaXRzIiwidHJhaXROYW1lIiwibWFwIiwiZXJyb3JzIiwiX3Bvc3RwYXJzZSIsIm9wdHMiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/postrender.js":
/*!*****************************************************!*\
  !*** ./node_modules/docxtemplater/js/postrender.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n/*\n * Convert string to array (typed, when possible)\n * Stryker disable all : because this is a utility function that was copied\n * from\n * https://github.com/open-xml-templating/pizzip/blob/34a840553c604980859dc6d0dcd1f89b6e5527b3/es6/utf8.js#L33\n */ function string2buf(str) {\n    var c, c2, mPos, i, bufLen = 0;\n    var strLen = str.length;\n    // count binary size\n    for(mPos = 0; mPos < strLen; mPos++){\n        c = str.charCodeAt(mPos);\n        if ((c & 0xfc00) === 0xd800 && mPos + 1 < strLen) {\n            c2 = str.charCodeAt(mPos + 1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n                mPos++;\n            }\n        }\n        bufLen += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n    // allocate buffer\n    var buf = new Uint8Array(bufLen);\n    // convert\n    for(i = 0, mPos = 0; i < bufLen; mPos++){\n        c = str.charCodeAt(mPos);\n        if ((c & 0xfc00) === 0xd800 && mPos + 1 < strLen) {\n            c2 = str.charCodeAt(mPos + 1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n                mPos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */ buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */ buf[i++] = 0xc0 | c >>> 6;\n            buf[i++] = 0x80 | c & 0x3f;\n        } else if (c < 0x10000) {\n            /* three bytes */ buf[i++] = 0xe0 | c >>> 12;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n        } else {\n            /* four bytes */ buf[i++] = 0xf0 | c >>> 18;\n            buf[i++] = 0x80 | c >>> 12 & 0x3f;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n        }\n    }\n    return buf;\n}\n// Stryker restore all\nfunction postrender(parts, options) {\n    for(var _i2 = 0, _options$modules2 = options.modules; _i2 < _options$modules2.length; _i2++){\n        var _module = _options$modules2[_i2];\n        parts = _module.postrender(parts, options);\n    }\n    var fullLength = 0;\n    var newParts = options.joinUncorrupt(parts, options);\n    var longStr = \"\";\n    var lenStr = 0;\n    var maxCompact = 65536;\n    var uintArrays = [];\n    for(var i = 0, len = newParts.length; i < len; i++){\n        var part = newParts[i];\n        /*\n     * This condition should be hit in the integration test at :\n     * it(\"should not regress with long file (hit maxCompact value of 65536)\", function () {\n     * Stryker disable all : because this is an optimisation that won't make any tests fail\n     */ if (part.length + lenStr > maxCompact) {\n            var _arr = string2buf(longStr);\n            fullLength += _arr.length;\n            uintArrays.push(_arr);\n            longStr = \"\";\n        }\n        // Stryker restore all\n        longStr += part;\n        lenStr += part.length;\n        delete newParts[i];\n    }\n    var arr = string2buf(longStr);\n    fullLength += arr.length;\n    uintArrays.push(arr);\n    var array = new Uint8Array(fullLength);\n    var j = 0;\n    // Stryker disable all : because this is an optimisation that won't make any tests fail\n    for(var _i4 = 0; _i4 < uintArrays.length; _i4++){\n        var buf = uintArrays[_i4];\n        for(var _i5 = 0; _i5 < buf.length; ++_i5){\n            array[_i5 + j] = buf[_i5];\n        }\n        j += buf.length;\n    } // Stryker restore all\n    return array;\n}\nmodule.exports = postrender;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9wb3N0cmVuZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWI7Ozs7O0NBS0MsR0FDRCxTQUFTQSxXQUFXQyxHQUFHO0lBQ3JCLElBQUlDLEdBQ0ZDLElBQ0FDLE1BQ0FDLEdBQ0FDLFNBQVM7SUFDWCxJQUFJQyxTQUFTTixJQUFJTyxNQUFNO0lBRXZCLG9CQUFvQjtJQUNwQixJQUFLSixPQUFPLEdBQUdBLE9BQU9HLFFBQVFILE9BQVE7UUFDcENGLElBQUlELElBQUlRLFVBQVUsQ0FBQ0w7UUFDbkIsSUFBSSxDQUFDRixJQUFJLE1BQUssTUFBTyxVQUFVRSxPQUFPLElBQUlHLFFBQVE7WUFDaERKLEtBQUtGLElBQUlRLFVBQVUsQ0FBQ0wsT0FBTztZQUMzQixJQUFJLENBQUNELEtBQUssTUFBSyxNQUFPLFFBQVE7Z0JBQzVCRCxJQUFJLFVBQVdBLENBQUFBLElBQUksVUFBVSxFQUFDLElBQU1DLENBQUFBLEtBQUssTUFBSztnQkFDOUNDO1lBQ0Y7UUFDRjtRQUNBRSxVQUFVSixJQUFJLE9BQU8sSUFBSUEsSUFBSSxRQUFRLElBQUlBLElBQUksVUFBVSxJQUFJO0lBQzdEO0lBRUEsa0JBQWtCO0lBQ2xCLElBQUlRLE1BQU0sSUFBSUMsV0FBV0w7SUFFekIsVUFBVTtJQUNWLElBQUtELElBQUksR0FBR0QsT0FBTyxHQUFHQyxJQUFJQyxRQUFRRixPQUFRO1FBQ3hDRixJQUFJRCxJQUFJUSxVQUFVLENBQUNMO1FBQ25CLElBQUksQ0FBQ0YsSUFBSSxNQUFLLE1BQU8sVUFBVUUsT0FBTyxJQUFJRyxRQUFRO1lBQ2hESixLQUFLRixJQUFJUSxVQUFVLENBQUNMLE9BQU87WUFDM0IsSUFBSSxDQUFDRCxLQUFLLE1BQUssTUFBTyxRQUFRO2dCQUM1QkQsSUFBSSxVQUFXQSxDQUFBQSxJQUFJLFVBQVUsRUFBQyxJQUFNQyxDQUFBQSxLQUFLLE1BQUs7Z0JBQzlDQztZQUNGO1FBQ0Y7UUFDQSxJQUFJRixJQUFJLE1BQU07WUFDWixZQUFZLEdBQ1pRLEdBQUcsQ0FBQ0wsSUFBSSxHQUFHSDtRQUNiLE9BQU8sSUFBSUEsSUFBSSxPQUFPO1lBQ3BCLGFBQWEsR0FDYlEsR0FBRyxDQUFDTCxJQUFJLEdBQUcsT0FBT0gsTUFBTTtZQUN4QlEsR0FBRyxDQUFDTCxJQUFJLEdBQUcsT0FBT0gsSUFBSTtRQUN4QixPQUFPLElBQUlBLElBQUksU0FBUztZQUN0QixlQUFlLEdBQ2ZRLEdBQUcsQ0FBQ0wsSUFBSSxHQUFHLE9BQU9ILE1BQU07WUFDeEJRLEdBQUcsQ0FBQ0wsSUFBSSxHQUFHLE9BQU9ILE1BQU0sSUFBSTtZQUM1QlEsR0FBRyxDQUFDTCxJQUFJLEdBQUcsT0FBT0gsSUFBSTtRQUN4QixPQUFPO1lBQ0wsY0FBYyxHQUNkUSxHQUFHLENBQUNMLElBQUksR0FBRyxPQUFPSCxNQUFNO1lBQ3hCUSxHQUFHLENBQUNMLElBQUksR0FBRyxPQUFPSCxNQUFNLEtBQUs7WUFDN0JRLEdBQUcsQ0FBQ0wsSUFBSSxHQUFHLE9BQU9ILE1BQU0sSUFBSTtZQUM1QlEsR0FBRyxDQUFDTCxJQUFJLEdBQUcsT0FBT0gsSUFBSTtRQUN4QjtJQUNGO0lBQ0EsT0FBT1E7QUFDVDtBQUNBLHNCQUFzQjtBQUV0QixTQUFTRSxXQUFXQyxLQUFLLEVBQUVDLE9BQU87SUFDaEMsSUFBSyxJQUFJQyxNQUFNLEdBQUdDLG9CQUFvQkYsUUFBUUcsT0FBTyxFQUFFRixNQUFNQyxrQkFBa0JSLE1BQU0sRUFBRU8sTUFBTztRQUM1RixJQUFJRyxVQUFVRixpQkFBaUIsQ0FBQ0QsSUFBSTtRQUNwQ0YsUUFBUUssUUFBUU4sVUFBVSxDQUFDQyxPQUFPQztJQUNwQztJQUNBLElBQUlLLGFBQWE7SUFDakIsSUFBSUMsV0FBV04sUUFBUU8sYUFBYSxDQUFDUixPQUFPQztJQUM1QyxJQUFJUSxVQUFVO0lBQ2QsSUFBSUMsU0FBUztJQUNiLElBQUlDLGFBQWE7SUFDakIsSUFBSUMsYUFBYSxFQUFFO0lBQ25CLElBQUssSUFBSXBCLElBQUksR0FBR3FCLE1BQU1OLFNBQVNaLE1BQU0sRUFBRUgsSUFBSXFCLEtBQUtyQixJQUFLO1FBQ25ELElBQUlzQixPQUFPUCxRQUFRLENBQUNmLEVBQUU7UUFFdEI7Ozs7S0FJQyxHQUNELElBQUlzQixLQUFLbkIsTUFBTSxHQUFHZSxTQUFTQyxZQUFZO1lBQ3JDLElBQUlJLE9BQU81QixXQUFXc0I7WUFDdEJILGNBQWNTLEtBQUtwQixNQUFNO1lBQ3pCaUIsV0FBV0ksSUFBSSxDQUFDRDtZQUNoQk4sVUFBVTtRQUNaO1FBQ0Esc0JBQXNCO1FBRXRCQSxXQUFXSztRQUNYSixVQUFVSSxLQUFLbkIsTUFBTTtRQUNyQixPQUFPWSxRQUFRLENBQUNmLEVBQUU7SUFDcEI7SUFDQSxJQUFJeUIsTUFBTTlCLFdBQVdzQjtJQUNyQkgsY0FBY1csSUFBSXRCLE1BQU07SUFDeEJpQixXQUFXSSxJQUFJLENBQUNDO0lBQ2hCLElBQUlDLFFBQVEsSUFBSXBCLFdBQVdRO0lBQzNCLElBQUlhLElBQUk7SUFFUix1RkFBdUY7SUFDdkYsSUFBSyxJQUFJQyxNQUFNLEdBQUdBLE1BQU1SLFdBQVdqQixNQUFNLEVBQUV5QixNQUFPO1FBQ2hELElBQUl2QixNQUFNZSxVQUFVLENBQUNRLElBQUk7UUFDekIsSUFBSyxJQUFJQyxNQUFNLEdBQUdBLE1BQU14QixJQUFJRixNQUFNLEVBQUUsRUFBRTBCLElBQUs7WUFDekNILEtBQUssQ0FBQ0csTUFBTUYsRUFBRSxHQUFHdEIsR0FBRyxDQUFDd0IsSUFBSTtRQUMzQjtRQUNBRixLQUFLdEIsSUFBSUYsTUFBTTtJQUNqQixFQUFFLHNCQUFzQjtJQUN4QixPQUFPdUI7QUFDVDtBQUNBSSxPQUFPQyxPQUFPLEdBQUd4QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Jpa2UtcmVudGFsLXdlYnNpdGUvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9wb3N0cmVuZGVyLmpzP2Q0OWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gKiBDb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG4gKiBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSB0aGlzIGlzIGEgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IHdhcyBjb3BpZWRcbiAqIGZyb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLXhtbC10ZW1wbGF0aW5nL3BpenppcC9ibG9iLzM0YTg0MDU1M2M2MDQ5ODA4NTlkYzZkMGRjZDFmODliNmU1NTI3YjMvZXM2L3V0ZjguanMjTDMzXG4gKi9cbmZ1bmN0aW9uIHN0cmluZzJidWYoc3RyKSB7XG4gIHZhciBjLFxuICAgIGMyLFxuICAgIG1Qb3MsXG4gICAgaSxcbiAgICBidWZMZW4gPSAwO1xuICB2YXIgc3RyTGVuID0gc3RyLmxlbmd0aDtcblxuICAvLyBjb3VudCBiaW5hcnkgc2l6ZVxuICBmb3IgKG1Qb3MgPSAwOyBtUG9zIDwgc3RyTGVuOyBtUG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobVBvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIG1Qb3MgKyAxIDwgc3RyTGVuKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1Qb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoYyAtIDB4ZDgwMCA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtUG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1ZkxlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgfVxuXG4gIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmTGVuKTtcblxuICAvLyBjb252ZXJ0XG4gIGZvciAoaSA9IDAsIG1Qb3MgPSAwOyBpIDwgYnVmTGVuOyBtUG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobVBvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIG1Qb3MgKyAxIDwgc3RyTGVuKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1Qb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoYyAtIDB4ZDgwMCA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtUG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgIGJ1ZltpKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4YzAgfCBjID4+PiA2O1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgYyAmIDB4M2Y7XG4gICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgLyogdGhyZWUgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhlMCB8IGMgPj4+IDEyO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgYyA+Pj4gNiAmIDB4M2Y7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCBjICYgMHgzZjtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweGYwIHwgYyA+Pj4gMTg7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCBjID4+PiAxMiAmIDB4M2Y7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCBjID4+PiA2ICYgMHgzZjtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IGMgJiAweDNmO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYnVmO1xufVxuLy8gU3RyeWtlciByZXN0b3JlIGFsbFxuXG5mdW5jdGlvbiBwb3N0cmVuZGVyKHBhcnRzLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIF9pMiA9IDAsIF9vcHRpb25zJG1vZHVsZXMyID0gb3B0aW9ucy5tb2R1bGVzOyBfaTIgPCBfb3B0aW9ucyRtb2R1bGVzMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9tb2R1bGUgPSBfb3B0aW9ucyRtb2R1bGVzMltfaTJdO1xuICAgIHBhcnRzID0gX21vZHVsZS5wb3N0cmVuZGVyKHBhcnRzLCBvcHRpb25zKTtcbiAgfVxuICB2YXIgZnVsbExlbmd0aCA9IDA7XG4gIHZhciBuZXdQYXJ0cyA9IG9wdGlvbnMuam9pblVuY29ycnVwdChwYXJ0cywgb3B0aW9ucyk7XG4gIHZhciBsb25nU3RyID0gXCJcIjtcbiAgdmFyIGxlblN0ciA9IDA7XG4gIHZhciBtYXhDb21wYWN0ID0gNjU1MzY7XG4gIHZhciB1aW50QXJyYXlzID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBuZXdQYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwYXJ0ID0gbmV3UGFydHNbaV07XG5cbiAgICAvKlxuICAgICAqIFRoaXMgY29uZGl0aW9uIHNob3VsZCBiZSBoaXQgaW4gdGhlIGludGVncmF0aW9uIHRlc3QgYXQgOlxuICAgICAqIGl0KFwic2hvdWxkIG5vdCByZWdyZXNzIHdpdGggbG9uZyBmaWxlIChoaXQgbWF4Q29tcGFjdCB2YWx1ZSBvZiA2NTUzNilcIiwgZnVuY3Rpb24gKCkge1xuICAgICAqIFN0cnlrZXIgZGlzYWJsZSBhbGwgOiBiZWNhdXNlIHRoaXMgaXMgYW4gb3B0aW1pc2F0aW9uIHRoYXQgd29uJ3QgbWFrZSBhbnkgdGVzdHMgZmFpbFxuICAgICAqL1xuICAgIGlmIChwYXJ0Lmxlbmd0aCArIGxlblN0ciA+IG1heENvbXBhY3QpIHtcbiAgICAgIHZhciBfYXJyID0gc3RyaW5nMmJ1Zihsb25nU3RyKTtcbiAgICAgIGZ1bGxMZW5ndGggKz0gX2Fyci5sZW5ndGg7XG4gICAgICB1aW50QXJyYXlzLnB1c2goX2Fycik7XG4gICAgICBsb25nU3RyID0gXCJcIjtcbiAgICB9XG4gICAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxuXG4gICAgbG9uZ1N0ciArPSBwYXJ0O1xuICAgIGxlblN0ciArPSBwYXJ0Lmxlbmd0aDtcbiAgICBkZWxldGUgbmV3UGFydHNbaV07XG4gIH1cbiAgdmFyIGFyciA9IHN0cmluZzJidWYobG9uZ1N0cik7XG4gIGZ1bGxMZW5ndGggKz0gYXJyLmxlbmd0aDtcbiAgdWludEFycmF5cy5wdXNoKGFycik7XG4gIHZhciBhcnJheSA9IG5ldyBVaW50OEFycmF5KGZ1bGxMZW5ndGgpO1xuICB2YXIgaiA9IDA7XG5cbiAgLy8gU3RyeWtlciBkaXNhYmxlIGFsbCA6IGJlY2F1c2UgdGhpcyBpcyBhbiBvcHRpbWlzYXRpb24gdGhhdCB3b24ndCBtYWtlIGFueSB0ZXN0cyBmYWlsXG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHVpbnRBcnJheXMubGVuZ3RoOyBfaTQrKykge1xuICAgIHZhciBidWYgPSB1aW50QXJyYXlzW19pNF07XG4gICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgYnVmLmxlbmd0aDsgKytfaTUpIHtcbiAgICAgIGFycmF5W19pNSArIGpdID0gYnVmW19pNV07XG4gICAgfVxuICAgIGogKz0gYnVmLmxlbmd0aDtcbiAgfSAvLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG4gIHJldHVybiBhcnJheTtcbn1cbm1vZHVsZS5leHBvcnRzID0gcG9zdHJlbmRlcjsiXSwibmFtZXMiOlsic3RyaW5nMmJ1ZiIsInN0ciIsImMiLCJjMiIsIm1Qb3MiLCJpIiwiYnVmTGVuIiwic3RyTGVuIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsImJ1ZiIsIlVpbnQ4QXJyYXkiLCJwb3N0cmVuZGVyIiwicGFydHMiLCJvcHRpb25zIiwiX2kyIiwiX29wdGlvbnMkbW9kdWxlczIiLCJtb2R1bGVzIiwiX21vZHVsZSIsImZ1bGxMZW5ndGgiLCJuZXdQYXJ0cyIsImpvaW5VbmNvcnJ1cHQiLCJsb25nU3RyIiwibGVuU3RyIiwibWF4Q29tcGFjdCIsInVpbnRBcnJheXMiLCJsZW4iLCJwYXJ0IiwiX2FyciIsInB1c2giLCJhcnIiLCJhcnJheSIsImoiLCJfaTQiLCJfaTUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/postrender.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/prefix-matcher.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/prefix-matcher.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nvar nbspRegex = new RegExp(String.fromCharCode(160), \"g\");\nfunction replaceNbsps(str) {\n    return str.replace(nbspRegex, \" \");\n}\nfunction match(condition, placeHolderContent) {\n    var type = _typeof(condition);\n    if (type === \"string\") {\n        return replaceNbsps(placeHolderContent.substr(0, condition.length)) === condition;\n    }\n    if (condition instanceof RegExp) {\n        return condition.test(replaceNbsps(placeHolderContent));\n    }\n    if (type === \"function\") {\n        return !!condition(placeHolderContent);\n    }\n}\nfunction getValue(condition, placeHolderContent) {\n    var type = _typeof(condition);\n    if (type === \"string\") {\n        return replaceNbsps(placeHolderContent).substr(condition.length);\n    }\n    if (condition instanceof RegExp) {\n        return replaceNbsps(placeHolderContent).match(condition)[1];\n    }\n    if (type === \"function\") {\n        return condition(placeHolderContent);\n    }\n}\nfunction getValues(condition, placeHolderContent) {\n    var type = _typeof(condition);\n    if (type === \"string\") {\n        return [\n            placeHolderContent,\n            replaceNbsps(placeHolderContent).substr(condition.length)\n        ];\n    }\n    if (condition instanceof RegExp) {\n        return replaceNbsps(placeHolderContent).match(condition);\n    }\n    if (type === \"function\") {\n        return [\n            placeHolderContent,\n            condition(placeHolderContent)\n        ];\n    }\n}\nmodule.exports = {\n    match: match,\n    getValue: getValue,\n    getValues: getValues\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9wcmVmaXgtbWF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLFFBQVFDLENBQUM7SUFBSTtJQUEyQixPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixDQUFDO1FBQUksT0FBTyxPQUFPQTtJQUFHLElBQUksU0FBVUEsQ0FBQztRQUFJLE9BQU9BLEtBQUssY0FBYyxPQUFPQyxVQUFVRCxFQUFFRyxXQUFXLEtBQUtGLFVBQVVELE1BQU1DLE9BQU9HLFNBQVMsR0FBRyxXQUFXLE9BQU9KO0lBQUcsR0FBR0QsUUFBUUM7QUFBSTtBQUM3VCxJQUFJSyxZQUFZLElBQUlDLE9BQU9DLE9BQU9DLFlBQVksQ0FBQyxNQUFNO0FBQ3JELFNBQVNDLGFBQWFDLEdBQUc7SUFDdkIsT0FBT0EsSUFBSUMsT0FBTyxDQUFDTixXQUFXO0FBQ2hDO0FBQ0EsU0FBU08sTUFBTUMsU0FBUyxFQUFFQyxrQkFBa0I7SUFDMUMsSUFBSUMsT0FBT2hCLFFBQVFjO0lBQ25CLElBQUlFLFNBQVMsVUFBVTtRQUNyQixPQUFPTixhQUFhSyxtQkFBbUJFLE1BQU0sQ0FBQyxHQUFHSCxVQUFVSSxNQUFNLE9BQU9KO0lBQzFFO0lBQ0EsSUFBSUEscUJBQXFCUCxRQUFRO1FBQy9CLE9BQU9PLFVBQVVLLElBQUksQ0FBQ1QsYUFBYUs7SUFDckM7SUFDQSxJQUFJQyxTQUFTLFlBQVk7UUFDdkIsT0FBTyxDQUFDLENBQUNGLFVBQVVDO0lBQ3JCO0FBQ0Y7QUFDQSxTQUFTSyxTQUFTTixTQUFTLEVBQUVDLGtCQUFrQjtJQUM3QyxJQUFJQyxPQUFPaEIsUUFBUWM7SUFDbkIsSUFBSUUsU0FBUyxVQUFVO1FBQ3JCLE9BQU9OLGFBQWFLLG9CQUFvQkUsTUFBTSxDQUFDSCxVQUFVSSxNQUFNO0lBQ2pFO0lBQ0EsSUFBSUoscUJBQXFCUCxRQUFRO1FBQy9CLE9BQU9HLGFBQWFLLG9CQUFvQkYsS0FBSyxDQUFDQyxVQUFVLENBQUMsRUFBRTtJQUM3RDtJQUNBLElBQUlFLFNBQVMsWUFBWTtRQUN2QixPQUFPRixVQUFVQztJQUNuQjtBQUNGO0FBQ0EsU0FBU00sVUFBVVAsU0FBUyxFQUFFQyxrQkFBa0I7SUFDOUMsSUFBSUMsT0FBT2hCLFFBQVFjO0lBQ25CLElBQUlFLFNBQVMsVUFBVTtRQUNyQixPQUFPO1lBQUNEO1lBQW9CTCxhQUFhSyxvQkFBb0JFLE1BQU0sQ0FBQ0gsVUFBVUksTUFBTTtTQUFFO0lBQ3hGO0lBQ0EsSUFBSUoscUJBQXFCUCxRQUFRO1FBQy9CLE9BQU9HLGFBQWFLLG9CQUFvQkYsS0FBSyxDQUFDQztJQUNoRDtJQUNBLElBQUlFLFNBQVMsWUFBWTtRQUN2QixPQUFPO1lBQUNEO1lBQW9CRCxVQUFVQztTQUFvQjtJQUM1RDtBQUNGO0FBQ0FPLE9BQU9DLE9BQU8sR0FBRztJQUNmVixPQUFPQTtJQUNQTyxVQUFVQTtJQUNWQyxXQUFXQTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlrZS1yZW50YWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL3ByZWZpeC1tYXRjaGVyLmpzPzczNzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbnZhciBuYnNwUmVnZXggPSBuZXcgUmVnRXhwKFN0cmluZy5mcm9tQ2hhckNvZGUoMTYwKSwgXCJnXCIpO1xuZnVuY3Rpb24gcmVwbGFjZU5ic3BzKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UobmJzcFJlZ2V4LCBcIiBcIik7XG59XG5mdW5jdGlvbiBtYXRjaChjb25kaXRpb24sIHBsYWNlSG9sZGVyQ29udGVudCkge1xuICB2YXIgdHlwZSA9IF90eXBlb2YoY29uZGl0aW9uKTtcbiAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gcmVwbGFjZU5ic3BzKHBsYWNlSG9sZGVyQ29udGVudC5zdWJzdHIoMCwgY29uZGl0aW9uLmxlbmd0aCkpID09PSBjb25kaXRpb247XG4gIH1cbiAgaWYgKGNvbmRpdGlvbiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBjb25kaXRpb24udGVzdChyZXBsYWNlTmJzcHMocGxhY2VIb2xkZXJDb250ZW50KSk7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiAhIWNvbmRpdGlvbihwbGFjZUhvbGRlckNvbnRlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRWYWx1ZShjb25kaXRpb24sIHBsYWNlSG9sZGVyQ29udGVudCkge1xuICB2YXIgdHlwZSA9IF90eXBlb2YoY29uZGl0aW9uKTtcbiAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gcmVwbGFjZU5ic3BzKHBsYWNlSG9sZGVyQ29udGVudCkuc3Vic3RyKGNvbmRpdGlvbi5sZW5ndGgpO1xuICB9XG4gIGlmIChjb25kaXRpb24gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVwbGFjZU5ic3BzKHBsYWNlSG9sZGVyQ29udGVudCkubWF0Y2goY29uZGl0aW9uKVsxXTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGNvbmRpdGlvbihwbGFjZUhvbGRlckNvbnRlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRWYWx1ZXMoY29uZGl0aW9uLCBwbGFjZUhvbGRlckNvbnRlbnQpIHtcbiAgdmFyIHR5cGUgPSBfdHlwZW9mKGNvbmRpdGlvbik7XG4gIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFtwbGFjZUhvbGRlckNvbnRlbnQsIHJlcGxhY2VOYnNwcyhwbGFjZUhvbGRlckNvbnRlbnQpLnN1YnN0cihjb25kaXRpb24ubGVuZ3RoKV07XG4gIH1cbiAgaWYgKGNvbmRpdGlvbiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZXBsYWNlTmJzcHMocGxhY2VIb2xkZXJDb250ZW50KS5tYXRjaChjb25kaXRpb24pO1xuICB9XG4gIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gW3BsYWNlSG9sZGVyQ29udGVudCwgY29uZGl0aW9uKHBsYWNlSG9sZGVyQ29udGVudCldO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWF0Y2g6IG1hdGNoLFxuICBnZXRWYWx1ZTogZ2V0VmFsdWUsXG4gIGdldFZhbHVlczogZ2V0VmFsdWVzXG59OyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJuYnNwUmVnZXgiLCJSZWdFeHAiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJyZXBsYWNlTmJzcHMiLCJzdHIiLCJyZXBsYWNlIiwibWF0Y2giLCJjb25kaXRpb24iLCJwbGFjZUhvbGRlckNvbnRlbnQiLCJ0eXBlIiwic3Vic3RyIiwibGVuZ3RoIiwidGVzdCIsImdldFZhbHVlIiwiZ2V0VmFsdWVzIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/prefix-matcher.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/render.js":
/*!*************************************************!*\
  !*** ./node_modules/docxtemplater/js/render.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar _require = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\"), throwUnimplementedTagType = _require.throwUnimplementedTagType, XTScopeParserError = _require.XTScopeParserError;\nvar _require2 = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"), pushArray = _require2.pushArray;\nvar getResolvedId = __webpack_require__(/*! ./get-resolved-id.js */ \"(rsc)/./node_modules/docxtemplater/js/get-resolved-id.js\");\nfunction moduleRender(part, options) {\n    for(var _i2 = 0, _options$modules2 = options.modules; _i2 < _options$modules2.length; _i2++){\n        var _module = _options$modules2[_i2];\n        var moduleRendered = _module.render(part, options);\n        if (moduleRendered) {\n            return moduleRendered;\n        }\n    }\n    return false;\n}\nfunction render(options) {\n    var baseNullGetter = options.baseNullGetter;\n    var compiled = options.compiled, scopeManager = options.scopeManager;\n    options.nullGetter = function(part, sm) {\n        return baseNullGetter(part, sm || scopeManager);\n    };\n    var errors = [];\n    var parts = [];\n    for(var i = 0, len = compiled.length; i < len; i++){\n        var part = compiled[i];\n        options.index = i;\n        options.resolvedId = getResolvedId(part, options);\n        var moduleRendered = void 0;\n        try {\n            moduleRendered = moduleRender(part, options);\n        } catch (e) {\n            if (e instanceof XTScopeParserError) {\n                errors.push(e);\n                parts.push(part);\n                continue;\n            }\n            throw e;\n        }\n        if (moduleRendered) {\n            if (moduleRendered.errors) {\n                pushArray(errors, moduleRendered.errors);\n            }\n            parts.push(moduleRendered);\n            continue;\n        }\n        if (part.type === \"content\" || part.type === \"tag\") {\n            parts.push(part);\n            continue;\n        }\n        throwUnimplementedTagType(part, i);\n    }\n    // This is done in two steps because for some files, it is possible to #edit-value-backwards\n    var totalParts = [];\n    for(var _i4 = 0; _i4 < parts.length; _i4++){\n        var value = parts[_i4].value;\n        if (value instanceof Array) {\n            pushArray(totalParts, value);\n        } else if (value) {\n            totalParts.push(value);\n        }\n    }\n    return {\n        errors: errors,\n        parts: totalParts\n    };\n}\nmodule.exports = render;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9yZW5kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixJQUFJQSxXQUFXQyxtQkFBT0EsQ0FBQyxvRUFBYSxHQUNsQ0MsNEJBQTRCRixTQUFTRSx5QkFBeUIsRUFDOURDLHFCQUFxQkgsU0FBU0csa0JBQWtCO0FBQ2xELElBQUlDLFlBQVlILG1CQUFPQSxDQUFDLDBFQUFnQixHQUN0Q0ksWUFBWUQsVUFBVUMsU0FBUztBQUNqQyxJQUFJQyxnQkFBZ0JMLG1CQUFPQSxDQUFDLHNGQUFzQjtBQUNsRCxTQUFTTSxhQUFhQyxJQUFJLEVBQUVDLE9BQU87SUFDakMsSUFBSyxJQUFJQyxNQUFNLEdBQUdDLG9CQUFvQkYsUUFBUUcsT0FBTyxFQUFFRixNQUFNQyxrQkFBa0JFLE1BQU0sRUFBRUgsTUFBTztRQUM1RixJQUFJSSxVQUFVSCxpQkFBaUIsQ0FBQ0QsSUFBSTtRQUNwQyxJQUFJSyxpQkFBaUJELFFBQVFFLE1BQU0sQ0FBQ1IsTUFBTUM7UUFDMUMsSUFBSU0sZ0JBQWdCO1lBQ2xCLE9BQU9BO1FBQ1Q7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVNDLE9BQU9QLE9BQU87SUFDckIsSUFBSVEsaUJBQWlCUixRQUFRUSxjQUFjO0lBQzNDLElBQUlDLFdBQVdULFFBQVFTLFFBQVEsRUFDN0JDLGVBQWVWLFFBQVFVLFlBQVk7SUFDckNWLFFBQVFXLFVBQVUsR0FBRyxTQUFVWixJQUFJLEVBQUVhLEVBQUU7UUFDckMsT0FBT0osZUFBZVQsTUFBTWEsTUFBTUY7SUFDcEM7SUFDQSxJQUFJRyxTQUFTLEVBQUU7SUFDZixJQUFJQyxRQUFRLEVBQUU7SUFDZCxJQUFLLElBQUlDLElBQUksR0FBR0MsTUFBTVAsU0FBU0wsTUFBTSxFQUFFVyxJQUFJQyxLQUFLRCxJQUFLO1FBQ25ELElBQUloQixPQUFPVSxRQUFRLENBQUNNLEVBQUU7UUFDdEJmLFFBQVFpQixLQUFLLEdBQUdGO1FBQ2hCZixRQUFRa0IsVUFBVSxHQUFHckIsY0FBY0UsTUFBTUM7UUFDekMsSUFBSU0saUJBQWlCLEtBQUs7UUFDMUIsSUFBSTtZQUNGQSxpQkFBaUJSLGFBQWFDLE1BQU1DO1FBQ3RDLEVBQUUsT0FBT21CLEdBQUc7WUFDVixJQUFJQSxhQUFhekIsb0JBQW9CO2dCQUNuQ21CLE9BQU9PLElBQUksQ0FBQ0Q7Z0JBQ1pMLE1BQU1NLElBQUksQ0FBQ3JCO2dCQUNYO1lBQ0Y7WUFDQSxNQUFNb0I7UUFDUjtRQUNBLElBQUliLGdCQUFnQjtZQUNsQixJQUFJQSxlQUFlTyxNQUFNLEVBQUU7Z0JBQ3pCakIsVUFBVWlCLFFBQVFQLGVBQWVPLE1BQU07WUFDekM7WUFDQUMsTUFBTU0sSUFBSSxDQUFDZDtZQUNYO1FBQ0Y7UUFDQSxJQUFJUCxLQUFLc0IsSUFBSSxLQUFLLGFBQWF0QixLQUFLc0IsSUFBSSxLQUFLLE9BQU87WUFDbERQLE1BQU1NLElBQUksQ0FBQ3JCO1lBQ1g7UUFDRjtRQUNBTiwwQkFBMEJNLE1BQU1nQjtJQUNsQztJQUVBLDRGQUE0RjtJQUM1RixJQUFJTyxhQUFhLEVBQUU7SUFDbkIsSUFBSyxJQUFJQyxNQUFNLEdBQUdBLE1BQU1ULE1BQU1WLE1BQU0sRUFBRW1CLE1BQU87UUFDM0MsSUFBSUMsUUFBUVYsS0FBSyxDQUFDUyxJQUFJLENBQUNDLEtBQUs7UUFDNUIsSUFBSUEsaUJBQWlCQyxPQUFPO1lBQzFCN0IsVUFBVTBCLFlBQVlFO1FBQ3hCLE9BQU8sSUFBSUEsT0FBTztZQUNoQkYsV0FBV0YsSUFBSSxDQUFDSTtRQUNsQjtJQUNGO0lBQ0EsT0FBTztRQUNMWCxRQUFRQTtRQUNSQyxPQUFPUTtJQUNUO0FBQ0Y7QUFDQUksT0FBT0MsT0FBTyxHQUFHcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaWtlLXJlbnRhbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcmVuZGVyLmpzP2Y4YTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKSxcbiAgdGhyb3dVbmltcGxlbWVudGVkVGFnVHlwZSA9IF9yZXF1aXJlLnRocm93VW5pbXBsZW1lbnRlZFRhZ1R5cGUsXG4gIFhUU2NvcGVQYXJzZXJFcnJvciA9IF9yZXF1aXJlLlhUU2NvcGVQYXJzZXJFcnJvcjtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi9kb2MtdXRpbHMuanNcIiksXG4gIHB1c2hBcnJheSA9IF9yZXF1aXJlMi5wdXNoQXJyYXk7XG52YXIgZ2V0UmVzb2x2ZWRJZCA9IHJlcXVpcmUoXCIuL2dldC1yZXNvbHZlZC1pZC5qc1wiKTtcbmZ1bmN0aW9uIG1vZHVsZVJlbmRlcihwYXJ0LCBvcHRpb25zKSB7XG4gIGZvciAodmFyIF9pMiA9IDAsIF9vcHRpb25zJG1vZHVsZXMyID0gb3B0aW9ucy5tb2R1bGVzOyBfaTIgPCBfb3B0aW9ucyRtb2R1bGVzMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9tb2R1bGUgPSBfb3B0aW9ucyRtb2R1bGVzMltfaTJdO1xuICAgIHZhciBtb2R1bGVSZW5kZXJlZCA9IF9tb2R1bGUucmVuZGVyKHBhcnQsIG9wdGlvbnMpO1xuICAgIGlmIChtb2R1bGVSZW5kZXJlZCkge1xuICAgICAgcmV0dXJuIG1vZHVsZVJlbmRlcmVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZW5kZXIob3B0aW9ucykge1xuICB2YXIgYmFzZU51bGxHZXR0ZXIgPSBvcHRpb25zLmJhc2VOdWxsR2V0dGVyO1xuICB2YXIgY29tcGlsZWQgPSBvcHRpb25zLmNvbXBpbGVkLFxuICAgIHNjb3BlTWFuYWdlciA9IG9wdGlvbnMuc2NvcGVNYW5hZ2VyO1xuICBvcHRpb25zLm51bGxHZXR0ZXIgPSBmdW5jdGlvbiAocGFydCwgc20pIHtcbiAgICByZXR1cm4gYmFzZU51bGxHZXR0ZXIocGFydCwgc20gfHwgc2NvcGVNYW5hZ2VyKTtcbiAgfTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgcGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbXBpbGVkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHBhcnQgPSBjb21waWxlZFtpXTtcbiAgICBvcHRpb25zLmluZGV4ID0gaTtcbiAgICBvcHRpb25zLnJlc29sdmVkSWQgPSBnZXRSZXNvbHZlZElkKHBhcnQsIG9wdGlvbnMpO1xuICAgIHZhciBtb2R1bGVSZW5kZXJlZCA9IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgbW9kdWxlUmVuZGVyZWQgPSBtb2R1bGVSZW5kZXIocGFydCwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBYVFNjb3BlUGFyc2VyRXJyb3IpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZVJlbmRlcmVkKSB7XG4gICAgICBpZiAobW9kdWxlUmVuZGVyZWQuZXJyb3JzKSB7XG4gICAgICAgIHB1c2hBcnJheShlcnJvcnMsIG1vZHVsZVJlbmRlcmVkLmVycm9ycyk7XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKG1vZHVsZVJlbmRlcmVkKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocGFydC50eXBlID09PSBcImNvbnRlbnRcIiB8fCBwYXJ0LnR5cGUgPT09IFwidGFnXCIpIHtcbiAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhyb3dVbmltcGxlbWVudGVkVGFnVHlwZShwYXJ0LCBpKTtcbiAgfVxuXG4gIC8vIFRoaXMgaXMgZG9uZSBpbiB0d28gc3RlcHMgYmVjYXVzZSBmb3Igc29tZSBmaWxlcywgaXQgaXMgcG9zc2libGUgdG8gI2VkaXQtdmFsdWUtYmFja3dhcmRzXG4gIHZhciB0b3RhbFBhcnRzID0gW107XG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHBhcnRzLmxlbmd0aDsgX2k0KyspIHtcbiAgICB2YXIgdmFsdWUgPSBwYXJ0c1tfaTRdLnZhbHVlO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBwdXNoQXJyYXkodG90YWxQYXJ0cywgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHRvdGFsUGFydHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgcGFydHM6IHRvdGFsUGFydHNcbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gcmVuZGVyOyJdLCJuYW1lcyI6WyJfcmVxdWlyZSIsInJlcXVpcmUiLCJ0aHJvd1VuaW1wbGVtZW50ZWRUYWdUeXBlIiwiWFRTY29wZVBhcnNlckVycm9yIiwiX3JlcXVpcmUyIiwicHVzaEFycmF5IiwiZ2V0UmVzb2x2ZWRJZCIsIm1vZHVsZVJlbmRlciIsInBhcnQiLCJvcHRpb25zIiwiX2kyIiwiX29wdGlvbnMkbW9kdWxlczIiLCJtb2R1bGVzIiwibGVuZ3RoIiwiX21vZHVsZSIsIm1vZHVsZVJlbmRlcmVkIiwicmVuZGVyIiwiYmFzZU51bGxHZXR0ZXIiLCJjb21waWxlZCIsInNjb3BlTWFuYWdlciIsIm51bGxHZXR0ZXIiLCJzbSIsImVycm9ycyIsInBhcnRzIiwiaSIsImxlbiIsImluZGV4IiwicmVzb2x2ZWRJZCIsImUiLCJwdXNoIiwidHlwZSIsInRvdGFsUGFydHMiLCJfaTQiLCJ2YWx1ZSIsIkFycmF5IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/render.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/resolve.js":
/*!**************************************************!*\
  !*** ./node_modules/docxtemplater/js/resolve.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"), pushArray = _require.pushArray;\nvar getResolvedId = __webpack_require__(/*! ./get-resolved-id.js */ \"(rsc)/./node_modules/docxtemplater/js/get-resolved-id.js\");\nfunction moduleResolve(part, options) {\n    for(var _i2 = 0, _options$modules2 = options.modules; _i2 < _options$modules2.length; _i2++){\n        var _module = _options$modules2[_i2];\n        var moduleResolved = _module.resolve(part, options);\n        if (moduleResolved) {\n            return moduleResolved;\n        }\n    }\n    return false;\n}\nfunction resolve(options) {\n    var resolved = [];\n    var baseNullGetter = options.baseNullGetter;\n    var compiled = options.compiled, scopeManager = options.scopeManager;\n    options.nullGetter = function(part, sm) {\n        return baseNullGetter(part, sm || scopeManager);\n    };\n    options.resolved = resolved;\n    var errors = [];\n    return Promise.all(compiled.filter(function(part) {\n        return [\n            \"content\",\n            \"tag\"\n        ].indexOf(part.type) === -1;\n    }).reduce(function(promises, part) {\n        var moduleResolved = moduleResolve(part, _objectSpread(_objectSpread({}, options), {}, {\n            resolvedId: getResolvedId(part, options)\n        }));\n        var result;\n        if (moduleResolved) {\n            result = moduleResolved.then(function(value) {\n                resolved.push({\n                    tag: part.value,\n                    lIndex: part.lIndex,\n                    value: value\n                });\n            });\n        } else if (part.type === \"placeholder\") {\n            result = scopeManager.getValueAsync(part.value, {\n                part: part\n            }).then(function(value) {\n                return value == null ? options.nullGetter(part) : value;\n            }).then(function(value) {\n                resolved.push({\n                    tag: part.value,\n                    lIndex: part.lIndex,\n                    value: value\n                });\n                return value;\n            });\n        } else {\n            return;\n        }\n        promises.push(result[\"catch\"](function(e) {\n            if (e instanceof Array) {\n                pushArray(errors, e);\n            } else {\n                errors.push(e);\n            }\n        }));\n        return promises;\n    }, [])).then(function() {\n        return {\n            errors: errors,\n            resolved: resolved\n        };\n    });\n}\nmodule.exports = resolve;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9yZXNvbHZlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNLLFFBQVFDLENBQUMsRUFBRUMsQ0FBQztJQUFJLElBQUlDLElBQUlDLE9BQU9DLElBQUksQ0FBQ0o7SUFBSSxJQUFJRyxPQUFPRSxxQkFBcUIsRUFBRTtRQUFFLElBQUlYLElBQUlTLE9BQU9FLHFCQUFxQixDQUFDTDtRQUFJQyxLQUFNUCxDQUFBQSxJQUFJQSxFQUFFWSxNQUFNLENBQUMsU0FBVUwsQ0FBQztZQUFJLE9BQU9FLE9BQU9JLHdCQUF3QixDQUFDUCxHQUFHQyxHQUFHTyxVQUFVO1FBQUUsRUFBQyxHQUFJTixFQUFFTyxJQUFJLENBQUNDLEtBQUssQ0FBQ1IsR0FBR1I7SUFBSTtJQUFFLE9BQU9RO0FBQUc7QUFDOVAsU0FBU1MsY0FBY1gsQ0FBQztJQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJVyxVQUFVQyxNQUFNLEVBQUVaLElBQUs7UUFBRSxJQUFJQyxJQUFJLFFBQVFVLFNBQVMsQ0FBQ1gsRUFBRSxHQUFHVyxTQUFTLENBQUNYLEVBQUUsR0FBRyxDQUFDO1FBQUdBLElBQUksSUFBSUYsUUFBUUksT0FBT0QsSUFBSSxDQUFDLEdBQUdZLE9BQU8sQ0FBQyxTQUFVYixDQUFDO1lBQUljLGdCQUFnQmYsR0FBR0MsR0FBR0MsQ0FBQyxDQUFDRCxFQUFFO1FBQUcsS0FB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QkFDMUN1QixTQUFTbEMsSUFBSSxDQUFDO29CQUNaa0QsS0FBS3hCLEtBQUtmLEtBQUs7b0JBQ2Z3QyxRQUFRekIsS0FBS3lCLE1BQU07b0JBQ25CeEMsT0FBT0E7Z0JBQ1Q7WUFDRjtRQUNGLE9BQU8sSUFBSWUsS0FBS2tCLElBQUksS0FBSyxlQUFlO1lBQ3RDSSxTQUFTWCxhQUFhZSxhQUFhLENBQUMxQixLQUFLZixLQUFLLEVBQUU7Z0JBQzlDZSxNQUFNQTtZQUNSLEdBQUd1QixJQUFJLENBQUMsU0FBVXRDLEtBQUs7Z0JBQ3JCLE9BQU9BLFNBQVMsT0FBT2dCLFFBQVFXLFVBQVUsQ0FBQ1osUUFBUWY7WUFDcEQsR0FBR3NDLElBQUksQ0FBQyxTQUFVdEMsS0FBSztnQkFDckJ1QixTQUFTbEMsSUFBSSxDQUFDO29CQUNaa0QsS0FBS3hCLEtBQUtmLEtBQUs7b0JBQ2Z3QyxRQUFRekIsS0FBS3lCLE1BQU07b0JBQ25CeEMsT0FBT0E7Z0JBQ1Q7Z0JBQ0EsT0FBT0E7WUFDVDtRQUNGLE9BQU87WUFDTDtRQUNGO1FBQ0FtQyxTQUFTOUMsSUFBSSxDQUFDZ0QsTUFBTSxDQUFDLFFBQVEsQ0FBQyxTQUFVekQsQ0FBQztZQUN2QyxJQUFJQSxhQUFhOEQsT0FBTztnQkFDdEI5QixVQUFVaUIsUUFBUWpEO1lBQ3BCLE9BQU87Z0JBQ0xpRCxPQUFPeEMsSUFBSSxDQUFDVDtZQUNkO1FBQ0Y7UUFDQSxPQUFPdUQ7SUFDVCxHQUFHLEVBQUUsR0FBR0csSUFBSSxDQUFDO1FBQ1gsT0FBTztZQUNMVCxRQUFRQTtZQUNSTixVQUFVQTtRQUNaO0lBQ0Y7QUFDRjtBQUNBb0IsT0FBT0MsT0FBTyxHQUFHdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaWtlLXJlbnRhbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcmVzb2x2ZS5qcz9lYzllIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgcHVzaEFycmF5ID0gX3JlcXVpcmUucHVzaEFycmF5O1xudmFyIGdldFJlc29sdmVkSWQgPSByZXF1aXJlKFwiLi9nZXQtcmVzb2x2ZWQtaWQuanNcIik7XG5mdW5jdGlvbiBtb2R1bGVSZXNvbHZlKHBhcnQsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgX2kyID0gMCwgX29wdGlvbnMkbW9kdWxlczIgPSBvcHRpb25zLm1vZHVsZXM7IF9pMiA8IF9vcHRpb25zJG1vZHVsZXMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX21vZHVsZSA9IF9vcHRpb25zJG1vZHVsZXMyW19pMl07XG4gICAgdmFyIG1vZHVsZVJlc29sdmVkID0gX21vZHVsZS5yZXNvbHZlKHBhcnQsIG9wdGlvbnMpO1xuICAgIGlmIChtb2R1bGVSZXNvbHZlZCkge1xuICAgICAgcmV0dXJuIG1vZHVsZVJlc29sdmVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZXNvbHZlKG9wdGlvbnMpIHtcbiAgdmFyIHJlc29sdmVkID0gW107XG4gIHZhciBiYXNlTnVsbEdldHRlciA9IG9wdGlvbnMuYmFzZU51bGxHZXR0ZXI7XG4gIHZhciBjb21waWxlZCA9IG9wdGlvbnMuY29tcGlsZWQsXG4gICAgc2NvcGVNYW5hZ2VyID0gb3B0aW9ucy5zY29wZU1hbmFnZXI7XG4gIG9wdGlvbnMubnVsbEdldHRlciA9IGZ1bmN0aW9uIChwYXJ0LCBzbSkge1xuICAgIHJldHVybiBiYXNlTnVsbEdldHRlcihwYXJ0LCBzbSB8fCBzY29wZU1hbmFnZXIpO1xuICB9O1xuICBvcHRpb25zLnJlc29sdmVkID0gcmVzb2x2ZWQ7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgcmV0dXJuIFByb21pc2UuYWxsKGNvbXBpbGVkLmZpbHRlcihmdW5jdGlvbiAocGFydCkge1xuICAgIHJldHVybiBbXCJjb250ZW50XCIsIFwidGFnXCJdLmluZGV4T2YocGFydC50eXBlKSA9PT0gLTE7XG4gIH0pLnJlZHVjZShmdW5jdGlvbiAocHJvbWlzZXMsIHBhcnQpIHtcbiAgICB2YXIgbW9kdWxlUmVzb2x2ZWQgPSBtb2R1bGVSZXNvbHZlKHBhcnQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICByZXNvbHZlZElkOiBnZXRSZXNvbHZlZElkKHBhcnQsIG9wdGlvbnMpXG4gICAgfSkpO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKG1vZHVsZVJlc29sdmVkKSB7XG4gICAgICByZXN1bHQgPSBtb2R1bGVSZXNvbHZlZC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXNvbHZlZC5wdXNoKHtcbiAgICAgICAgICB0YWc6IHBhcnQudmFsdWUsXG4gICAgICAgICAgbEluZGV4OiBwYXJ0LmxJbmRleCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHBhcnQudHlwZSA9PT0gXCJwbGFjZWhvbGRlclwiKSB7XG4gICAgICByZXN1bHQgPSBzY29wZU1hbmFnZXIuZ2V0VmFsdWVBc3luYyhwYXJ0LnZhbHVlLCB7XG4gICAgICAgIHBhcnQ6IHBhcnRcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gb3B0aW9ucy5udWxsR2V0dGVyKHBhcnQpIDogdmFsdWU7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXNvbHZlZC5wdXNoKHtcbiAgICAgICAgICB0YWc6IHBhcnQudmFsdWUsXG4gICAgICAgICAgbEluZGV4OiBwYXJ0LmxJbmRleCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByb21pc2VzLnB1c2gocmVzdWx0W1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgcHVzaEFycmF5KGVycm9ycywgZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgcmV0dXJuIHByb21pc2VzO1xuICB9LCBbXSkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgIHJlc29sdmVkOiByZXNvbHZlZFxuICAgIH07XG4gIH0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlOyJdLCJuYW1lcyI6WyJfdHlwZW9mIiwibyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJvd25LZXlzIiwiZSIsInIiLCJ0IiwiT2JqZWN0Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJwdXNoIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiZm9yRWFjaCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJfdG9Qcm9wZXJ0eUtleSIsInZhbHVlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJpIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiX3JlcXVpcmUiLCJyZXF1aXJlIiwicHVzaEFycmF5IiwiZ2V0UmVzb2x2ZWRJZCIsIm1vZHVsZVJlc29sdmUiLCJwYXJ0Iiwib3B0aW9ucyIsIl9pMiIsIl9vcHRpb25zJG1vZHVsZXMyIiwibW9kdWxlcyIsIl9tb2R1bGUiLCJtb2R1bGVSZXNvbHZlZCIsInJlc29sdmUiLCJyZXNvbHZlZCIsImJhc2VOdWxsR2V0dGVyIiwiY29tcGlsZWQiLCJzY29wZU1hbmFnZXIiLCJudWxsR2V0dGVyIiwic20iLCJlcnJvcnMiLCJQcm9taXNlIiwiYWxsIiwiaW5kZXhPZiIsInR5cGUiLCJyZWR1Y2UiLCJwcm9taXNlcyIsInJlc29sdmVkSWQiLCJyZXN1bHQiLCJ0aGVuIiwidGFnIiwibEluZGV4IiwiZ2V0VmFsdWVBc3luYyIsIkFycmF5IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/resolve.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/scope-manager.js":
/*!********************************************************!*\
  !*** ./node_modules/docxtemplater/js/scope-manager.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n    for(var t = 0; t < r.length; t++){\n        var o = r[t];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n}\nfunction _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n        writable: !1\n    }), e;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar _require = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\"), getScopeParserExecutionError = _require.getScopeParserExecutionError;\nvar _require2 = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/docxtemplater/js/utils.js\"), last = _require2.last;\nvar _require3 = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"), concatArrays = _require3.concatArrays;\nfunction find(list, fn) {\n    var length = list.length >>> 0;\n    var value;\n    for(var i = 0; i < length; i++){\n        value = list[i];\n        if (fn.call(this, value, i, list)) {\n            return value;\n        }\n    }\n    return undefined;\n}\nfunction _getValue(tag, meta, num) {\n    var _this = this;\n    var scope = this.scopeList[num];\n    if (this.root.finishedResolving) {\n        var w = this.resolved;\n        var _loop = function _loop() {\n            var lIndex = _this.scopeLindex[i];\n            w = find(w, function(r) {\n                return r.lIndex === lIndex;\n            });\n            w = w.value[_this.scopePathItem[i]];\n        };\n        for(var i = this.resolveOffset, len = this.scopePath.length; i < len; i++){\n            _loop();\n        }\n        return find(w, function(r) {\n            return meta.part.lIndex === r.lIndex;\n        }).value;\n    }\n    // search in the scopes (in reverse order) and keep the first defined value\n    var result;\n    var parser;\n    if (!this.cachedParsers || !meta.part) {\n        parser = this.parser(tag, {\n            tag: meta.part,\n            scopePath: this.scopePath\n        });\n    } else if (this.cachedParsers[meta.part.lIndex]) {\n        parser = this.cachedParsers[meta.part.lIndex];\n    } else {\n        parser = this.cachedParsers[meta.part.lIndex] = this.parser(tag, {\n            tag: meta.part,\n            scopePath: this.scopePath\n        });\n    }\n    try {\n        result = parser.get(scope, this.getContext(meta, num));\n    } catch (error) {\n        throw getScopeParserExecutionError({\n            tag: tag,\n            scope: scope,\n            error: error,\n            offset: meta.part.offset\n        });\n    }\n    if (result == null && num > 0) {\n        return _getValue.call(this, tag, meta, num - 1);\n    }\n    return result;\n}\nfunction _getValueAsync(tag, meta, num) {\n    var _this2 = this;\n    var scope = this.scopeList[num];\n    // search in the scopes (in reverse order) and keep the first defined value\n    var parser;\n    if (!this.cachedParsers || !meta.part) {\n        parser = this.parser(tag, {\n            tag: meta.part,\n            scopePath: this.scopePath\n        });\n    } else if (this.cachedParsers[meta.part.lIndex]) {\n        parser = this.cachedParsers[meta.part.lIndex];\n    } else {\n        parser = this.cachedParsers[meta.part.lIndex] = this.parser(tag, {\n            tag: meta.part,\n            scopePath: this.scopePath\n        });\n    }\n    return Promise.resolve().then(function() {\n        return parser.get(scope, _this2.getContext(meta, num));\n    })[\"catch\"](function(error) {\n        throw getScopeParserExecutionError({\n            tag: tag,\n            scope: scope,\n            error: error,\n            offset: meta.part.offset\n        });\n    }).then(function(result) {\n        if (result == null && num > 0) {\n            return _getValueAsync.call(_this2, tag, meta, num - 1);\n        }\n        return result;\n    });\n}\nvar ScopeManager = /*#__PURE__*/ function() {\n    function ScopeManager(options) {\n        _classCallCheck(this, ScopeManager);\n        this.root = options.root || this;\n        this.resolveOffset = options.resolveOffset || 0;\n        this.scopePath = options.scopePath;\n        this.scopePathItem = options.scopePathItem;\n        this.scopePathLength = options.scopePathLength;\n        this.scopeList = options.scopeList;\n        this.scopeType = \"\";\n        this.scopeTypes = options.scopeTypes;\n        this.scopeLindex = options.scopeLindex;\n        this.parser = options.parser;\n        this.resolved = options.resolved;\n        this.cachedParsers = options.cachedParsers;\n    }\n    return _createClass(ScopeManager, [\n        {\n            key: \"loopOver\",\n            value: function loopOver(tag, functor, inverted, meta) {\n                return this.loopOverValue(this.getValue(tag, meta), functor, inverted);\n            }\n        },\n        {\n            key: \"functorIfInverted\",\n            value: function functorIfInverted(inverted, functor, value, i, length) {\n                if (inverted) {\n                    functor(value, i, length);\n                }\n                return inverted;\n            }\n        },\n        {\n            key: \"isValueFalsy\",\n            value: function isValueFalsy(value, type) {\n                return value == null || !value || type === \"[object Array]\" && value.length === 0;\n            }\n        },\n        {\n            key: \"loopOverValue\",\n            value: function loopOverValue(value, functor, inverted) {\n                if (this.root.finishedResolving) {\n                    inverted = false;\n                }\n                var type = Object.prototype.toString.call(value);\n                if (this.isValueFalsy(value, type)) {\n                    this.scopeType = false;\n                    return this.functorIfInverted(inverted, functor, last(this.scopeList), 0, 1);\n                }\n                if (type === \"[object Array]\") {\n                    this.scopeType = \"array\";\n                    for(var i = 0; i < value.length; i++){\n                        this.functorIfInverted(!inverted, functor, value[i], i, value.length);\n                    }\n                    return true;\n                }\n                if (type === \"[object Object]\") {\n                    this.scopeType = \"object\";\n                    return this.functorIfInverted(!inverted, functor, value, 0, 1);\n                }\n                return this.functorIfInverted(!inverted, functor, last(this.scopeList), 0, 1);\n            }\n        },\n        {\n            key: \"getValue\",\n            value: function getValue(tag, meta) {\n                var result = _getValue.call(this, tag, meta, this.scopeList.length - 1);\n                if (typeof result === \"function\") {\n                    return result(this.scopeList[this.scopeList.length - 1], this);\n                }\n                return result;\n            }\n        },\n        {\n            key: \"getValueAsync\",\n            value: function getValueAsync(tag, meta) {\n                var _this3 = this;\n                return _getValueAsync.call(this, tag, meta, this.scopeList.length - 1).then(function(result) {\n                    if (typeof result === \"function\") {\n                        return result(_this3.scopeList[_this3.scopeList.length - 1], _this3);\n                    }\n                    return result;\n                });\n            }\n        },\n        {\n            key: \"getContext\",\n            value: function getContext(meta, num) {\n                return {\n                    num: num,\n                    meta: meta,\n                    scopeList: this.scopeList,\n                    resolved: this.resolved,\n                    scopePath: this.scopePath,\n                    scopeTypes: this.scopeTypes,\n                    scopePathItem: this.scopePathItem,\n                    scopePathLength: this.scopePathLength\n                };\n            }\n        },\n        {\n            key: \"createSubScopeManager\",\n            value: function createSubScopeManager(scope, tag, i, part, length) {\n                return new ScopeManager({\n                    root: this.root,\n                    resolveOffset: this.resolveOffset,\n                    resolved: this.resolved,\n                    parser: this.parser,\n                    cachedParsers: this.cachedParsers,\n                    scopeTypes: concatArrays([\n                        this.scopeTypes,\n                        [\n                            this.scopeType\n                        ]\n                    ]),\n                    scopeList: concatArrays([\n                        this.scopeList,\n                        [\n                            scope\n                        ]\n                    ]),\n                    scopePath: concatArrays([\n                        this.scopePath,\n                        [\n                            tag\n                        ]\n                    ]),\n                    scopePathItem: concatArrays([\n                        this.scopePathItem,\n                        [\n                            i\n                        ]\n                    ]),\n                    scopePathLength: concatArrays([\n                        this.scopePathLength,\n                        [\n                            length\n                        ]\n                    ]),\n                    scopeLindex: concatArrays([\n                        this.scopeLindex,\n                        [\n                            part.lIndex\n                        ]\n                    ])\n                });\n            }\n        }\n    ]);\n}();\nmodule.exports = function(options) {\n    options.scopePath = [];\n    options.scopePathItem = [];\n    options.scopePathLength = [];\n    options.scopeTypes = [];\n    options.scopeLindex = [];\n    options.scopeList = [\n        options.tags\n    ];\n    return new ScopeManager(options);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9zY29wZS1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNLLGdCQUFnQkMsQ0FBQyxFQUFFQyxDQUFDO0lBQUksSUFBSSxDQUFFRCxDQUFBQSxhQUFhQyxDQUFBQSxHQUFJLE1BQU0sSUFBSUMsVUFBVTtBQUFzQztBQUNsSCxTQUFTQyxrQkFBa0JDLENBQUMsRUFBRUMsQ0FBQztJQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxFQUFFRSxNQUFNLEVBQUVELElBQUs7UUFBRSxJQUFJWixJQUFJVyxDQUFDLENBQUNDLEVBQUU7UUFBRVosRUFBRWMsVUFBVSxHQUFHZCxFQUFFYyxVQUFVLElBQUksQ0FBQyxHQUFHZCxFQUFFZSxZQUFZLEdBQUcsQ0FBQyxHQUFHLFdBQVdmLEtBQU1BLENBQUFBLEVBQUVnQixRQUFRLEdBQUcsQ0FBQyxJQUFJQyxPQUFPQyxjQUFjLENBQUNSLEdBQUdTLGVBQWVuQixFQUFFb0IsR0FBRyxHQUFHcEI7SUFBSTtBQUFFO0FBQ3ZPLFNBQVNxQixhQUFhWCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQztJQUFJLE9BQU9ELEtBQUtGLGtCQUFrQkMsRUFBRU4sU0FBUyxFQUFFTyxJQUFJQyxLQUFLSCxrQkFBa0JDLEdBQUdFLElBQUlLLE9BQU9DLGNBQWMsQ0FBQ1IsR0FBRyxhQUFhO1FBQUVNLFVBQVUs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QkFDdkJVLFFBQVEsSUFBSSxDQUFDQSxNQUFNO29CQUNuQkMsZUFBZSxJQUFJLENBQUNBLGFBQWE7b0JBQ2pDYyxZQUFZekMsYUFBYTt3QkFBQyxJQUFJLENBQUN5QyxVQUFVO3dCQUFFOzRCQUFDLElBQUksQ0FBQ0QsU0FBUzt5QkFBQztxQkFBQztvQkFDNUQ1QixXQUFXWixhQUFhO3dCQUFDLElBQUksQ0FBQ1ksU0FBUzt3QkFBRTs0QkFBQ0Q7eUJBQU07cUJBQUM7b0JBQ2pEWSxXQUFXdkIsYUFBYTt3QkFBQyxJQUFJLENBQUN1QixTQUFTO3dCQUFFOzRCQUFDaEI7eUJBQUk7cUJBQUM7b0JBQy9DYSxlQUFlcEIsYUFBYTt3QkFBQyxJQUFJLENBQUNvQixhQUFhO3dCQUFFOzRCQUFDaEM7eUJBQUU7cUJBQUM7b0JBQ3JEbUQsaUJBQWlCdkMsYUFBYTt3QkFBQyxJQUFJLENBQUN1QyxlQUFlO3dCQUFFOzRCQUFDNUQ7eUJBQU87cUJBQUM7b0JBQzlEd0MsYUFBYW5CLGFBQWE7d0JBQUMsSUFBSSxDQUFDbUIsV0FBVzt3QkFBRTs0QkFBQ0ssS0FBS04sTUFBTTt5QkFBQztxQkFBQztnQkFDN0Q7WUFDRjtRQUNGO0tBQUU7QUFDSjtBQUNBb0MsT0FBT0MsT0FBTyxHQUFHLFNBQVVqQixPQUFPO0lBQ2hDQSxRQUFRZixTQUFTLEdBQUcsRUFBRTtJQUN0QmUsUUFBUWxCLGFBQWEsR0FBRyxFQUFFO0lBQzFCa0IsUUFBUUMsZUFBZSxHQUFHLEVBQUU7SUFDNUJELFFBQVFHLFVBQVUsR0FBRyxFQUFFO0lBQ3ZCSCxRQUFRbkIsV0FBVyxHQUFHLEVBQUU7SUFDeEJtQixRQUFRMUIsU0FBUyxHQUFHO1FBQUMwQixRQUFRa0IsSUFBSTtLQUFDO0lBQ2xDLE9BQU8sSUFBSW5CLGFBQWFDO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlrZS1yZW50YWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL3Njb3BlLW1hbmFnZXIuanM/OTViYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpLFxuICBnZXRTY29wZVBhcnNlckV4ZWN1dGlvbkVycm9yID0gX3JlcXVpcmUuZ2V0U2NvcGVQYXJzZXJFeGVjdXRpb25FcnJvcjtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKSxcbiAgbGFzdCA9IF9yZXF1aXJlMi5sYXN0O1xudmFyIF9yZXF1aXJlMyA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgY29uY2F0QXJyYXlzID0gX3JlcXVpcmUzLmNvbmNhdEFycmF5cztcbmZ1bmN0aW9uIGZpbmQobGlzdCwgZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoID4+PiAwO1xuICB2YXIgdmFsdWU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YWx1ZSA9IGxpc3RbaV07XG4gICAgaWYgKGZuLmNhbGwodGhpcywgdmFsdWUsIGksIGxpc3QpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBfZ2V0VmFsdWUodGFnLCBtZXRhLCBudW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgdmFyIHNjb3BlID0gdGhpcy5zY29wZUxpc3RbbnVtXTtcbiAgaWYgKHRoaXMucm9vdC5maW5pc2hlZFJlc29sdmluZykge1xuICAgIHZhciB3ID0gdGhpcy5yZXNvbHZlZDtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBsSW5kZXggPSBfdGhpcy5zY29wZUxpbmRleFtpXTtcbiAgICAgIHcgPSBmaW5kKHcsIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiByLmxJbmRleCA9PT0gbEluZGV4O1xuICAgICAgfSk7XG4gICAgICB3ID0gdy52YWx1ZVtfdGhpcy5zY29wZVBhdGhJdGVtW2ldXTtcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnJlc29sdmVPZmZzZXQsIGxlbiA9IHRoaXMuc2NvcGVQYXRoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBfbG9vcCgpO1xuICAgIH1cbiAgICByZXR1cm4gZmluZCh3LCBmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuIG1ldGEucGFydC5sSW5kZXggPT09IHIubEluZGV4O1xuICAgIH0pLnZhbHVlO1xuICB9XG4gIC8vIHNlYXJjaCBpbiB0aGUgc2NvcGVzIChpbiByZXZlcnNlIG9yZGVyKSBhbmQga2VlcCB0aGUgZmlyc3QgZGVmaW5lZCB2YWx1ZVxuICB2YXIgcmVzdWx0O1xuICB2YXIgcGFyc2VyO1xuICBpZiAoIXRoaXMuY2FjaGVkUGFyc2VycyB8fCAhbWV0YS5wYXJ0KSB7XG4gICAgcGFyc2VyID0gdGhpcy5wYXJzZXIodGFnLCB7XG4gICAgICB0YWc6IG1ldGEucGFydCxcbiAgICAgIHNjb3BlUGF0aDogdGhpcy5zY29wZVBhdGhcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0aGlzLmNhY2hlZFBhcnNlcnNbbWV0YS5wYXJ0LmxJbmRleF0pIHtcbiAgICBwYXJzZXIgPSB0aGlzLmNhY2hlZFBhcnNlcnNbbWV0YS5wYXJ0LmxJbmRleF07XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VyID0gdGhpcy5jYWNoZWRQYXJzZXJzW21ldGEucGFydC5sSW5kZXhdID0gdGhpcy5wYXJzZXIodGFnLCB7XG4gICAgICB0YWc6IG1ldGEucGFydCxcbiAgICAgIHNjb3BlUGF0aDogdGhpcy5zY29wZVBhdGhcbiAgICB9KTtcbiAgfVxuICB0cnkge1xuICAgIHJlc3VsdCA9IHBhcnNlci5nZXQoc2NvcGUsIHRoaXMuZ2V0Q29udGV4dChtZXRhLCBudW0pKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBnZXRTY29wZVBhcnNlckV4ZWN1dGlvbkVycm9yKHtcbiAgICAgIHRhZzogdGFnLFxuICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgb2Zmc2V0OiBtZXRhLnBhcnQub2Zmc2V0XG4gICAgfSk7XG4gIH1cbiAgaWYgKHJlc3VsdCA9PSBudWxsICYmIG51bSA+IDApIHtcbiAgICByZXR1cm4gX2dldFZhbHVlLmNhbGwodGhpcywgdGFnLCBtZXRhLCBudW0gLSAxKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2dldFZhbHVlQXN5bmModGFnLCBtZXRhLCBudW0pIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG4gIHZhciBzY29wZSA9IHRoaXMuc2NvcGVMaXN0W251bV07XG4gIC8vIHNlYXJjaCBpbiB0aGUgc2NvcGVzIChpbiByZXZlcnNlIG9yZGVyKSBhbmQga2VlcCB0aGUgZmlyc3QgZGVmaW5lZCB2YWx1ZVxuICB2YXIgcGFyc2VyO1xuICBpZiAoIXRoaXMuY2FjaGVkUGFyc2VycyB8fCAhbWV0YS5wYXJ0KSB7XG4gICAgcGFyc2VyID0gdGhpcy5wYXJzZXIodGFnLCB7XG4gICAgICB0YWc6IG1ldGEucGFydCxcbiAgICAgIHNjb3BlUGF0aDogdGhpcy5zY29wZVBhdGhcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0aGlzLmNhY2hlZFBhcnNlcnNbbWV0YS5wYXJ0LmxJbmRleF0pIHtcbiAgICBwYXJzZXIgPSB0aGlzLmNhY2hlZFBhcnNlcnNbbWV0YS5wYXJ0LmxJbmRleF07XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VyID0gdGhpcy5jYWNoZWRQYXJzZXJzW21ldGEucGFydC5sSW5kZXhdID0gdGhpcy5wYXJzZXIodGFnLCB7XG4gICAgICB0YWc6IG1ldGEucGFydCxcbiAgICAgIHNjb3BlUGF0aDogdGhpcy5zY29wZVBhdGhcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBhcnNlci5nZXQoc2NvcGUsIF90aGlzMi5nZXRDb250ZXh0KG1ldGEsIG51bSkpO1xuICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHRocm93IGdldFNjb3BlUGFyc2VyRXhlY3V0aW9uRXJyb3Ioe1xuICAgICAgdGFnOiB0YWcsXG4gICAgICBzY29wZTogc2NvcGUsXG4gICAgICBlcnJvcjogZXJyb3IsXG4gICAgICBvZmZzZXQ6IG1ldGEucGFydC5vZmZzZXRcbiAgICB9KTtcbiAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdCA9PSBudWxsICYmIG51bSA+IDApIHtcbiAgICAgIHJldHVybiBfZ2V0VmFsdWVBc3luYy5jYWxsKF90aGlzMiwgdGFnLCBtZXRhLCBudW0gLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG59XG52YXIgU2NvcGVNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2NvcGVNYW5hZ2VyKG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2NvcGVNYW5hZ2VyKTtcbiAgICB0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgdGhpcztcbiAgICB0aGlzLnJlc29sdmVPZmZzZXQgPSBvcHRpb25zLnJlc29sdmVPZmZzZXQgfHwgMDtcbiAgICB0aGlzLnNjb3BlUGF0aCA9IG9wdGlvbnMuc2NvcGVQYXRoO1xuICAgIHRoaXMuc2NvcGVQYXRoSXRlbSA9IG9wdGlvbnMuc2NvcGVQYXRoSXRlbTtcbiAgICB0aGlzLnNjb3BlUGF0aExlbmd0aCA9IG9wdGlvbnMuc2NvcGVQYXRoTGVuZ3RoO1xuICAgIHRoaXMuc2NvcGVMaXN0ID0gb3B0aW9ucy5zY29wZUxpc3Q7XG4gICAgdGhpcy5zY29wZVR5cGUgPSBcIlwiO1xuICAgIHRoaXMuc2NvcGVUeXBlcyA9IG9wdGlvbnMuc2NvcGVUeXBlcztcbiAgICB0aGlzLnNjb3BlTGluZGV4ID0gb3B0aW9ucy5zY29wZUxpbmRleDtcbiAgICB0aGlzLnBhcnNlciA9IG9wdGlvbnMucGFyc2VyO1xuICAgIHRoaXMucmVzb2x2ZWQgPSBvcHRpb25zLnJlc29sdmVkO1xuICAgIHRoaXMuY2FjaGVkUGFyc2VycyA9IG9wdGlvbnMuY2FjaGVkUGFyc2VycztcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFNjb3BlTWFuYWdlciwgW3tcbiAgICBrZXk6IFwibG9vcE92ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9vcE92ZXIodGFnLCBmdW5jdG9yLCBpbnZlcnRlZCwgbWV0YSkge1xuICAgICAgcmV0dXJuIHRoaXMubG9vcE92ZXJWYWx1ZSh0aGlzLmdldFZhbHVlKHRhZywgbWV0YSksIGZ1bmN0b3IsIGludmVydGVkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnVuY3RvcklmSW52ZXJ0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnVuY3RvcklmSW52ZXJ0ZWQoaW52ZXJ0ZWQsIGZ1bmN0b3IsIHZhbHVlLCBpLCBsZW5ndGgpIHtcbiAgICAgIGlmIChpbnZlcnRlZCkge1xuICAgICAgICBmdW5jdG9yKHZhbHVlLCBpLCBsZW5ndGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGludmVydGVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1ZhbHVlRmFsc3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNWYWx1ZUZhbHN5KHZhbHVlLCB0eXBlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCAhdmFsdWUgfHwgdHlwZSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiICYmIHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9vcE92ZXJWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb29wT3ZlclZhbHVlKHZhbHVlLCBmdW5jdG9yLCBpbnZlcnRlZCkge1xuICAgICAgaWYgKHRoaXMucm9vdC5maW5pc2hlZFJlc29sdmluZykge1xuICAgICAgICBpbnZlcnRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgaWYgKHRoaXMuaXNWYWx1ZUZhbHN5KHZhbHVlLCB0eXBlKSkge1xuICAgICAgICB0aGlzLnNjb3BlVHlwZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jdG9ySWZJbnZlcnRlZChpbnZlcnRlZCwgZnVuY3RvciwgbGFzdCh0aGlzLnNjb3BlTGlzdCksIDAsIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICB0aGlzLnNjb3BlVHlwZSA9IFwiYXJyYXlcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuZnVuY3RvcklmSW52ZXJ0ZWQoIWludmVydGVkLCBmdW5jdG9yLCB2YWx1ZVtpXSwgaSwgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgICAgIHRoaXMuc2NvcGVUeXBlID0gXCJvYmplY3RcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuY3RvcklmSW52ZXJ0ZWQoIWludmVydGVkLCBmdW5jdG9yLCB2YWx1ZSwgMCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5mdW5jdG9ySWZJbnZlcnRlZCghaW52ZXJ0ZWQsIGZ1bmN0b3IsIGxhc3QodGhpcy5zY29wZUxpc3QpLCAwLCAxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUodGFnLCBtZXRhKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gX2dldFZhbHVlLmNhbGwodGhpcywgdGFnLCBtZXRhLCB0aGlzLnNjb3BlTGlzdC5sZW5ndGggLSAxKTtcbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLnNjb3BlTGlzdFt0aGlzLnNjb3BlTGlzdC5sZW5ndGggLSAxXSwgdGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRWYWx1ZUFzeW5jXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlQXN5bmModGFnLCBtZXRhKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHJldHVybiBfZ2V0VmFsdWVBc3luYy5jYWxsKHRoaXMsIHRhZywgbWV0YSwgdGhpcy5zY29wZUxpc3QubGVuZ3RoIC0gMSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0KF90aGlzMy5zY29wZUxpc3RbX3RoaXMzLnNjb3BlTGlzdC5sZW5ndGggLSAxXSwgX3RoaXMzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGV4dChtZXRhLCBudW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG51bTogbnVtLFxuICAgICAgICBtZXRhOiBtZXRhLFxuICAgICAgICBzY29wZUxpc3Q6IHRoaXMuc2NvcGVMaXN0LFxuICAgICAgICByZXNvbHZlZDogdGhpcy5yZXNvbHZlZCxcbiAgICAgICAgc2NvcGVQYXRoOiB0aGlzLnNjb3BlUGF0aCxcbiAgICAgICAgc2NvcGVUeXBlczogdGhpcy5zY29wZVR5cGVzLFxuICAgICAgICBzY29wZVBhdGhJdGVtOiB0aGlzLnNjb3BlUGF0aEl0ZW0sXG4gICAgICAgIHNjb3BlUGF0aExlbmd0aDogdGhpcy5zY29wZVBhdGhMZW5ndGhcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVN1YlNjb3BlTWFuYWdlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTdWJTY29wZU1hbmFnZXIoc2NvcGUsIHRhZywgaSwgcGFydCwgbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3IFNjb3BlTWFuYWdlcih7XG4gICAgICAgIHJvb3Q6IHRoaXMucm9vdCxcbiAgICAgICAgcmVzb2x2ZU9mZnNldDogdGhpcy5yZXNvbHZlT2Zmc2V0LFxuICAgICAgICByZXNvbHZlZDogdGhpcy5yZXNvbHZlZCxcbiAgICAgICAgcGFyc2VyOiB0aGlzLnBhcnNlcixcbiAgICAgICAgY2FjaGVkUGFyc2VyczogdGhpcy5jYWNoZWRQYXJzZXJzLFxuICAgICAgICBzY29wZVR5cGVzOiBjb25jYXRBcnJheXMoW3RoaXMuc2NvcGVUeXBlcywgW3RoaXMuc2NvcGVUeXBlXV0pLFxuICAgICAgICBzY29wZUxpc3Q6IGNvbmNhdEFycmF5cyhbdGhpcy5zY29wZUxpc3QsIFtzY29wZV1dKSxcbiAgICAgICAgc2NvcGVQYXRoOiBjb25jYXRBcnJheXMoW3RoaXMuc2NvcGVQYXRoLCBbdGFnXV0pLFxuICAgICAgICBzY29wZVBhdGhJdGVtOiBjb25jYXRBcnJheXMoW3RoaXMuc2NvcGVQYXRoSXRlbSwgW2ldXSksXG4gICAgICAgIHNjb3BlUGF0aExlbmd0aDogY29uY2F0QXJyYXlzKFt0aGlzLnNjb3BlUGF0aExlbmd0aCwgW2xlbmd0aF1dKSxcbiAgICAgICAgc2NvcGVMaW5kZXg6IGNvbmNhdEFycmF5cyhbdGhpcy5zY29wZUxpbmRleCwgW3BhcnQubEluZGV4XV0pXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5zY29wZVBhdGggPSBbXTtcbiAgb3B0aW9ucy5zY29wZVBhdGhJdGVtID0gW107XG4gIG9wdGlvbnMuc2NvcGVQYXRoTGVuZ3RoID0gW107XG4gIG9wdGlvbnMuc2NvcGVUeXBlcyA9IFtdO1xuICBvcHRpb25zLnNjb3BlTGluZGV4ID0gW107XG4gIG9wdGlvbnMuc2NvcGVMaXN0ID0gW29wdGlvbnMudGFnc107XG4gIHJldHVybiBuZXcgU2NvcGVNYW5hZ2VyKG9wdGlvbnMpO1xufTsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2NsYXNzQ2FsbENoZWNrIiwiYSIsIm4iLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsImUiLCJyIiwidCIsImxlbmd0aCIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiX3RvUHJvcGVydHlLZXkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJpIiwiX3RvUHJpbWl0aXZlIiwidG9QcmltaXRpdmUiLCJjYWxsIiwiU3RyaW5nIiwiTnVtYmVyIiwiX3JlcXVpcmUiLCJyZXF1aXJlIiwiZ2V0U2NvcGVQYXJzZXJFeGVjdXRpb25FcnJvciIsIl9yZXF1aXJlMiIsImxhc3QiLCJfcmVxdWlyZTMiLCJjb25jYXRBcnJheXMiLCJmaW5kIiwibGlzdCIsImZuIiwidmFsdWUiLCJ1bmRlZmluZWQiLCJfZ2V0VmFsdWUiLCJ0YWciLCJtZXRhIiwibnVtIiwiX3RoaXMiLCJzY29wZSIsInNjb3BlTGlzdCIsInJvb3QiLCJmaW5pc2hlZFJlc29sdmluZyIsInciLCJyZXNvbHZlZCIsIl9sb29wIiwibEluZGV4Iiwic2NvcGVMaW5kZXgiLCJzY29wZVBhdGhJdGVtIiwicmVzb2x2ZU9mZnNldCIsImxlbiIsInNjb3BlUGF0aCIsInBhcnQiLCJyZXN1bHQiLCJwYXJzZXIiLCJjYWNoZWRQYXJzZXJzIiwiZ2V0IiwiZ2V0Q29udGV4dCIsImVycm9yIiwib2Zmc2V0IiwiX2dldFZhbHVlQXN5bmMiLCJfdGhpczIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJTY29wZU1hbmFnZXIiLCJvcHRpb25zIiwic2NvcGVQYXRoTGVuZ3RoIiwic2NvcGVUeXBlIiwic2NvcGVUeXBlcyIsImxvb3BPdmVyIiwiZnVuY3RvciIsImludmVydGVkIiwibG9vcE92ZXJWYWx1ZSIsImdldFZhbHVlIiwiZnVuY3RvcklmSW52ZXJ0ZWQiLCJpc1ZhbHVlRmFsc3kiLCJ0eXBlIiwidG9TdHJpbmciLCJnZXRWYWx1ZUFzeW5jIiwiX3RoaXMzIiwiY3JlYXRlU3ViU2NvcGVNYW5hZ2VyIiwibW9kdWxlIiwiZXhwb3J0cyIsInRhZ3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/scope-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/traits.js":
/*!*************************************************!*\
  !*** ./node_modules/docxtemplater/js/traits.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _toConsumableArray(r) {\n    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArray(r) {\n    if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _arrayWithoutHoles(r) {\n    if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _slicedToArray(r, e) {\n    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(r, a) {\n    if (r) {\n        if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n        var t = ({}).toString.call(r).slice(8, -1);\n        return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n    }\n}\nfunction _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];\n    return n;\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = !0, o = !1;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = !0, n = r;\n        } finally{\n            try {\n                if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _arrayWithHoles(r) {\n    if (Array.isArray(r)) return r;\n}\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nfunction _defineProperty(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"), getRightOrNull = _require.getRightOrNull, getRight = _require.getRight, getLeft = _require.getLeft, getLeftOrNull = _require.getLeftOrNull, chunkBy = _require.chunkBy, isTagStart = _require.isTagStart, isTagEnd = _require.isTagEnd, isContent = _require.isContent, last = _require.last, first = _require.first;\nvar _require2 = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/docxtemplater/js/errors.js\"), XTTemplateError = _require2.XTTemplateError, throwExpandNotFound = _require2.throwExpandNotFound, getLoopPositionProducesInvalidXMLError = _require2.getLoopPositionProducesInvalidXMLError;\nfunction lastTagIsOpenTag(tags, tag) {\n    if (tags.length === 0) {\n        return false;\n    }\n    var innerLastTag = last(tags).substr(1);\n    return innerLastTag.indexOf(tag) === 0;\n}\nfunction getListXmlElements(parts) {\n    /*\n   * Gets the list of closing and opening tags between two texts. It doesn't take\n   * into account tags that are opened then closed. Those that are closed then\n   * opened are kept\n   *\n   * Example input :\n   *\n   * [\n   * \t{\n   * \t\t\"type\": \"placeholder\",\n   * \t\t\"value\": \"table1\",\n   * \t\t...\n   * \t},\n   * \t{\n   * \t\t\"type\": \"placeholder\",\n   * \t\t\"value\": \"t1data1\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"position\": \"end\",\n   * \t\t\"text\": true,\n   * \t\t\"value\": \"</w:t>\",\n   * \t\t\"tag\": \"w:t\",\n   * \t\t\"lIndex\": 112\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"</w:r>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"</w:p>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"</w:tc>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"<w:tc>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"content\",\n   * \t\t\"value\": \"<w:tcPr><w:tcW w:w=\"2444\" w:type=\"dxa\"/><w:tcBorders><w:top w:val=\"nil\"/><w:left w:val=\"nil\"/><w:bottom w:val=\"nil\"/><w:right w:val=\"nil\"/></w:tcBorders><w:shd w:val=\"clear\" w:color=\"auto\" w:fill=\"FFFFFF\"/></w:tcPr>\",\n   * \t},\n   * \t...\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"<w:r>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"<w:t xml:space=\"preserve\">\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"placeholder\",\n   * \t\t\"value\": \"t1data4\",\n   * \t}\n   * ]\n   *\n   * Returns\n   *\n   * \t[\n   * \t\t{\n   * \t\t\t\"tag\": \"</w:t>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"</w:r>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"</w:p>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"</w:tc>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"<w:tc>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"<w:p>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"<w:r>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"<w:t>\",\n   * \t\t},\n   * \t]\n   */ var result = [];\n    for(var _i2 = 0; _i2 < parts.length; _i2++){\n        var _parts$_i = parts[_i2], position = _parts$_i.position, value = _parts$_i.value, tag = _parts$_i.tag;\n        // Stryker disable all : because removing this condition would also work but we want to make the API future proof\n        if (!tag) {\n            continue;\n        }\n        // Stryker restore all\n        if (position === \"end\") {\n            if (lastTagIsOpenTag(result, tag)) {\n                result.pop();\n            } else {\n                result.push(value);\n            }\n        } else if (position === \"start\") {\n            result.push(value);\n        }\n    // ignore position === \"selfclosing\"\n    }\n    return result;\n}\nfunction has(name, xmlElements) {\n    for(var _i4 = 0; _i4 < xmlElements.length; _i4++){\n        var xmlElement = xmlElements[_i4];\n        if (xmlElement.indexOf(\"<\".concat(name)) === 0) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction getExpandToDefault(postparsed, pair, expandTags) {\n    var parts = postparsed.slice(pair[0].offset, pair[1].offset);\n    var xmlElements = getListXmlElements(parts);\n    var closingTagCount = xmlElements.filter(function(tag) {\n        return tag[1] === \"/\";\n    }).length;\n    var startingTagCount = xmlElements.filter(function(tag) {\n        return tag[1] !== \"/\" && tag[tag.length - 2] !== \"/\";\n    }).length;\n    if (closingTagCount !== startingTagCount) {\n        return {\n            error: getLoopPositionProducesInvalidXMLError({\n                tag: first(pair).part.value,\n                offset: [\n                    first(pair).part.offset,\n                    last(pair).part.offset\n                ]\n            })\n        };\n    }\n    var _loop = function _loop() {\n        var _expandTags$_i = expandTags[_i6], contains = _expandTags$_i.contains, expand = _expandTags$_i.expand, onlyTextInTag = _expandTags$_i.onlyTextInTag;\n        if (has(contains, xmlElements)) {\n            if (onlyTextInTag) {\n                var left = getLeftOrNull(postparsed, contains, pair[0].offset);\n                var right = getRightOrNull(postparsed, contains, pair[1].offset);\n                if (left === null || right === null) {\n                    return 0; // continue\n                }\n                var chunks = chunkBy(postparsed.slice(left, right), function(p) {\n                    return isTagStart(contains, p) ? \"start\" : isTagEnd(contains, p) ? \"end\" : null;\n                });\n                var firstChunk = first(chunks);\n                var lastChunk = last(chunks);\n                var firstContent = firstChunk.filter(isContent);\n                var lastContent = lastChunk.filter(isContent);\n                if (firstContent.length !== 1 || lastContent.length !== 1) {\n                    return 0; // continue\n                }\n            }\n            return {\n                v: {\n                    value: expand\n                }\n            };\n        }\n    }, _ret;\n    for(var _i6 = 0; _i6 < expandTags.length; _i6++){\n        _ret = _loop();\n        if (_ret === 0) continue;\n        if (_ret) return _ret.v;\n    }\n    return {};\n}\nfunction getExpandLimit(part, index, postparsed, options) {\n    var expandTo = part.expandTo || options.expandTo;\n    // Stryker disable all : because this condition can be removed in v4 (the only usage was the image module before version 3.12.3 of the image module\n    if (!expandTo) {\n        return;\n    }\n    // Stryker restore all\n    var right, left;\n    try {\n        left = getLeft(postparsed, expandTo, index);\n        right = getRight(postparsed, expandTo, index);\n    } catch (rootError) {\n        var errProps = _objectSpread({\n            part: part,\n            rootError: rootError,\n            postparsed: postparsed,\n            expandTo: expandTo,\n            index: index\n        }, options.error);\n        if (options.onError) {\n            var errorResult = options.onError(errProps);\n            if (errorResult === \"ignore\") {\n                return;\n            }\n        }\n        throwExpandNotFound(errProps);\n    }\n    return [\n        left,\n        right\n    ];\n}\nfunction expandOne(_ref, part, postparsed, options) {\n    var _ref2 = _slicedToArray(_ref, 2), left = _ref2[0], right = _ref2[1];\n    var index = postparsed.indexOf(part);\n    var leftParts = postparsed.slice(left, index);\n    var rightParts = postparsed.slice(index + 1, right + 1);\n    var inner = options.getInner({\n        postparse: options.postparse,\n        index: index,\n        part: part,\n        leftParts: leftParts,\n        rightParts: rightParts,\n        left: left,\n        right: right,\n        postparsed: postparsed\n    });\n    if (!inner.length) {\n        inner.expanded = [\n            leftParts,\n            rightParts\n        ];\n        inner = [\n            inner\n        ];\n    }\n    return {\n        left: left,\n        right: right,\n        inner: inner\n    };\n}\n/* eslint-disable-next-line complexity */ function expandToOne(postparsed, options) {\n    var errors = [];\n    if (postparsed.errors) {\n        errors = postparsed.errors;\n        postparsed = postparsed.postparsed;\n    }\n    var limits = [];\n    for(var i = 0, len = postparsed.length; i < len; i++){\n        var part = postparsed[i];\n        if (part.type === \"placeholder\" && part.module === options.moduleName && /*\n     * The part.subparsed check is used to fix this github issue :\n     * https://github.com/open-xml-templating/docxtemplater/issues/671\n     */ !part.subparsed && !part.expanded) {\n            try {\n                var limit = getExpandLimit(part, i, postparsed, options);\n                if (!limit) {\n                    continue;\n                }\n                var _limit = _slicedToArray(limit, 2), left = _limit[0], right = _limit[1];\n                limits.push({\n                    left: left,\n                    right: right,\n                    part: part,\n                    i: i,\n                    leftPart: postparsed[left],\n                    rightPart: postparsed[right]\n                });\n            } catch (error) {\n                // The Error can only be a\n                errors.push(error);\n            }\n        }\n    }\n    limits.sort(function(l1, l2) {\n        if (l1.left === l2.left) {\n            return l2.part.lIndex < l1.part.lIndex ? 1 : -1;\n        }\n        return l2.left < l1.left ? 1 : -1;\n    });\n    var maxRight = -1;\n    var offset = 0;\n    for(var _i7 = 0, _len = limits.length; _i7 < _len; _i7++){\n        var _postparsed;\n        var _limit2 = limits[_i7];\n        maxRight = Math.max(maxRight, _i7 > 0 ? limits[_i7 - 1].right : 0);\n        if (_limit2.left < maxRight) {\n            continue;\n        }\n        var result = void 0;\n        try {\n            result = expandOne([\n                _limit2.left + offset,\n                _limit2.right + offset\n            ], _limit2.part, postparsed, options);\n        } catch (error) {\n            if (options.onError) {\n                var errorResult = options.onError(_objectSpread({\n                    part: _limit2.part,\n                    rootError: error,\n                    postparsed: postparsed,\n                    expandOne: expandOne\n                }, options.errors));\n                if (errorResult === \"ignore\") {\n                    continue;\n                }\n            }\n            if (error instanceof XTTemplateError) {\n                errors.push(error);\n            } else {\n                throw error;\n            }\n        }\n        if (!result) {\n            continue;\n        }\n        offset += result.inner.length - (result.right + 1 - result.left);\n        (_postparsed = postparsed).splice.apply(_postparsed, [\n            result.left,\n            result.right + 1 - result.left\n        ].concat(_toConsumableArray(result.inner)));\n    }\n    return {\n        postparsed: postparsed,\n        errors: errors\n    };\n}\nmodule.exports = {\n    expandToOne: expandToOne,\n    getExpandToDefault: getExpandToDefault\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy90cmFpdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYixTQUFTQSxRQUFRQyxDQUFDO0lBQUk7SUFBMkIsT0FBT0QsVUFBVSxjQUFjLE9BQU9FLFVBQVUsWUFBWSxPQUFPQSxPQUFPQyxRQUFRLEdBQUcsU0FBVUYsQ0FBQztRQUFJLE9BQU8sT0FBT0E7SUFBRyxJQUFJLFNBQVVBLENBQUM7UUFBSSxPQUFPQSxLQUFLLGNBQWMsT0FBT0MsVUFBVUQsRUFBRUcsV0FBVyxLQUFLRixVQUFVRCxNQUFNQyxPQUFPRyxTQUFTLEdBQUcsV0FBVyxPQUFPSjtJQUFHLEdBQUdELFFBQVFDO0FBQUk7QUFDN1QsU0FBU0ssbUJBQW1CQyxDQUFDO0lBQUksT0FBT0MsbUJBQW1CRCxNQUFNRSxpQkFBaUJGLE1BQU1HLDRCQUE0QkgsTUFBTUk7QUFBc0I7QUFDaEosU0FBU0E7SUFBdUIsTUFBTSxJQUFJQyxVQUFVO0FBQXlJO0FBQzdMLFNBQVNILGlCQUFpQkYsQ0FBQztJQUFJLElBQUksZUFBZSxPQUFPTCxVQUFVLFFBQVFLLENBQUMsQ0FBQ0wsT0FBT0MsUUFBUSxDQUFDLElBQUksUUFBUUksQ0FBQyxDQUFDLGFBQWEsRUFBRSxPQUFPTSxNQUFNQyxJQUFJLENBQUNQO0FBQUk7QUFDaEosU0FBU0MsbUJBQW1CRCxDQUFDO0lBQUksSUFBSU0sTUFBTUUsT0FBTyxDQUFDUixJQUFJLE9BQU9TLGtCQUFrQlQ7QUFBSTtBQUNwRixTQUFTVSxlQUFlVixDQUFDLEVBQUVXLENBQUM7SUFBSSxPQUFPQyxnQkFBZ0JaLE1BQU1hLHNCQUFzQmIsR0FBR1csTUFBTVIsNEJBQTRCSCxHQUFHVyxNQUFNRztBQUFvQjtBQUNySixTQUFTQTtJQUFxQixNQUFNLElBQUlULFVBQVU7QUFBOEk7QUFDaE0sU0FBU0YsNEJBQTRCSCxDQUFDLEVBQUVlLENBQUM7SUFBSSxJQUFJZixHQUFHO1FBQUUsSUFBSSxZQUFZLE9BQU9BLEdBQUcs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QUFDeEYsbUJBQW1CK0UsT0FBT2dELEtBQUs7SUFDM0k7SUFDQSxPQUFPO1FBQ0xyQyxZQUFZQTtRQUNaMEMsUUFBUUE7SUFDVjtBQUNGO0FBQ0FJLE9BQU9tQixPQUFPLEdBQUc7SUFDZnhCLGFBQWFBO0lBQ2IxQyxvQkFBb0JBO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmlrZS1yZW50YWwtd2Vic2l0ZS8uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL3RyYWl0cy5qcz9mZGMwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkocikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXkocikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KHIpIHsgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBudWxsICE9IHJbU3ltYm9sLml0ZXJhdG9yXSB8fCBudWxsICE9IHJbXCJAQGl0ZXJhdG9yXCJdKSByZXR1cm4gQXJyYXkuZnJvbShyKTsgfVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyKTsgfVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkociwgZSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpOyB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpOyByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHZvaWQgMDsgfSB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhyKSB7IGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gcjsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkgeyByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7IHZhbHVlOiB0LCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVtyXSA9IHQsIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9kb2MtdXRpbHMuanNcIiksXG4gIGdldFJpZ2h0T3JOdWxsID0gX3JlcXVpcmUuZ2V0UmlnaHRPck51bGwsXG4gIGdldFJpZ2h0ID0gX3JlcXVpcmUuZ2V0UmlnaHQsXG4gIGdldExlZnQgPSBfcmVxdWlyZS5nZXRMZWZ0LFxuICBnZXRMZWZ0T3JOdWxsID0gX3JlcXVpcmUuZ2V0TGVmdE9yTnVsbCxcbiAgY2h1bmtCeSA9IF9yZXF1aXJlLmNodW5rQnksXG4gIGlzVGFnU3RhcnQgPSBfcmVxdWlyZS5pc1RhZ1N0YXJ0LFxuICBpc1RhZ0VuZCA9IF9yZXF1aXJlLmlzVGFnRW5kLFxuICBpc0NvbnRlbnQgPSBfcmVxdWlyZS5pc0NvbnRlbnQsXG4gIGxhc3QgPSBfcmVxdWlyZS5sYXN0LFxuICBmaXJzdCA9IF9yZXF1aXJlLmZpcnN0O1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKSxcbiAgWFRUZW1wbGF0ZUVycm9yID0gX3JlcXVpcmUyLlhUVGVtcGxhdGVFcnJvcixcbiAgdGhyb3dFeHBhbmROb3RGb3VuZCA9IF9yZXF1aXJlMi50aHJvd0V4cGFuZE5vdEZvdW5kLFxuICBnZXRMb29wUG9zaXRpb25Qcm9kdWNlc0ludmFsaWRYTUxFcnJvciA9IF9yZXF1aXJlMi5nZXRMb29wUG9zaXRpb25Qcm9kdWNlc0ludmFsaWRYTUxFcnJvcjtcbmZ1bmN0aW9uIGxhc3RUYWdJc09wZW5UYWcodGFncywgdGFnKSB7XG4gIGlmICh0YWdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5uZXJMYXN0VGFnID0gbGFzdCh0YWdzKS5zdWJzdHIoMSk7XG4gIHJldHVybiBpbm5lckxhc3RUYWcuaW5kZXhPZih0YWcpID09PSAwO1xufVxuZnVuY3Rpb24gZ2V0TGlzdFhtbEVsZW1lbnRzKHBhcnRzKSB7XG4gIC8qXG4gICAqIEdldHMgdGhlIGxpc3Qgb2YgY2xvc2luZyBhbmQgb3BlbmluZyB0YWdzIGJldHdlZW4gdHdvIHRleHRzLiBJdCBkb2Vzbid0IHRha2VcbiAgICogaW50byBhY2NvdW50IHRhZ3MgdGhhdCBhcmUgb3BlbmVkIHRoZW4gY2xvc2VkLiBUaG9zZSB0aGF0IGFyZSBjbG9zZWQgdGhlblxuICAgKiBvcGVuZWQgYXJlIGtlcHRcbiAgICpcbiAgICogRXhhbXBsZSBpbnB1dCA6XG4gICAqXG4gICAqIFtcbiAgICogXHR7XG4gICAqIFx0XHRcInR5cGVcIjogXCJwbGFjZWhvbGRlclwiLFxuICAgKiBcdFx0XCJ2YWx1ZVwiOiBcInRhYmxlMVwiLFxuICAgKiBcdFx0Li4uXG4gICAqIFx0fSxcbiAgICogXHR7XG4gICAqIFx0XHRcInR5cGVcIjogXCJwbGFjZWhvbGRlclwiLFxuICAgKiBcdFx0XCJ2YWx1ZVwiOiBcInQxZGF0YTFcIixcbiAgICogXHR9LFxuICAgKiBcdHtcbiAgICogXHRcdFwidHlwZVwiOiBcInRhZ1wiLFxuICAgKiBcdFx0XCJwb3NpdGlvblwiOiBcImVuZFwiLFxuICAgKiBcdFx0XCJ0ZXh0XCI6IHRydWUsXG4gICAqIFx0XHRcInZhbHVlXCI6IFwiPC93OnQ+XCIsXG4gICAqIFx0XHRcInRhZ1wiOiBcInc6dFwiLFxuICAgKiBcdFx0XCJsSW5kZXhcIjogMTEyXG4gICAqIFx0fSxcbiAgICogXHR7XG4gICAqIFx0XHRcInR5cGVcIjogXCJ0YWdcIixcbiAgICogXHRcdFwidmFsdWVcIjogXCI8L3c6cj5cIixcbiAgICogXHR9LFxuICAgKiBcdHtcbiAgICogXHRcdFwidHlwZVwiOiBcInRhZ1wiLFxuICAgKiBcdFx0XCJ2YWx1ZVwiOiBcIjwvdzpwPlwiLFxuICAgKiBcdH0sXG4gICAqIFx0e1xuICAgKiBcdFx0XCJ0eXBlXCI6IFwidGFnXCIsXG4gICAqIFx0XHRcInZhbHVlXCI6IFwiPC93OnRjPlwiLFxuICAgKiBcdH0sXG4gICAqIFx0e1xuICAgKiBcdFx0XCJ0eXBlXCI6IFwidGFnXCIsXG4gICAqIFx0XHRcInZhbHVlXCI6IFwiPHc6dGM+XCIsXG4gICAqIFx0fSxcbiAgICogXHR7XG4gICAqIFx0XHRcInR5cGVcIjogXCJjb250ZW50XCIsXG4gICAqIFx0XHRcInZhbHVlXCI6IFwiPHc6dGNQcj48dzp0Y1cgdzp3PVwiMjQ0NFwiIHc6dHlwZT1cImR4YVwiLz48dzp0Y0JvcmRlcnM+PHc6dG9wIHc6dmFsPVwibmlsXCIvPjx3OmxlZnQgdzp2YWw9XCJuaWxcIi8+PHc6Ym90dG9tIHc6dmFsPVwibmlsXCIvPjx3OnJpZ2h0IHc6dmFsPVwibmlsXCIvPjwvdzp0Y0JvcmRlcnM+PHc6c2hkIHc6dmFsPVwiY2xlYXJcIiB3OmNvbG9yPVwiYXV0b1wiIHc6ZmlsbD1cIkZGRkZGRlwiLz48L3c6dGNQcj5cIixcbiAgICogXHR9LFxuICAgKiBcdC4uLlxuICAgKiBcdHtcbiAgICogXHRcdFwidHlwZVwiOiBcInRhZ1wiLFxuICAgKiBcdFx0XCJ2YWx1ZVwiOiBcIjx3OnI+XCIsXG4gICAqIFx0fSxcbiAgICogXHR7XG4gICAqIFx0XHRcInR5cGVcIjogXCJ0YWdcIixcbiAgICogXHRcdFwidmFsdWVcIjogXCI8dzp0IHhtbDpzcGFjZT1cInByZXNlcnZlXCI+XCIsXG4gICAqIFx0fSxcbiAgICogXHR7XG4gICAqIFx0XHRcInR5cGVcIjogXCJwbGFjZWhvbGRlclwiLFxuICAgKiBcdFx0XCJ2YWx1ZVwiOiBcInQxZGF0YTRcIixcbiAgICogXHR9XG4gICAqIF1cbiAgICpcbiAgICogUmV0dXJuc1xuICAgKlxuICAgKiBcdFtcbiAgICogXHRcdHtcbiAgICogXHRcdFx0XCJ0YWdcIjogXCI8L3c6dD5cIixcbiAgICogXHRcdH0sXG4gICAqIFx0XHR7XG4gICAqIFx0XHRcdFwidGFnXCI6IFwiPC93OnI+XCIsXG4gICAqIFx0XHR9LFxuICAgKiBcdFx0e1xuICAgKiBcdFx0XHRcInRhZ1wiOiBcIjwvdzpwPlwiLFxuICAgKiBcdFx0fSxcbiAgICogXHRcdHtcbiAgICogXHRcdFx0XCJ0YWdcIjogXCI8L3c6dGM+XCIsXG4gICAqIFx0XHR9LFxuICAgKiBcdFx0e1xuICAgKiBcdFx0XHRcInRhZ1wiOiBcIjx3OnRjPlwiLFxuICAgKiBcdFx0fSxcbiAgICogXHRcdHtcbiAgICogXHRcdFx0XCJ0YWdcIjogXCI8dzpwPlwiLFxuICAgKiBcdFx0fSxcbiAgICogXHRcdHtcbiAgICogXHRcdFx0XCJ0YWdcIjogXCI8dzpyPlwiLFxuICAgKiBcdFx0fSxcbiAgICogXHRcdHtcbiAgICogXHRcdFx0XCJ0YWdcIjogXCI8dzp0PlwiLFxuICAgKiBcdFx0fSxcbiAgICogXHRdXG4gICAqL1xuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcGFydHMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfcGFydHMkX2kgPSBwYXJ0c1tfaTJdLFxuICAgICAgcG9zaXRpb24gPSBfcGFydHMkX2kucG9zaXRpb24sXG4gICAgICB2YWx1ZSA9IF9wYXJ0cyRfaS52YWx1ZSxcbiAgICAgIHRhZyA9IF9wYXJ0cyRfaS50YWc7XG4gICAgLy8gU3RyeWtlciBkaXNhYmxlIGFsbCA6IGJlY2F1c2UgcmVtb3ZpbmcgdGhpcyBjb25kaXRpb24gd291bGQgYWxzbyB3b3JrIGJ1dCB3ZSB3YW50IHRvIG1ha2UgdGhlIEFQSSBmdXR1cmUgcHJvb2ZcbiAgICBpZiAoIXRhZykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIFN0cnlrZXIgcmVzdG9yZSBhbGxcbiAgICBpZiAocG9zaXRpb24gPT09IFwiZW5kXCIpIHtcbiAgICAgIGlmIChsYXN0VGFnSXNPcGVuVGFnKHJlc3VsdCwgdGFnKSkge1xuICAgICAgICByZXN1bHQucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gXCJzdGFydFwiKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIC8vIGlnbm9yZSBwb3NpdGlvbiA9PT0gXCJzZWxmY2xvc2luZ1wiXG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGhhcyhuYW1lLCB4bWxFbGVtZW50cykge1xuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCB4bWxFbGVtZW50cy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgdmFyIHhtbEVsZW1lbnQgPSB4bWxFbGVtZW50c1tfaTRdO1xuICAgIGlmICh4bWxFbGVtZW50LmluZGV4T2YoXCI8XCIuY29uY2F0KG5hbWUpKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldEV4cGFuZFRvRGVmYXVsdChwb3N0cGFyc2VkLCBwYWlyLCBleHBhbmRUYWdzKSB7XG4gIHZhciBwYXJ0cyA9IHBvc3RwYXJzZWQuc2xpY2UocGFpclswXS5vZmZzZXQsIHBhaXJbMV0ub2Zmc2V0KTtcbiAgdmFyIHhtbEVsZW1lbnRzID0gZ2V0TGlzdFhtbEVsZW1lbnRzKHBhcnRzKTtcbiAgdmFyIGNsb3NpbmdUYWdDb3VudCA9IHhtbEVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAodGFnKSB7XG4gICAgcmV0dXJuIHRhZ1sxXSA9PT0gXCIvXCI7XG4gIH0pLmxlbmd0aDtcbiAgdmFyIHN0YXJ0aW5nVGFnQ291bnQgPSB4bWxFbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHRhZykge1xuICAgIHJldHVybiB0YWdbMV0gIT09IFwiL1wiICYmIHRhZ1t0YWcubGVuZ3RoIC0gMl0gIT09IFwiL1wiO1xuICB9KS5sZW5ndGg7XG4gIGlmIChjbG9zaW5nVGFnQ291bnQgIT09IHN0YXJ0aW5nVGFnQ291bnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IGdldExvb3BQb3NpdGlvblByb2R1Y2VzSW52YWxpZFhNTEVycm9yKHtcbiAgICAgICAgdGFnOiBmaXJzdChwYWlyKS5wYXJ0LnZhbHVlLFxuICAgICAgICBvZmZzZXQ6IFtmaXJzdChwYWlyKS5wYXJ0Lm9mZnNldCwgbGFzdChwYWlyKS5wYXJ0Lm9mZnNldF1cbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBfZXhwYW5kVGFncyRfaSA9IGV4cGFuZFRhZ3NbX2k2XSxcbiAgICAgICAgY29udGFpbnMgPSBfZXhwYW5kVGFncyRfaS5jb250YWlucyxcbiAgICAgICAgZXhwYW5kID0gX2V4cGFuZFRhZ3MkX2kuZXhwYW5kLFxuICAgICAgICBvbmx5VGV4dEluVGFnID0gX2V4cGFuZFRhZ3MkX2kub25seVRleHRJblRhZztcbiAgICAgIGlmIChoYXMoY29udGFpbnMsIHhtbEVsZW1lbnRzKSkge1xuICAgICAgICBpZiAob25seVRleHRJblRhZykge1xuICAgICAgICAgIHZhciBsZWZ0ID0gZ2V0TGVmdE9yTnVsbChwb3N0cGFyc2VkLCBjb250YWlucywgcGFpclswXS5vZmZzZXQpO1xuICAgICAgICAgIHZhciByaWdodCA9IGdldFJpZ2h0T3JOdWxsKHBvc3RwYXJzZWQsIGNvbnRhaW5zLCBwYWlyWzFdLm9mZnNldCk7XG4gICAgICAgICAgaWYgKGxlZnQgPT09IG51bGwgfHwgcmlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAwOyAvLyBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2h1bmtzID0gY2h1bmtCeShwb3N0cGFyc2VkLnNsaWNlKGxlZnQsIHJpZ2h0KSwgZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHJldHVybiBpc1RhZ1N0YXJ0KGNvbnRhaW5zLCBwKSA/IFwic3RhcnRcIiA6IGlzVGFnRW5kKGNvbnRhaW5zLCBwKSA/IFwiZW5kXCIgOiBudWxsO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBmaXJzdENodW5rID0gZmlyc3QoY2h1bmtzKTtcbiAgICAgICAgICB2YXIgbGFzdENodW5rID0gbGFzdChjaHVua3MpO1xuICAgICAgICAgIHZhciBmaXJzdENvbnRlbnQgPSBmaXJzdENodW5rLmZpbHRlcihpc0NvbnRlbnQpO1xuICAgICAgICAgIHZhciBsYXN0Q29udGVudCA9IGxhc3RDaHVuay5maWx0ZXIoaXNDb250ZW50KTtcbiAgICAgICAgICBpZiAoZmlyc3RDb250ZW50Lmxlbmd0aCAhPT0gMSB8fCBsYXN0Q29udGVudC5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAwOyAvLyBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHY6IHtcbiAgICAgICAgICAgIHZhbHVlOiBleHBhbmRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBfcmV0O1xuICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBleHBhbmRUYWdzLmxlbmd0aDsgX2k2KyspIHtcbiAgICBfcmV0ID0gX2xvb3AoKTtcbiAgICBpZiAoX3JldCA9PT0gMCkgY29udGludWU7XG4gICAgaWYgKF9yZXQpIHJldHVybiBfcmV0LnY7XG4gIH1cbiAgcmV0dXJuIHt9O1xufVxuZnVuY3Rpb24gZ2V0RXhwYW5kTGltaXQocGFydCwgaW5kZXgsIHBvc3RwYXJzZWQsIG9wdGlvbnMpIHtcbiAgdmFyIGV4cGFuZFRvID0gcGFydC5leHBhbmRUbyB8fCBvcHRpb25zLmV4cGFuZFRvO1xuICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSB0aGlzIGNvbmRpdGlvbiBjYW4gYmUgcmVtb3ZlZCBpbiB2NCAodGhlIG9ubHkgdXNhZ2Ugd2FzIHRoZSBpbWFnZSBtb2R1bGUgYmVmb3JlIHZlcnNpb24gMy4xMi4zIG9mIHRoZSBpbWFnZSBtb2R1bGVcbiAgaWYgKCFleHBhbmRUbykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG4gIHZhciByaWdodCwgbGVmdDtcbiAgdHJ5IHtcbiAgICBsZWZ0ID0gZ2V0TGVmdChwb3N0cGFyc2VkLCBleHBhbmRUbywgaW5kZXgpO1xuICAgIHJpZ2h0ID0gZ2V0UmlnaHQocG9zdHBhcnNlZCwgZXhwYW5kVG8sIGluZGV4KTtcbiAgfSBjYXRjaCAocm9vdEVycm9yKSB7XG4gICAgdmFyIGVyclByb3BzID0gX29iamVjdFNwcmVhZCh7XG4gICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgcm9vdEVycm9yOiByb290RXJyb3IsXG4gICAgICBwb3N0cGFyc2VkOiBwb3N0cGFyc2VkLFxuICAgICAgZXhwYW5kVG86IGV4cGFuZFRvLFxuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfSwgb3B0aW9ucy5lcnJvcik7XG4gICAgaWYgKG9wdGlvbnMub25FcnJvcikge1xuICAgICAgdmFyIGVycm9yUmVzdWx0ID0gb3B0aW9ucy5vbkVycm9yKGVyclByb3BzKTtcbiAgICAgIGlmIChlcnJvclJlc3VsdCA9PT0gXCJpZ25vcmVcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93RXhwYW5kTm90Rm91bmQoZXJyUHJvcHMpO1xuICB9XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdO1xufVxuZnVuY3Rpb24gZXhwYW5kT25lKF9yZWYsIHBhcnQsIHBvc3RwYXJzZWQsIG9wdGlvbnMpIHtcbiAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgbGVmdCA9IF9yZWYyWzBdLFxuICAgIHJpZ2h0ID0gX3JlZjJbMV07XG4gIHZhciBpbmRleCA9IHBvc3RwYXJzZWQuaW5kZXhPZihwYXJ0KTtcbiAgdmFyIGxlZnRQYXJ0cyA9IHBvc3RwYXJzZWQuc2xpY2UobGVmdCwgaW5kZXgpO1xuICB2YXIgcmlnaHRQYXJ0cyA9IHBvc3RwYXJzZWQuc2xpY2UoaW5kZXggKyAxLCByaWdodCArIDEpO1xuICB2YXIgaW5uZXIgPSBvcHRpb25zLmdldElubmVyKHtcbiAgICBwb3N0cGFyc2U6IG9wdGlvbnMucG9zdHBhcnNlLFxuICAgIGluZGV4OiBpbmRleCxcbiAgICBwYXJ0OiBwYXJ0LFxuICAgIGxlZnRQYXJ0czogbGVmdFBhcnRzLFxuICAgIHJpZ2h0UGFydHM6IHJpZ2h0UGFydHMsXG4gICAgbGVmdDogbGVmdCxcbiAgICByaWdodDogcmlnaHQsXG4gICAgcG9zdHBhcnNlZDogcG9zdHBhcnNlZFxuICB9KTtcbiAgaWYgKCFpbm5lci5sZW5ndGgpIHtcbiAgICBpbm5lci5leHBhbmRlZCA9IFtsZWZ0UGFydHMsIHJpZ2h0UGFydHNdO1xuICAgIGlubmVyID0gW2lubmVyXTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGxlZnQ6IGxlZnQsXG4gICAgcmlnaHQ6IHJpZ2h0LFxuICAgIGlubmVyOiBpbm5lclxuICB9O1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eSAqL1xuZnVuY3Rpb24gZXhwYW5kVG9PbmUocG9zdHBhcnNlZCwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmIChwb3N0cGFyc2VkLmVycm9ycykge1xuICAgIGVycm9ycyA9IHBvc3RwYXJzZWQuZXJyb3JzO1xuICAgIHBvc3RwYXJzZWQgPSBwb3N0cGFyc2VkLnBvc3RwYXJzZWQ7XG4gIH1cbiAgdmFyIGxpbWl0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9zdHBhcnNlZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwYXJ0ID0gcG9zdHBhcnNlZFtpXTtcbiAgICBpZiAocGFydC50eXBlID09PSBcInBsYWNlaG9sZGVyXCIgJiYgcGFydC5tb2R1bGUgPT09IG9wdGlvbnMubW9kdWxlTmFtZSAmJlxuICAgIC8qXG4gICAgICogVGhlIHBhcnQuc3VicGFyc2VkIGNoZWNrIGlzIHVzZWQgdG8gZml4IHRoaXMgZ2l0aHViIGlzc3VlIDpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vb3Blbi14bWwtdGVtcGxhdGluZy9kb2N4dGVtcGxhdGVyL2lzc3Vlcy82NzFcbiAgICAgKi9cbiAgICAhcGFydC5zdWJwYXJzZWQgJiYgIXBhcnQuZXhwYW5kZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBsaW1pdCA9IGdldEV4cGFuZExpbWl0KHBhcnQsIGksIHBvc3RwYXJzZWQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIWxpbWl0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9saW1pdCA9IF9zbGljZWRUb0FycmF5KGxpbWl0LCAyKSxcbiAgICAgICAgICBsZWZ0ID0gX2xpbWl0WzBdLFxuICAgICAgICAgIHJpZ2h0ID0gX2xpbWl0WzFdO1xuICAgICAgICBsaW1pdHMucHVzaCh7XG4gICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIGxlZnRQYXJ0OiBwb3N0cGFyc2VkW2xlZnRdLFxuICAgICAgICAgIHJpZ2h0UGFydDogcG9zdHBhcnNlZFtyaWdodF1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBUaGUgRXJyb3IgY2FuIG9ubHkgYmUgYVxuICAgICAgICBlcnJvcnMucHVzaChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxpbWl0cy5zb3J0KGZ1bmN0aW9uIChsMSwgbDIpIHtcbiAgICBpZiAobDEubGVmdCA9PT0gbDIubGVmdCkge1xuICAgICAgcmV0dXJuIGwyLnBhcnQubEluZGV4IDwgbDEucGFydC5sSW5kZXggPyAxIDogLTE7XG4gICAgfVxuICAgIHJldHVybiBsMi5sZWZ0IDwgbDEubGVmdCA/IDEgOiAtMTtcbiAgfSk7XG4gIHZhciBtYXhSaWdodCA9IC0xO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgZm9yICh2YXIgX2k3ID0gMCwgX2xlbiA9IGxpbWl0cy5sZW5ndGg7IF9pNyA8IF9sZW47IF9pNysrKSB7XG4gICAgdmFyIF9wb3N0cGFyc2VkO1xuICAgIHZhciBfbGltaXQyID0gbGltaXRzW19pN107XG4gICAgbWF4UmlnaHQgPSBNYXRoLm1heChtYXhSaWdodCwgX2k3ID4gMCA/IGxpbWl0c1tfaTcgLSAxXS5yaWdodCA6IDApO1xuICAgIGlmIChfbGltaXQyLmxlZnQgPCBtYXhSaWdodCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGV4cGFuZE9uZShbX2xpbWl0Mi5sZWZ0ICsgb2Zmc2V0LCBfbGltaXQyLnJpZ2h0ICsgb2Zmc2V0XSwgX2xpbWl0Mi5wYXJ0LCBwb3N0cGFyc2VkLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKG9wdGlvbnMub25FcnJvcikge1xuICAgICAgICB2YXIgZXJyb3JSZXN1bHQgPSBvcHRpb25zLm9uRXJyb3IoX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgcGFydDogX2xpbWl0Mi5wYXJ0LFxuICAgICAgICAgIHJvb3RFcnJvcjogZXJyb3IsXG4gICAgICAgICAgcG9zdHBhcnNlZDogcG9zdHBhcnNlZCxcbiAgICAgICAgICBleHBhbmRPbmU6IGV4cGFuZE9uZVxuICAgICAgICB9LCBvcHRpb25zLmVycm9ycykpO1xuICAgICAgICBpZiAoZXJyb3JSZXN1bHQgPT09IFwiaWdub3JlXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgWFRUZW1wbGF0ZUVycm9yKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG9mZnNldCArPSByZXN1bHQuaW5uZXIubGVuZ3RoIC0gKHJlc3VsdC5yaWdodCArIDEgLSByZXN1bHQubGVmdCk7XG4gICAgKF9wb3N0cGFyc2VkID0gcG9zdHBhcnNlZCkuc3BsaWNlLmFwcGx5KF9wb3N0cGFyc2VkLCBbcmVzdWx0LmxlZnQsIHJlc3VsdC5yaWdodCArIDEgLSByZXN1bHQubGVmdF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZXN1bHQuaW5uZXIpKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwb3N0cGFyc2VkOiBwb3N0cGFyc2VkLFxuICAgIGVycm9yczogZXJyb3JzXG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXhwYW5kVG9PbmU6IGV4cGFuZFRvT25lLFxuICBnZXRFeHBhbmRUb0RlZmF1bHQ6IGdldEV4cGFuZFRvRGVmYXVsdFxufTsiXSwibmFtZXMiOlsiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiciIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJUeXBlRXJyb3IiLCJBcnJheSIsImZyb20iLCJpc0FycmF5IiwiX2FycmF5TGlrZVRvQXJyYXkiLCJfc2xpY2VkVG9BcnJheSIsImUiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfbm9uSXRlcmFibGVSZXN0IiwiYSIsInQiLCJ0b1N0cmluZyIsImNhbGwiLCJzbGljZSIsIm5hbWUiLCJ0ZXN0IiwibGVuZ3RoIiwibiIsImwiLCJpIiwidSIsImYiLCJuZXh0IiwiT2JqZWN0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5IiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiU3RyaW5nIiwiTnVtYmVyIiwiX3JlcXVpcmUiLCJyZXF1aXJlIiwiZ2V0UmlnaHRPck51bGwiLCJnZXRSaWdodCIsImdldExlZnQiLCJnZXRMZWZ0T3JOdWxsIiwiY2h1bmtCeSIsImlzVGFnU3RhcnQiLCJpc1RhZ0VuZCIsImlzQ29udGVudCIsImxhc3QiLCJmaXJzdCIsIl9yZXF1aXJlMiIsIlhUVGVtcGxhdGVFcnJvciIsInRocm93RXhwYW5kTm90Rm91bmQiLCJnZXRMb29wUG9zaXRpb25Qcm9kdWNlc0ludmFsaWRYTUxFcnJvciIsImxhc3RUYWdJc09wZW5UYWciLCJ0YWdzIiwidGFnIiwiaW5uZXJMYXN0VGFnIiwic3Vic3RyIiwiaW5kZXhPZiIsImdldExpc3RYbWxFbGVtZW50cyIsInBhcnRzIiwicmVzdWx0IiwiX2kyIiwiX3BhcnRzJF9pIiwicG9zaXRpb24iLCJwb3AiLCJoYXMiLCJ4bWxFbGVtZW50cyIsIl9pNCIsInhtbEVsZW1lbnQiLCJjb25jYXQiLCJnZXRFeHBhbmRUb0RlZmF1bHQiLCJwb3N0cGFyc2VkIiwicGFpciIsImV4cGFuZFRhZ3MiLCJvZmZzZXQiLCJjbG9zaW5nVGFnQ291bnQiLCJzdGFydGluZ1RhZ0NvdW50IiwiZXJyb3IiLCJwYXJ0IiwiX2xvb3AiLCJfZXhwYW5kVGFncyRfaSIsIl9pNiIsImNvbnRhaW5zIiwiZXhwYW5kIiwib25seVRleHRJblRhZyIsImxlZnQiLCJyaWdodCIsImNodW5rcyIsInAiLCJmaXJzdENodW5rIiwibGFzdENodW5rIiwiZmlyc3RDb250ZW50IiwibGFzdENvbnRlbnQiLCJ2IiwiX3JldCIsImdldEV4cGFuZExpbWl0IiwiaW5kZXgiLCJvcHRpb25zIiwiZXhwYW5kVG8iLCJyb290RXJyb3IiLCJlcnJQcm9wcyIsIm9uRXJyb3IiLCJlcnJvclJlc3VsdCIsImV4cGFuZE9uZSIsIl9yZWYiLCJfcmVmMiIsImxlZnRQYXJ0cyIsInJpZ2h0UGFydHMiLCJpbm5lciIsImdldElubmVyIiwicG9zdHBhcnNlIiwiZXhwYW5kZWQiLCJleHBhbmRUb09uZSIsImVycm9ycyIsImxpbWl0cyIsImxlbiIsInR5cGUiLCJtb2R1bGUiLCJtb2R1bGVOYW1lIiwic3VicGFyc2VkIiwibGltaXQiLCJfbGltaXQiLCJsZWZ0UGFydCIsInJpZ2h0UGFydCIsInNvcnQiLCJsMSIsImwyIiwibEluZGV4IiwibWF4UmlnaHQiLCJfaTciLCJfbGVuIiwiX3Bvc3RwYXJzZWQiLCJfbGltaXQyIiwiTWF0aCIsIm1heCIsInNwbGljZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/traits.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/utils.js":
/*!************************************************!*\
  !*** ./node_modules/docxtemplater/js/utils.js ***!
  \************************************************/
/***/ ((module) => {

eval("\nfunction last(a) {\n    return a[a.length - 1];\n}\nfunction first(a) {\n    return a[0];\n}\nmodule.exports = {\n    last: last,\n    first: first\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLEtBQUtDLENBQUM7SUFDYixPQUFPQSxDQUFDLENBQUNBLEVBQUVDLE1BQU0sR0FBRyxFQUFFO0FBQ3hCO0FBQ0EsU0FBU0MsTUFBTUYsQ0FBQztJQUNkLE9BQU9BLENBQUMsQ0FBQyxFQUFFO0FBQ2I7QUFDQUcsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZMLE1BQU1BO0lBQ05HLE9BQU9BO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaWtlLXJlbnRhbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvdXRpbHMuanM/NWMzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gbGFzdChhKSB7XG4gIHJldHVybiBhW2EubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBmaXJzdChhKSB7XG4gIHJldHVybiBhWzBdO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxhc3Q6IGxhc3QsXG4gIGZpcnN0OiBmaXJzdFxufTsiXSwibmFtZXMiOlsibGFzdCIsImEiLCJsZW5ndGgiLCJmaXJzdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/xml-matcher.js":
/*!******************************************************!*\
  !*** ./node_modules/docxtemplater/js/xml-matcher.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"), pregMatchAll = _require.pregMatchAll;\nmodule.exports = function xmlMatcher(content, tagsXmlArray) {\n    var res = {\n        content: content\n    };\n    var taj = tagsXmlArray.join(\"|\");\n    var regexp = new RegExp(\"(?:(<(?:\".concat(taj, \")[^>]*>)([^<>]*)</(?:\").concat(taj, \")>)|(<(?:\").concat(taj, \")[^>]*/>)\"), \"g\");\n    res.matches = pregMatchAll(regexp, res.content);\n    return res;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy94bWwtbWF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLElBQUlBLFdBQVdDLG1CQUFPQSxDQUFDLDBFQUFnQixHQUNyQ0MsZUFBZUYsU0FBU0UsWUFBWTtBQUN0Q0MsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLFdBQVdDLE9BQU8sRUFBRUMsWUFBWTtJQUN4RCxJQUFJQyxNQUFNO1FBQ1JGLFNBQVNBO0lBQ1g7SUFDQSxJQUFJRyxNQUFNRixhQUFhRyxJQUFJLENBQUM7SUFDNUIsSUFBSUMsU0FBUyxJQUFJQyxPQUFPLFdBQVdDLE1BQU0sQ0FBQ0osS0FBSyx5QkFBeUJJLE1BQU0sQ0FBQ0osS0FBSyxhQUFhSSxNQUFNLENBQUNKLEtBQUssY0FBYztJQUMzSEQsSUFBSU0sT0FBTyxHQUFHWixhQUFhUyxRQUFRSCxJQUFJRixPQUFPO0lBQzlDLE9BQU9FO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaWtlLXJlbnRhbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMveG1sLW1hdGNoZXIuanM/YjBmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpLFxuICBwcmVnTWF0Y2hBbGwgPSBfcmVxdWlyZS5wcmVnTWF0Y2hBbGw7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhtbE1hdGNoZXIoY29udGVudCwgdGFnc1htbEFycmF5KSB7XG4gIHZhciByZXMgPSB7XG4gICAgY29udGVudDogY29udGVudFxuICB9O1xuICB2YXIgdGFqID0gdGFnc1htbEFycmF5LmpvaW4oXCJ8XCIpO1xuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cChcIig/Oig8KD86XCIuY29uY2F0KHRhaiwgXCIpW14+XSo+KShbXjw+XSopPC8oPzpcIikuY29uY2F0KHRhaiwgXCIpPil8KDwoPzpcIikuY29uY2F0KHRhaiwgXCIpW14+XSovPilcIiksIFwiZ1wiKTtcbiAgcmVzLm1hdGNoZXMgPSBwcmVnTWF0Y2hBbGwocmVnZXhwLCByZXMuY29udGVudCk7XG4gIHJldHVybiByZXM7XG59OyJdLCJuYW1lcyI6WyJfcmVxdWlyZSIsInJlcXVpcmUiLCJwcmVnTWF0Y2hBbGwiLCJtb2R1bGUiLCJleHBvcnRzIiwieG1sTWF0Y2hlciIsImNvbnRlbnQiLCJ0YWdzWG1sQXJyYXkiLCJyZXMiLCJ0YWoiLCJqb2luIiwicmVnZXhwIiwiUmVnRXhwIiwiY29uY2F0IiwibWF0Y2hlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/xml-matcher.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/docxtemplater/js/xml-templater.js":
/*!********************************************************!*\
  !*** ./node_modules/docxtemplater/js/xml-templater.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n    for(var t = 0; t < r.length; t++){\n        var o = r[t];\n        o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n}\nfunction _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n        writable: !1\n    }), e;\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/./node_modules/docxtemplater/js/doc-utils.js\"), pushArray = _require.pushArray, wordToUtf8 = _require.wordToUtf8, convertSpaces = _require.convertSpaces;\nvar xmlMatcher = __webpack_require__(/*! ./xml-matcher.js */ \"(rsc)/./node_modules/docxtemplater/js/xml-matcher.js\");\nvar Lexer = __webpack_require__(/*! ./lexer.js */ \"(rsc)/./node_modules/docxtemplater/js/lexer.js\");\nvar Parser = __webpack_require__(/*! ./parser.js */ \"(rsc)/./node_modules/docxtemplater/js/parser.js\");\nvar _render = __webpack_require__(/*! ./render.js */ \"(rsc)/./node_modules/docxtemplater/js/render.js\");\nvar postrender = __webpack_require__(/*! ./postrender.js */ \"(rsc)/./node_modules/docxtemplater/js/postrender.js\");\nvar resolve = __webpack_require__(/*! ./resolve.js */ \"(rsc)/./node_modules/docxtemplater/js/resolve.js\");\nvar joinUncorrupt = __webpack_require__(/*! ./join-uncorrupt.js */ \"(rsc)/./node_modules/docxtemplater/js/join-uncorrupt.js\");\nfunction _getFullText(content, tagsXmlArray) {\n    var matcher = xmlMatcher(content, tagsXmlArray);\n    var result = matcher.matches.map(function(match) {\n        return match.array[2];\n    });\n    return wordToUtf8(convertSpaces(result.join(\"\")));\n}\nmodule.exports = /*#__PURE__*/ function() {\n    function XmlTemplater(content, options) {\n        _classCallCheck(this, XmlTemplater);\n        this.cachedParsers = {};\n        this.content = content;\n        for(var key in options){\n            this[key] = options[key];\n        }\n        this.setModules({\n            inspect: {\n                filePath: options.filePath\n            }\n        });\n    }\n    return _createClass(XmlTemplater, [\n        {\n            key: \"resolveTags\",\n            value: function resolveTags(tags) {\n                var _this = this;\n                this.tags = tags;\n                var options = this.getOptions();\n                var filePath = this.filePath;\n                options.scopeManager = this.scopeManager;\n                options.resolve = resolve;\n                var errors = [];\n                return Promise.all(this.modules.map(function(module1) {\n                    return Promise.resolve(module1.preResolve(options))[\"catch\"](function(e) {\n                        errors.push(e);\n                    });\n                })).then(function() {\n                    if (errors.length !== 0) {\n                        throw errors;\n                    }\n                    return resolve(options).then(function(_ref) {\n                        var resolved = _ref.resolved, errors = _ref.errors;\n                        errors = errors.map(function(error) {\n                            var _error;\n                            // If a string is thrown, convert it to a real Error\n                            if (!(error instanceof Error)) {\n                                error = new Error(error);\n                            }\n                            /*\n             * error properties might not be defined if some foreign error\n             * (unhandled error not thrown by docxtemplater willingly) is\n             * thrown.\n             */ (_error = error).properties || (_error.properties = {});\n                            error.properties.file = filePath;\n                            return error;\n                        });\n                        if (errors.length !== 0) {\n                            throw errors;\n                        }\n                        return Promise.all(resolved).then(function(resolved) {\n                            options.scopeManager.root.finishedResolving = true;\n                            options.scopeManager.resolved = resolved;\n                            _this.setModules({\n                                inspect: {\n                                    resolved: resolved,\n                                    filePath: filePath\n                                }\n                            });\n                            return resolved;\n                        });\n                    })[\"catch\"](function(error) {\n                        _this.errorChecker(error);\n                        throw error;\n                    });\n                });\n            }\n        },\n        {\n            key: \"getFullText\",\n            value: function getFullText() {\n                return _getFullText(this.content, this.fileTypeConfig.tagsXmlTextArray);\n            }\n        },\n        {\n            key: \"setModules\",\n            value: function setModules(obj) {\n                for(var _i2 = 0, _this$modules2 = this.modules; _i2 < _this$modules2.length; _i2++){\n                    var _module = _this$modules2[_i2];\n                    _module.set(obj);\n                }\n            }\n        },\n        {\n            key: \"preparse\",\n            value: function preparse() {\n                this.allErrors = [];\n                this.xmllexed = Lexer.xmlparse(this.content, {\n                    text: this.fileTypeConfig.tagsXmlTextArray,\n                    other: this.fileTypeConfig.tagsXmlLexedArray\n                });\n                this.setModules({\n                    inspect: {\n                        filePath: this.filePath,\n                        xmllexed: this.xmllexed\n                    }\n                });\n                var _Lexer$parse = Lexer.parse(this.xmllexed, this.delimiters, this.syntax, this.fileType), lexed = _Lexer$parse.lexed, lexerErrors = _Lexer$parse.errors;\n                pushArray(this.allErrors, lexerErrors);\n                this.lexed = lexed;\n                this.setModules({\n                    inspect: {\n                        filePath: this.filePath,\n                        lexed: this.lexed\n                    }\n                });\n                var options = this.getOptions();\n                this.lexed = Parser.preparse(this.lexed, this.modules, options);\n            }\n        },\n        {\n            key: \"parse\",\n            value: function parse() {\n                var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, noPostParse = _ref2.noPostParse;\n                this.setModules({\n                    inspect: {\n                        filePath: this.filePath\n                    }\n                });\n                var options = this.getOptions();\n                this.parsed = Parser.parse(this.lexed, this.modules, options);\n                this.setModules({\n                    inspect: {\n                        filePath: this.filePath,\n                        parsed: this.parsed\n                    }\n                });\n                if (noPostParse) {\n                    return this;\n                }\n                // In v4, we could remove this \"this.postparse()\" so that users have to call this manually.\n                return this.postparse();\n            }\n        },\n        {\n            key: \"postparse\",\n            value: function postparse() {\n                var options = this.getOptions();\n                var _Parser$postparse = Parser.postparse(this.parsed, this.modules, options), postparsed = _Parser$postparse.postparsed, postparsedErrors = _Parser$postparse.errors;\n                this.postparsed = postparsed;\n                this.setModules({\n                    inspect: {\n                        filePath: this.filePath,\n                        postparsed: this.postparsed\n                    }\n                });\n                pushArray(this.allErrors, postparsedErrors);\n                this.errorChecker(this.allErrors);\n                return this;\n            }\n        },\n        {\n            key: \"errorChecker\",\n            value: function errorChecker(errors) {\n                for(var _i4 = 0, _errors2 = errors; _i4 < _errors2.length; _i4++){\n                    var error = _errors2[_i4];\n                    /*\n         * error properties might not be defined if some foreign\n         * (unhandled error not thrown by docxtemplater willingly) is\n         * thrown.\n         */ error.properties || (error.properties = {});\n                    error.properties.file = this.filePath;\n                }\n                for(var _i6 = 0, _this$modules4 = this.modules; _i6 < _this$modules4.length; _i6++){\n                    var _module2 = _this$modules4[_i6];\n                    errors = _module2.errorsTransformer(errors);\n                }\n            }\n        },\n        {\n            key: \"baseNullGetter\",\n            value: function baseNullGetter(part, sm) {\n                var _this2 = this;\n                var value = this.modules.reduce(function(value, module1) {\n                    if (value != null) {\n                        return value;\n                    }\n                    return module1.nullGetter(part, sm, _this2);\n                }, null);\n                if (value != null) {\n                    return value;\n                }\n                return this.nullGetter(part, sm);\n            }\n        },\n        {\n            key: \"getOptions\",\n            value: function getOptions() {\n                return {\n                    compiled: this.postparsed,\n                    cachedParsers: this.cachedParsers,\n                    tags: this.tags,\n                    modules: this.modules,\n                    parser: this.parser,\n                    contentType: this.contentType,\n                    relsType: this.relsType,\n                    baseNullGetter: this.baseNullGetter.bind(this),\n                    filePath: this.filePath,\n                    fileTypeConfig: this.fileTypeConfig,\n                    fileType: this.fileType,\n                    linebreaks: this.linebreaks,\n                    stripInvalidXMLChars: this.stripInvalidXMLChars\n                };\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(to) {\n                this.filePath = to;\n                var options = this.getOptions();\n                options.resolved = this.scopeManager.resolved;\n                options.scopeManager = this.scopeManager;\n                options.render = _render;\n                options.joinUncorrupt = joinUncorrupt;\n                var _render2 = _render(options), errors = _render2.errors, parts = _render2.parts;\n                if (errors.length > 0) {\n                    this.allErrors = errors;\n                    this.errorChecker(errors);\n                    return this;\n                }\n                this.content = postrender(parts, options);\n                this.setModules({\n                    inspect: {\n                        filePath: this.filePath,\n                        content: this.content\n                    }\n                });\n                return this;\n            }\n        }\n    ]);\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy94bWwtdGVtcGxhdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWIsU0FBU0EsUUFBUUMsQ0FBQztJQUFJO0lBQTJCLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVVGLENBQUM7UUFBSSxPQUFPLE9BQU9BO0lBQUcsSUFBSSxTQUFVQSxDQUFDO1FBQUksT0FBT0EsS0FBSyxjQUFjLE9BQU9DLFVBQVVELEVBQUVHLFdBQVcsS0FBS0YsVUFBVUQsTUFBTUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFBRyxHQUFHRCxRQUFRQztBQUFJO0FBQzdULFNBQVNLLGdCQUFnQkMsQ0FBQyxFQUFFQyxDQUFDO0lBQUksSUFBSSxDQUFFRCxDQUFBQSxhQUFhQyxDQUFBQSxHQUFJLE1BQU0sSUFBSUMsVUFBVTtBQUFzQztBQUNsSCxTQUFTQyxrQkFBa0JDLENBQUMsRUFBRUMsQ0FBQztJQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRCxFQUFFRSxNQUFNLEVBQUVELElBQUs7UUFBRSxJQUFJWixJQUFJVyxDQUFDLENBQUNDLEVBQUU7UUFBRVosRUFBRWMsVUFBVSxHQUFHZCxFQUFFYyxVQUFVLElBQUksQ0FBQyxHQUFHZCxFQUFFZSxZQUFZLEdBQUcsQ0FBQyxHQUFHLFdBQVdmLEtBQU1BLENBQUFBLEVBQUVnQixRQUFRLEdBQUcsQ0FBQyxJQUFJQyxPQUFPQyxjQUFjLENBQUNSLEdBQUdTLGVBQWVuQixFQUFFb0IsR0FBRyxHQUFHcEI7SUFBSTtBQUFFO0FBQ3ZPLFNBQVNxQixhQUFhWCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQztJQUFJLE9BQU9ELEtBQUtGLGtCQUFrQkMsRUFBRU4sU0FBUyxFQUFFTyxJQUFJQyxLQUFLSCxrQkFBa0JDLEdBQUdFLElBQUlLLE9BQU9DLGNBQWMsQ0FBQ1IsR0FBRyxhQUFhO1FBQUVNLFVBQVUs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Ry9GO2dCQUNqQmlCLFFBQVFkLGFBQWEsR0FBR0E7Z0JBQ3hCLElBQUk4RixXQUFXakcsUUFBUWlCLFVBQ3JCVyxTQUFTcUUsU0FBU3JFLE1BQU0sRUFDeEJzRSxRQUFRRCxTQUFTQyxLQUFLO2dCQUN4QixJQUFJdEUsT0FBT25ELE1BQU0sR0FBRyxHQUFHO29CQUNyQixJQUFJLENBQUM2RSxTQUFTLEdBQUcxQjtvQkFDakIsSUFBSSxDQUFDZ0IsWUFBWSxDQUFDaEI7b0JBQ2xCLE9BQU8sSUFBSTtnQkFDYjtnQkFDQSxJQUFJLENBQUN2QixPQUFPLEdBQUdKLFdBQVdpRyxPQUFPakY7Z0JBQ2pDLElBQUksQ0FBQ0UsVUFBVSxDQUFDO29CQUNkQyxTQUFTO3dCQUNQQyxVQUFVLElBQUksQ0FBQ0EsUUFBUTt3QkFDdkJoQixTQUFTLElBQUksQ0FBQ0EsT0FBTztvQkFDdkI7Z0JBQ0Y7Z0JBQ0EsT0FBTyxJQUFJO1lBQ2I7UUFDRjtLQUFFO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iaWtlLXJlbnRhbC13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMveG1sLXRlbXBsYXRlci5qcz85MWY3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9kb2MtdXRpbHMuanNcIiksXG4gIHB1c2hBcnJheSA9IF9yZXF1aXJlLnB1c2hBcnJheSxcbiAgd29yZFRvVXRmOCA9IF9yZXF1aXJlLndvcmRUb1V0ZjgsXG4gIGNvbnZlcnRTcGFjZXMgPSBfcmVxdWlyZS5jb252ZXJ0U3BhY2VzO1xudmFyIHhtbE1hdGNoZXIgPSByZXF1aXJlKFwiLi94bWwtbWF0Y2hlci5qc1wiKTtcbnZhciBMZXhlciA9IHJlcXVpcmUoXCIuL2xleGVyLmpzXCIpO1xudmFyIFBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlci5qc1wiKTtcbnZhciBfcmVuZGVyID0gcmVxdWlyZShcIi4vcmVuZGVyLmpzXCIpO1xudmFyIHBvc3RyZW5kZXIgPSByZXF1aXJlKFwiLi9wb3N0cmVuZGVyLmpzXCIpO1xudmFyIHJlc29sdmUgPSByZXF1aXJlKFwiLi9yZXNvbHZlLmpzXCIpO1xudmFyIGpvaW5VbmNvcnJ1cHQgPSByZXF1aXJlKFwiLi9qb2luLXVuY29ycnVwdC5qc1wiKTtcbmZ1bmN0aW9uIF9nZXRGdWxsVGV4dChjb250ZW50LCB0YWdzWG1sQXJyYXkpIHtcbiAgdmFyIG1hdGNoZXIgPSB4bWxNYXRjaGVyKGNvbnRlbnQsIHRhZ3NYbWxBcnJheSk7XG4gIHZhciByZXN1bHQgPSBtYXRjaGVyLm1hdGNoZXMubWFwKGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBtYXRjaC5hcnJheVsyXTtcbiAgfSk7XG4gIHJldHVybiB3b3JkVG9VdGY4KGNvbnZlcnRTcGFjZXMocmVzdWx0LmpvaW4oXCJcIikpKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWG1sVGVtcGxhdGVyKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWG1sVGVtcGxhdGVyKTtcbiAgICB0aGlzLmNhY2hlZFBhcnNlcnMgPSB7fTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICBpbnNwZWN0OiB7XG4gICAgICAgIGZpbGVQYXRoOiBvcHRpb25zLmZpbGVQYXRoXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhYbWxUZW1wbGF0ZXIsIFt7XG4gICAga2V5OiBcInJlc29sdmVUYWdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmVUYWdzKHRhZ3MpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgIHZhciBmaWxlUGF0aCA9IHRoaXMuZmlsZVBhdGg7XG4gICAgICBvcHRpb25zLnNjb3BlTWFuYWdlciA9IHRoaXMuc2NvcGVNYW5hZ2VyO1xuICAgICAgb3B0aW9ucy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLm1vZHVsZXMubWFwKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtb2R1bGUucHJlUmVzb2x2ZShvcHRpb25zKSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUob3B0aW9ucykudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciByZXNvbHZlZCA9IF9yZWYucmVzb2x2ZWQsXG4gICAgICAgICAgICBlcnJvcnMgPSBfcmVmLmVycm9ycztcbiAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMubWFwKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIF9lcnJvcjtcbiAgICAgICAgICAgIC8vIElmIGEgc3RyaW5nIGlzIHRocm93biwgY29udmVydCBpdCB0byBhIHJlYWwgRXJyb3JcbiAgICAgICAgICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBlcnJvciBwcm9wZXJ0aWVzIG1pZ2h0IG5vdCBiZSBkZWZpbmVkIGlmIHNvbWUgZm9yZWlnbiBlcnJvclxuICAgICAgICAgICAgICogKHVuaGFuZGxlZCBlcnJvciBub3QgdGhyb3duIGJ5IGRvY3h0ZW1wbGF0ZXIgd2lsbGluZ2x5KSBpc1xuICAgICAgICAgICAgICogdGhyb3duLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAoX2Vycm9yID0gZXJyb3IpLnByb3BlcnRpZXMgfHwgKF9lcnJvci5wcm9wZXJ0aWVzID0ge30pO1xuICAgICAgICAgICAgZXJyb3IucHJvcGVydGllcy5maWxlID0gZmlsZVBhdGg7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IGVycm9ycztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJlc29sdmVkKS50aGVuKGZ1bmN0aW9uIChyZXNvbHZlZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5zY29wZU1hbmFnZXIucm9vdC5maW5pc2hlZFJlc29sdmluZyA9IHRydWU7XG4gICAgICAgICAgICBvcHRpb25zLnNjb3BlTWFuYWdlci5yZXNvbHZlZCA9IHJlc29sdmVkO1xuICAgICAgICAgICAgX3RoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgICAgICAgIGluc3BlY3Q6IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZDogcmVzb2x2ZWQsXG4gICAgICAgICAgICAgICAgZmlsZVBhdGg6IGZpbGVQYXRoXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIF90aGlzLmVycm9yQ2hlY2tlcihlcnJvcik7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZ1bGxUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZ1bGxUZXh0KCkge1xuICAgICAgcmV0dXJuIF9nZXRGdWxsVGV4dCh0aGlzLmNvbnRlbnQsIHRoaXMuZmlsZVR5cGVDb25maWcudGFnc1htbFRleHRBcnJheSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE1vZHVsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TW9kdWxlcyhvYmopIHtcbiAgICAgIGZvciAodmFyIF9pMiA9IDAsIF90aGlzJG1vZHVsZXMyID0gdGhpcy5tb2R1bGVzOyBfaTIgPCBfdGhpcyRtb2R1bGVzMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBfbW9kdWxlID0gX3RoaXMkbW9kdWxlczJbX2kyXTtcbiAgICAgICAgX21vZHVsZS5zZXQob2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlcGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyc2UoKSB7XG4gICAgICB0aGlzLmFsbEVycm9ycyA9IFtdO1xuICAgICAgdGhpcy54bWxsZXhlZCA9IExleGVyLnhtbHBhcnNlKHRoaXMuY29udGVudCwge1xuICAgICAgICB0ZXh0OiB0aGlzLmZpbGVUeXBlQ29uZmlnLnRhZ3NYbWxUZXh0QXJyYXksXG4gICAgICAgIG90aGVyOiB0aGlzLmZpbGVUeXBlQ29uZmlnLnRhZ3NYbWxMZXhlZEFycmF5XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgIGluc3BlY3Q6IHtcbiAgICAgICAgICBmaWxlUGF0aDogdGhpcy5maWxlUGF0aCxcbiAgICAgICAgICB4bWxsZXhlZDogdGhpcy54bWxsZXhlZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBfTGV4ZXIkcGFyc2UgPSBMZXhlci5wYXJzZSh0aGlzLnhtbGxleGVkLCB0aGlzLmRlbGltaXRlcnMsIHRoaXMuc3ludGF4LCB0aGlzLmZpbGVUeXBlKSxcbiAgICAgICAgbGV4ZWQgPSBfTGV4ZXIkcGFyc2UubGV4ZWQsXG4gICAgICAgIGxleGVyRXJyb3JzID0gX0xleGVyJHBhcnNlLmVycm9ycztcbiAgICAgIHB1c2hBcnJheSh0aGlzLmFsbEVycm9ycywgbGV4ZXJFcnJvcnMpO1xuICAgICAgdGhpcy5sZXhlZCA9IGxleGVkO1xuICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgaW5zcGVjdDoge1xuICAgICAgICAgIGZpbGVQYXRoOiB0aGlzLmZpbGVQYXRoLFxuICAgICAgICAgIGxleGVkOiB0aGlzLmxleGVkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgIHRoaXMubGV4ZWQgPSBQYXJzZXIucHJlcGFyc2UodGhpcy5sZXhlZCwgdGhpcy5tb2R1bGVzLCBvcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoKSB7XG4gICAgICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICBub1Bvc3RQYXJzZSA9IF9yZWYyLm5vUG9zdFBhcnNlO1xuICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgaW5zcGVjdDoge1xuICAgICAgICAgIGZpbGVQYXRoOiB0aGlzLmZpbGVQYXRoXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgIHRoaXMucGFyc2VkID0gUGFyc2VyLnBhcnNlKHRoaXMubGV4ZWQsIHRoaXMubW9kdWxlcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICBpbnNwZWN0OiB7XG4gICAgICAgICAgZmlsZVBhdGg6IHRoaXMuZmlsZVBhdGgsXG4gICAgICAgICAgcGFyc2VkOiB0aGlzLnBhcnNlZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChub1Bvc3RQYXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8vIEluIHY0LCB3ZSBjb3VsZCByZW1vdmUgdGhpcyBcInRoaXMucG9zdHBhcnNlKClcIiBzbyB0aGF0IHVzZXJzIGhhdmUgdG8gY2FsbCB0aGlzIG1hbnVhbGx5LlxuICAgICAgcmV0dXJuIHRoaXMucG9zdHBhcnNlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc3RwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0cGFyc2UoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgdmFyIF9QYXJzZXIkcG9zdHBhcnNlID0gUGFyc2VyLnBvc3RwYXJzZSh0aGlzLnBhcnNlZCwgdGhpcy5tb2R1bGVzLCBvcHRpb25zKSxcbiAgICAgICAgcG9zdHBhcnNlZCA9IF9QYXJzZXIkcG9zdHBhcnNlLnBvc3RwYXJzZWQsXG4gICAgICAgIHBvc3RwYXJzZWRFcnJvcnMgPSBfUGFyc2VyJHBvc3RwYXJzZS5lcnJvcnM7XG4gICAgICB0aGlzLnBvc3RwYXJzZWQgPSBwb3N0cGFyc2VkO1xuICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgaW5zcGVjdDoge1xuICAgICAgICAgIGZpbGVQYXRoOiB0aGlzLmZpbGVQYXRoLFxuICAgICAgICAgIHBvc3RwYXJzZWQ6IHRoaXMucG9zdHBhcnNlZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHB1c2hBcnJheSh0aGlzLmFsbEVycm9ycywgcG9zdHBhcnNlZEVycm9ycyk7XG4gICAgICB0aGlzLmVycm9yQ2hlY2tlcih0aGlzLmFsbEVycm9ycyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXJyb3JDaGVja2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVycm9yQ2hlY2tlcihlcnJvcnMpIHtcbiAgICAgIGZvciAodmFyIF9pNCA9IDAsIF9lcnJvcnMyID0gZXJyb3JzOyBfaTQgPCBfZXJyb3JzMi5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IF9lcnJvcnMyW19pNF07XG4gICAgICAgIC8qXG4gICAgICAgICAqIGVycm9yIHByb3BlcnRpZXMgbWlnaHQgbm90IGJlIGRlZmluZWQgaWYgc29tZSBmb3JlaWduXG4gICAgICAgICAqICh1bmhhbmRsZWQgZXJyb3Igbm90IHRocm93biBieSBkb2N4dGVtcGxhdGVyIHdpbGxpbmdseSkgaXNcbiAgICAgICAgICogdGhyb3duLlxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3IucHJvcGVydGllcyB8fCAoZXJyb3IucHJvcGVydGllcyA9IHt9KTtcbiAgICAgICAgZXJyb3IucHJvcGVydGllcy5maWxlID0gdGhpcy5maWxlUGF0aDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pNiA9IDAsIF90aGlzJG1vZHVsZXM0ID0gdGhpcy5tb2R1bGVzOyBfaTYgPCBfdGhpcyRtb2R1bGVzNC5sZW5ndGg7IF9pNisrKSB7XG4gICAgICAgIHZhciBfbW9kdWxlMiA9IF90aGlzJG1vZHVsZXM0W19pNl07XG4gICAgICAgIGVycm9ycyA9IF9tb2R1bGUyLmVycm9yc1RyYW5zZm9ybWVyKGVycm9ycyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJhc2VOdWxsR2V0dGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJhc2VOdWxsR2V0dGVyKHBhcnQsIHNtKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMubW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKHZhbHVlLCBtb2R1bGUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZS5udWxsR2V0dGVyKHBhcnQsIHNtLCBfdGhpczIpO1xuICAgICAgfSwgbnVsbCk7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5udWxsR2V0dGVyKHBhcnQsIHNtKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPcHRpb25zKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tcGlsZWQ6IHRoaXMucG9zdHBhcnNlZCxcbiAgICAgICAgY2FjaGVkUGFyc2VyczogdGhpcy5jYWNoZWRQYXJzZXJzLFxuICAgICAgICB0YWdzOiB0aGlzLnRhZ3MsXG4gICAgICAgIG1vZHVsZXM6IHRoaXMubW9kdWxlcyxcbiAgICAgICAgcGFyc2VyOiB0aGlzLnBhcnNlcixcbiAgICAgICAgY29udGVudFR5cGU6IHRoaXMuY29udGVudFR5cGUsXG4gICAgICAgIHJlbHNUeXBlOiB0aGlzLnJlbHNUeXBlLFxuICAgICAgICBiYXNlTnVsbEdldHRlcjogdGhpcy5iYXNlTnVsbEdldHRlci5iaW5kKHRoaXMpLFxuICAgICAgICBmaWxlUGF0aDogdGhpcy5maWxlUGF0aCxcbiAgICAgICAgZmlsZVR5cGVDb25maWc6IHRoaXMuZmlsZVR5cGVDb25maWcsXG4gICAgICAgIGZpbGVUeXBlOiB0aGlzLmZpbGVUeXBlLFxuICAgICAgICBsaW5lYnJlYWtzOiB0aGlzLmxpbmVicmVha3MsXG4gICAgICAgIHN0cmlwSW52YWxpZFhNTENoYXJzOiB0aGlzLnN0cmlwSW52YWxpZFhNTENoYXJzXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHRvKSB7XG4gICAgICB0aGlzLmZpbGVQYXRoID0gdG87XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgb3B0aW9ucy5yZXNvbHZlZCA9IHRoaXMuc2NvcGVNYW5hZ2VyLnJlc29sdmVkO1xuICAgICAgb3B0aW9ucy5zY29wZU1hbmFnZXIgPSB0aGlzLnNjb3BlTWFuYWdlcjtcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gX3JlbmRlcjtcbiAgICAgIG9wdGlvbnMuam9pblVuY29ycnVwdCA9IGpvaW5VbmNvcnJ1cHQ7XG4gICAgICB2YXIgX3JlbmRlcjIgPSBfcmVuZGVyKG9wdGlvbnMpLFxuICAgICAgICBlcnJvcnMgPSBfcmVuZGVyMi5lcnJvcnMsXG4gICAgICAgIHBhcnRzID0gX3JlbmRlcjIucGFydHM7XG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5hbGxFcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMuZXJyb3JDaGVja2VyKGVycm9ycyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250ZW50ID0gcG9zdHJlbmRlcihwYXJ0cywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICBpbnNwZWN0OiB7XG4gICAgICAgICAgZmlsZVBhdGg6IHRoaXMuZmlsZVBhdGgsXG4gICAgICAgICAgY29udGVudDogdGhpcy5jb250ZW50XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG59KCk7Il0sIm5hbWVzIjpbIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9jbGFzc0NhbGxDaGVjayIsImEiLCJuIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJlIiwiciIsInQiLCJsZW5ndGgiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl90b1Byb3BlcnR5S2V5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwiaSIsIl90b1ByaW1pdGl2ZSIsInRvUHJpbWl0aXZlIiwiY2FsbCIsIlN0cmluZyIsIk51bWJlciIsIl9yZXF1aXJlIiwicmVxdWlyZSIsInB1c2hBcnJheSIsIndvcmRUb1V0ZjgiLCJjb252ZXJ0U3BhY2VzIiwieG1sTWF0Y2hlciIsIkxleGVyIiwiUGFyc2VyIiwiX3JlbmRlciIsInBvc3RyZW5kZXIiLCJyZXNvbHZlIiwiam9pblVuY29ycnVwdCIsIl9nZXRGdWxsVGV4dCIsImNvbnRlbnQiLCJ0YWdzWG1sQXJyYXkiLCJtYXRjaGVyIiwicmVzdWx0IiwibWF0Y2hlcyIsIm1hcCIsIm1hdGNoIiwiYXJyYXkiLCJqb2luIiwibW9kdWxlIiwiZXhwb3J0cyIsIlhtbFRlbXBsYXRlciIsIm9wdGlvbnMiLCJjYWNoZWRQYXJzZXJzIiwic2V0TW9kdWxlcyIsImluc3BlY3QiLCJmaWxlUGF0aCIsInZhbHVlIiwicmVzb2x2ZVRhZ3MiLCJ0YWdzIiwiX3RoaXMiLCJnZXRPcHRpb25zIiwic2NvcGVNYW5hZ2VyIiwiZXJyb3JzIiwiUHJvbWlzZSIsImFsbCIsIm1vZHVsZXMiLCJwcmVSZXNvbHZlIiwicHVzaCIsInRoZW4iLCJfcmVmIiwicmVzb2x2ZWQiLCJlcnJvciIsIl9lcnJvciIsIkVycm9yIiwicHJvcGVydGllcyIsImZpbGUiLCJyb290IiwiZmluaXNoZWRSZXNvbHZpbmciLCJlcnJvckNoZWNrZXIiLCJnZXRGdWxsVGV4dCIsImZpbGVUeXBlQ29uZmlnIiwidGFnc1htbFRleHRBcnJheSIsIm9iaiIsIl9pMiIsIl90aGlzJG1vZHVsZXMyIiwiX21vZHVsZSIsInNldCIsInByZXBhcnNlIiwiYWxsRXJyb3JzIiwieG1sbGV4ZWQiLCJ4bWxwYXJzZSIsInRleHQiLCJvdGhlciIsInRhZ3NYbWxMZXhlZEFycmF5IiwiX0xleGVyJHBhcnNlIiwicGFyc2UiLCJkZWxpbWl0ZXJzIiwic3ludGF4IiwiZmlsZVR5cGUiLCJsZXhlZCIsImxleGVyRXJyb3JzIiwiX3JlZjIiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJub1Bvc3RQYXJzZSIsInBhcnNlZCIsInBvc3RwYXJzZSIsIl9QYXJzZXIkcG9zdHBhcnNlIiwicG9zdHBhcnNlZCIsInBvc3RwYXJzZWRFcnJvcnMiLCJfaTQiLCJfZXJyb3JzMiIsIl9pNiIsIl90aGlzJG1vZHVsZXM0IiwiX21vZHVsZTIiLCJlcnJvcnNUcmFuc2Zvcm1lciIsImJhc2VOdWxsR2V0dGVyIiwicGFydCIsInNtIiwiX3RoaXMyIiwicmVkdWNlIiwibnVsbEdldHRlciIsImNvbXBpbGVkIiwicGFyc2VyIiwiY29udGVudFR5cGUiLCJyZWxzVHlwZSIsImJpbmQiLCJsaW5lYnJlYWtzIiwic3RyaXBJbnZhbGlkWE1MQ2hhcnMiLCJyZW5kZXIiLCJ0byIsIl9yZW5kZXIyIiwicGFydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/docxtemplater/js/xml-templater.js\n");

/***/ })

};
;